{"./":{"url":"./","title":"Introduction","keywords":"","body":"前言 2022 年对我来说是相当忙碌的一年，这两年主要从事的工作围绕 Terraform Provider 以及 Terraform Module 社区方面，有幸被 HashiCorp 以及社区认可，在 2022 年获得了 HashiCorp Ambassador 的头衔。 2022 年为社区贡献了《Vault 中文手册》，然后试图编写《HashiStack 在中国》系列文章，可惜由于 2022 年上海封城，以及年底的疫情大爆发，增加了许多的困难，以至于没有能够为社区贡献太多的优秀内容，但是我会继续致力于推广 HashiCorp 技术栈的义务劳动，争取将更多的优秀内容带给中文互联网的读者们。我也看到了越来越多的中国公司和团队开始积极拥抱 Terraform，目前虽然我们仍然不是主流，但所谓趋势就是，一旦萌芽就无法再倒退的，我很有信心将来 IaC 也必将在中国成为主流。 还是让我们回到 HashiCorp 将云的自动化切分的四个层面： 基础设施 安全 网络 应用程序 HashiCorp 定义的基础设施层实际上不止有 Terraform，还有一个叫 Packer 的工具： 我曾经把 Terraform 文档中关键部分翻译为中文电子书《Terraform 入门教程》，现如今在国际上 Terraform 几乎已经成为了大型企业用云的主流交互方式，不少 500 强团队选择只通过 Terraform 来操作云端的资源。 但是我也同时发现不少读者在咨询和讨论的过程中普遍存在的几种误解，有两种观点最为普遍： 我怎么登录到 Terraform 创建的服务器上用 Ansible 安装工具、库以及部署应用？ 能否只把 Terraform 作为一种批量创建集群的工具，集群创建完以后就不再使用 Terraform 管理，而是使用他们熟悉的老办法老工具来管理。 归根到底，这些误解都是源于没有理解“不可变的基础设施”这一 HashiCorp 哲学所致。 我发现如果要彻底贯彻“不可变的基础设施”，光靠 Terraform 的力量是不够的，因为它缺了很重要的一个环节 —— 如何用不可变的风格在虚拟机上安装各种各样的软件和依赖，并做恰当的配置。乍听起来这是一个充满矛盾的叙述，既然“不可变”，又何谓安装和配置？ 如果要用一句话来描述 Packer 存在的必要性，那就是：你不会使用“创建一个容器实例后登录进容器安装各种依赖和要运行的应用程序”的方式来部署容器应用，但很多人会用这种方式来部署虚拟机应用，请问容器和虚拟机在这里本质的区别是什么以至于无法使用同一种方式来部署应用？Packer 之于虚拟机，就有些类似于 Dockerfile 之于容器。 我曾经心中发愿，要把 Terraform、Vault、Consul、Nomad 这四大 HashiCorp 支柱产品的文档翻译成中文，推广到中文互联网，目前这个目标已经完成了一半。但是剩下的 Consul 与 Nomad 都是非常艰巨的任务，而 Packer 的工作量会小一些，同时缺失了 Packer 的普及会给 Terraform 在中国的推广带来许多的麻烦，很多团队仍然会使用可变风格的方式误用 Terraform，所以今年打算先把 Packer 的文档翻了，巩固一下基础设施即代码方面的地基。 Packer 并非 HashiCorp 的一等公民，好在其功能也没有四大主要产品那么庞大复杂，所以本手册将基本按照官方文档的顺序进行翻译和编写。 如果读者满足以下一条或者多条情况，那么可能就是本书的目标读者： 从事运维、开发或者架构工作 已经或即将开始在生产环境使用 Terraform 对 HashiCorp 技术栈感兴趣 不喜欢或者没有时间阅读英文文档 本书编写时使用的是 Packer 1.8.5 版本。如果读者发现某些内容已经由于版本更新而不再准确时敬请包涵，并且以官方文档为准。 如同 HashiCorp 很多工具一样，今天的 Packer 实际上有两个版本：Packer 开源版，以及 HashiCorp 托管的 Packer 云服务版(HCP Packer)。本书将聚焦于开源版的内容，对其他版本感兴趣的读者敬请自行查阅相关文档。 这本电子书的内容将主要是以官方文档、文章的译文为主，另外由于 Packer 也类似 Vault 与 Terraform 那样采取了插件式设计，它可以与大量三方系统进行集成，所以笔者有限的精力无法涵盖所有的插件，只能依照个人喜好选择一二进行翻译，如有没有包括的部分烦请移步官方文档。笔者也无法同时精通这些不同平台和产品的知识，虽然竭尽自己驽钝的脑力也无法确保对各种知识的肤浅理解没有错误，所以具有相关领域专业知识的读者如果读到什么地方感觉到不对，请不要犹豫，这几乎可以肯定是笔者能力不足导致的错误，敬请以你的专业知识为准。 Packer 在历史上曾经有一套用 JSON 来定义的模板，但随着发展，目前主力开发已经主要转向了基于 HCL2 的新模板，各种新功能也只针对 HCL2 模板开发，所以译者也就乐得偷懒，本书将略过对遗留的 JSON 模板的翻译。 由于笔者的能力有限，书中如有错误在所难免，敬请方家届时能够不吝斧正赐教，万望读者海涵，在此先行谢过。 Markdown 格式中的问题 由于使用的 GitBook 插件的限制，如果在 Markdown 的反引号中使用了 {{}} 模板，并且模板中的变量没有相对应的定义，那么 GitBook 会报错 Template render error: expected variable end，所以读者有时会看到 { {} } 这样在花括号中间插入了空格的现象，这并不是 Packer 模板文档原文的格式，但并不影响我们正常使用。 马驰排除条款 本电子书使用 CC-BY-SA-4.0 license 授权发布，读者可以在该协议的许可范围内自由阅读、引用或是使用本电子书的内容，但以下情况除外： 禁止名为“马驰”的特定个人实体阅读、引用、复制本电子书的内容 禁止在名为“马驰”的特定个人实体所拥有的任何设备上打开、保存本书的内容或是离线副本、拷贝 禁止在名为“马驰”的特定个人实体打印、抄写本书内容，或是保有本书内容的非数字化副本（包含并不限于书籍、手抄本、照片等） 禁止在与名为“马驰”的特定个人实体有劳动关系、股权关系，或是与其直系亲属有关联的企业、团体所拥有的任何电子设备上打开、保存本电子书的内容或是离线副本、拷贝 以上情况均会被视为侵权行为。若读者名为“马驰”，但不知道自己是否是该条款所禁止的特定“马驰”个人实体，可以在本书 GitHub 仓库 中提交 issue 与作者确认。 任何人在复制、修改和重分发本电子书的过程中禁止删除、修改本条款。 "},"1.what_is_packer/overview.html":{"url":"1.what_is_packer/overview.html","title":"什么是 Packer","keywords":"","body":""},"1.what_is_packer/1.immutable_infrasturcture.html":{"url":"1.what_is_packer/1.immutable_infrasturcture.html","title":"拥抱不可变的基础设施","keywords":"","body":"什么是不可变基础设施(Immutable Infrastructure) 原文 HashiCorp 之道的一个关键方面是不可变的概念，即一旦我们创造了一个东西，我们就不会在创建之后改变它。我们经常被问到的一件事是，“可变风格和不可变风格之间有什么区别？它们之间的优势或权衡是什么？” 可变风格的基础设施 让我们举个例子来描述两种风格的不同。假设我正在创建一个服务器，可能是一台虚拟机，也可能是裸金属(Bare Metal)机，这并不重要。我们称它为网络服务器。 我将部署例如 Apache 2.4 作为 Web 服务器程序，然后再部署我的应用程序。我们称它为网络服务器版本 1。现在我们看到有网络流量传入，用户正在向这个服务发出请求。 但随着时间的推移，我想做出改变，也许是想升级 Web 应用程序的版本，也许是想部署最新版本的 Apache ，又或者我想切换到不同的 Web 服务器，比如 NGINX。要考虑的事情是我们已经定义了我们的网络服务器版本 1。我们要做的是定义我们想要的版本 2 的样子。我们假设将要升级 Web 应用程序的版本到版本 2，并使用 NGINX 取代 Apache。 我们需要在版本 2 中使用 NGINX，如果使用可变风格的基础设施管理，我们要做的是尝试将现有的服务器升级到这个新的版本 2 配置。我们直接进入服务器，修改数据与状态，使之含有版本 2 的新配置。 这个过程通常是通过使用 Chef、Puppet、Ansible 等配置管理之类的工具来完成。我们可以在一开始运行配置管理工具将服务器配置成版本 1，然后当我们决定从版本 1 升级到版本 2 时再运行一次配置管理工具。 这么做的优点是，我们在一台正在运行的服务器上执行的变更。也许我们已经在本地写入了一些数据，并且我们的 Web 服务器正在使用这些数据。当我们就地更新时，我们不必操心将数据拷贝到其他机器、创建新机器，所有的基础设施已经在那里了，我们要做的就是执行升级。 可变风格的挑战，以及与之相关需要权衡的是：如果不能完美升级会怎样？在现实世界中，事情是会出错的。当我们开始升级时，我们要做的第一件事就是：“我们需要安装这个新版本的 NGINX，因为我们以前不用 NGINX。” 我们将尝试运行 apt-get 安装 NGINX ，但安装可能会失败。比如，在我们运行该工具的那一刻，我们的网络不稳定，也许 DNS 服务不可用，也许我们的 APT 存储库没有响应。谁知道，有一百万种可能导致失败的原因。 安装失败导致我们此时处于这样一种奇怪的状态：没有成功安装 NGNIX，但成功红部署了我们的 Web 应用程序的版本 2。我们测试过版本 2，我们知道该版本可以搭配 NGINX 一起工作，我们已经测试并验证过这个组合了。我们同样理解、验证和测试过基于 Apache 和我们的 Web 服务器的版本 1 的组合。 但现在我们两个版本都不是。我们陷入了一个奇怪的版本： 1.56。我们的 Apache 仍在运行，我们没有安装 NGINX，与此同时我们有一个新版本的 Web 服务（它只能与 NGINX 搭配工作）。 我们可以称之为部分升级，如果我们从数据库领域的角度考虑，它就是一个部分提交的事务。一部分变化发生了，一部分变化没有发生。 可变性的权衡 这对我们有何启示？这种升级过程引入了风险：我们可能处于半失败的情况。另一方面，它增加了复杂性。如果我们运行过测试，我们就会了解版本 1 的情况。我们测试并验证了该版本。版本 2 也一样，它是被测试并验证过的。 我们从未测试或验证过 1.56。我们不了解 1.56，因为我们从来没有预料到会是这个状态。现在对我们来说，搞清楚是否有从版本 1.56 版到版本 2 版的可能升级路径，以及当流量现在达到版本 1.56时用户的体验如何，是很复杂的。 网站是否正常运行，是否出现错误，发生了什么？这些问题对于即便是单台服务器来说都很复杂，现在想象一下我有一个由数百或数千台机器组成的集群，它们各自都以略有不同的方式发生过故障。也许其中一个安装 NGINX 失败，而另一个安装了 NGINX 但没有安装 web 服务程序。也许第三台机器无法卸载 Apache，所以您最终会看到“好吧，我们有版本 1.56 的这台服务器，那台则是版本 1.54，那台是版本 1.78”。 我们这时必须重新审视我们的版本控制，将其视为一个连续的范围，而不是将其视为离散的版本 1 和版本 2，所有的内容都有可能处于中间状态，这将成为一个非常复杂的场景。 你可能会说这种假设不切实际。在实践中，99% 的情况下可变风格都能正常工作。确实如此，但问题是，某样东西有 99% 的概率可以正常工作，乘以一千台机器，这意味着在相当多的时间里，它是行不通的。您最终会遇到这些复杂的调试问题：十分之一的请求出现错误，或者十分之一的请求比应有的速度稍慢。 这些系统变得异常难以调试，因为系统正处于一种难以理解的状态。 这让我们想到了另一种思考方式，即，相对于这种可变风格的管理方式，不可变风格基础设施又是怎么样的？ 不可变风格的基础设施 不可变风格的不同之处在于，我们不会就地更新状态。服务器被创建后，我们永远不会尝试将其升级到 版本 2。我们将创建我们的服务器，将其称为版本 1，我们将安装 Apache，我们将安装我们的 Web 服务程序，然后我们将制作该虚拟机的快照，我们将创建的快照称为服务器的版本 1。 我们将使用该快照对用的镜像创建虚拟机，然后我们将引导用户流量流入其中。太好了，我们已经部署了服务的版本 1，就像我们在可变配置中所做的那样。但是当我们要升级到版本 2 时，我们要做的是创建一个全新的服务器，该服务器将安装 Web 服务程序的 版本 2，另外安装 NGINX，这就是 Web 服务器的版本 2。这一切都将发生在一台新的虚拟机上，我们不会去变更版本 1 服务器上的文件和状态。 如果安装过程中发生任何错误，我们可以中止创建，删除所有中间制品然后再试一次。但是如果我们成功创建了版本 2，过程中没有发生错误，一切都被正确安装配置好了，那么我们要做的就是切换流量。我们的用户现在开始访问版本 2 而不是版本 1。然后我们将停用版本 1。我们将把该版本的虚拟机停机或是删除，我们的目标是，不尝试修改这个系统。 这让我们拥有了一个离散的版本控制。流量要么通往版本 1，要么通往版本 2。没有中间区域，两者之间没有版本 1.5。这样做的好处是，当我们考虑风险和复杂性时，风险要低得多，因为我们没有这些未经验证的未定义状态，同时我们也降低了基础设施的复杂性。 我们可以说我们在版本 1 中有 50 台机器，在版本 2 中有 20 台机器，而不是有一些机器和不同版本的分布。这个样子的基础设施管理起来复杂度就要低得多。 不可变性的权衡 不可变风格并不是在任何情况下都可以直接采纳的。如果这个应用程序有状态怎么办？如果这个应用程序正在往本地磁盘写入对应用程序很重要的数据怎么办。这种情况下，创建一个新机器然后删除老机器，包括它的数据，包括它的磁盘，显然是行不通的。 为了在这种场景下使用不可变风格，我们通常需要做的是将数据外部化。与其将数据和应用放在一起，不如使用共享的外部数据库。两个版本的服务器可以同时使用一个数据库。 当我用这种方法切换到不可变风格时，我们不用担心会破坏机器上的数据，因为我们已经将数据保存在机器外部了。数据的外部化是我们在这种场景下应用不可变模式的关键所在。一般来说，诸如数据库这样的系统更新频率往往远小于我们的应用程序，所以我们可以说，“你知道吗，我们将使用可变方法来管理数据库，因为它不太更新，而且我们不会因为数据迁移而烦恼。” 也可能我们的应用部署在云上，并且使用了 Elastic Block Store 或外部的软件定义存储之类的技术，也许底层磁盘是可变风格的，但是运行我们数据库的机器仍然可以是不可变风格的。 我们可以关闭正在运行的虚拟机，比如说我们有一台服务器安装了MySQL 7，我们将关闭它，我们将启动一个运行 MySQL 8 的新虚拟机，并将它重新连接到同一个磁盘。通过这种方式，数据本身并没有丢失，只是机器、计算从一个版本迁移到了另一个版本。 有多种不同的方法可以实践不可变基础设施。它与可变风格基础设施相比根本的区别是：我们是在现有基础设施上原地变更，还是创建新的基础设施，取代并销毁旧的版本？ 这是可变基础设施和不可变基础设施之间的核心区别。 "},"1.what_is_packer/2.what_is_packer.html":{"url":"1.what_is_packer/2.what_is_packer.html","title":"什么是 Packer","keywords":"","body":"Packer 是什么 原文 1 原文 2 Packer 是一种用单一配置源为多个平台创建相同的镜像的开源工具。Packer 可以运行于各种主流操作系统，本身相当轻量，性能很高，可以为多个平台并行创建镜像。 Packer 不会取代像 Chef 或 Puppet 那样的配置管理工具。实际上，在构建镜像时，Packer 可以使用 Chef 或 Puppet 等工具将软件安装到镜像上。 一个镜像是一个单一的静态单元，包含预配置的操作系统和已安装的软件，用于快速创建新的实例。镜像格式因平台而异，例如用于 EC2 的 AMI、用于 VMware 的 VMDK/VMX 文件、VirtualBox 虚拟机导出的的 OVF 等。 为什么要用 Packer 使用预制的主机镜像有许多的优点，但大多数团队很难用好，因为镜像的创建和管理是一件非常繁琐乏味的事。要么没有现成的工具来自动创建镜像，要么是工具的学习曲线太陡峭。结果是，在有 Packer 之前，通过创建镜像实现不可变基础设施c会影响到操作团队的敏捷性，因此尽管有巨大的收益，但并没有被广泛使用。 Packer 改变了这一切。 Packer 可以自动创建任何类型的镜像，它通过鼓励您使用 Chef 或 Puppet 等工具在 Packer 制作的镜像中安装和配置软件来拥抱现代配置管理。 换句话说：Packer 提供了现代化的预制镜像体验，释放未开发的潜力并开启新的机会。 Packer 的优点 超快速的基础设施部署 使用 Packer 镜像允许您在几秒钟内启动完全安装和配置完的机器，而不是几分钟或几小时。这不仅有利于生产，也有利于开发，因为开发虚拟机也可以在几秒钟内启动，而无需等待通常更长的配置时间。 跨云跨平台 由于 Packer 可以在多个平台上创建相同的镜像，您可以在 AWS 中运行生产，在 OpenStack 等私有云中进行“预演/QA”，并在 VMware 或 VirtualBox 等桌面虚拟化解决方案中进行开发。每个环境都运行相同的机器映像，提供了终极的可移植性。 提高了稳定性 Packer 在构建镜像时为机器安装和配置所有软件。如果这些脚本中存在错误，它们会及早被发现，而不是在机器启动后几分钟才被发现。 更高的可测试性 构建机器镜像后，可以快速启动该机器镜像并进行冒烟测试以验证一切正常。如果测试通过，就可以确信从该镜像启动的任何其他机器都将正常运行。 Packer 使您能够轻松获得上述这些优势。 "},"2.terminology.html":{"url":"2.terminology.html","title":"术语","keywords":"","body":"Packer 术语 原文 在 Packer 文档中使用了一些术语，如果您以前没有使用过 Packer，它们的含义可能并不显而易见。幸运的是，这些术语的数量相对较少。此页面记录了理解和使用 Packer 所需的所有术语。术语按英文字母顺序排列以便快速参考。 制品(Artifact) - 制品是单次构建的结果，通常是一组 ID 或文件来表示机器镜像。每个构建器都会生成一个制品。例如，对于 Amazon EC2 构建器，制品是一组 AMI ID（每个 region 一个）。对于 VMware 构建器，制品是一个包含了所创建的虚拟机文件的目录。 构建(Build) - 构建是最终为某一个平台生成镜像的一个任务。可以同时并行运行多个构建。我们可以说：“一个构建生成了一个 AMI 来运行我们的 Web 应用程序”，也可以说：“Packer 现在正在为 VMware、AWS 和 VirtualBox 运行构建” 构建器(Builder) - 构建器是 Packer 用来为某一个目标平台创建机器镜像所使用的组件。构建器读取并应用一些配置来运行和生成机器镜像。构建器作为构建的一部分被调用，以创建实际生成的镜像。常见的构建器包括有 VirtualBox、VMware 和 Amazon EC2 等。 命令(Commands) - 命令是 Packer 程序提供的一组的子命令。一个例子是 build，通过 packer build 来调用。Packer 命令行程序附带了一组开箱即用的命令。 数据源(Data Source) - 数据源是 Packer 用来从外部获取数据并使其可在模板中使用的组件。常见的数据源有 Amazon AMI 和 Amazon Secrets Manager 等。 后处理器 - 后处理器是 Packer 的一个组件，它可以获取一个构建器或另一个后处理器的结果，对结果进行一定的处理来创建新的制品。常见的后处理器有上传制品、压缩并上传制品等。 配置器(Provisioner) - 配置器是 Packer 用来在正在运行中的机器上安装和配置软件的组件，配置器完成运行后 Packer 将虚拟机转化为一个静态的镜像。配置器完成了 Packer 安装配置所需要的软件的主要工作。常见的配置器有 shell 脚本、Chef、Puppet 等。 模板(Template) - 模板可以是 HCL 或 JSON 文件，它们通过配置 Packer 的各种组件来定义一个或多个构建。 Packer 能够读取并使用模板并行创建多个机器镜像。 "},"3.install_packer.html":{"url":"3.install_packer.html","title":"安装 Packer","keywords":"","body":"安装 Packer 原文 Packer 可以通过以下方式安装： 使用预编译的二进制文件。我们为所有支持的平台和架构发布二进制文件。这是官方最推荐的安装方法。 从源代码安装。仅建议高级用户使用此方法。 使用您系统的包管理器安装。 手动安装预编译的二进制文件 要安装预编译的二进制文件，请为您的系统下载适当的包。目前 Packer 被打包为一个 zip 文件。 下载 Packer 后，解压压缩包，有一个文件名为 packer 的二进制可执行文件。 最后，确保 packer 可执行文件被正确配置在 PATH 里。此过程将因您的操作系统而异。 在 Linux 平台上可以用以下命令打印当前的 PATH： $ echo $PATH 将 Packer 可执行文件移动到列出的位置之一。我们假设执行该命令时可执行文件正位于您的下载文件夹中，并且您的 PATH 里包括了 /usr/local/bin，但如果您的位置不同，可以进行定制化的修改： $ mv ~/Downloads/packer /usr/local/bin/ 要了解更多有关于 Linux 平台上添加可执行文件到 PATH 的信息，可以参考这篇 StackOverflow 帖子。 Windows 平台上配置 PATH 可以参考这篇 StackOverflow 帖子。 要从源代码编译，您需要正确安装和配置 Go 以及 PATH 中正确配置的 git。我们假设您已经正确安装了 Go，并且配置了正确的 GOPATH。 克隆代码仓库到本地： $ git clone https://github.com/hashicorp/packer.git 进入克隆下来的仓库，用以下命令构建并安装一个适用于当前构建环境的开发版： $ make dev 在 MacOS 上安装 Packer Homebrew 是适用于 Mac OS X 的免费开源包管理系统。从终端安装官方 Packer formula。 首先，安装 HashiCorp tap，这是我们所有 Homebrew 软件包的存储库： $ brew tap hashicorp/tap 现在，使用 hashicorp/tap/packer 安装 Packer： $ brew install hashicorp/tap/packer 请注意，该命令将安装一个签名的二进制文件，并随着每个新的官方版本自动更新。 要更新到最新版本，请运行： $ brew upgrade hashicorp/tap/packer 在 Windows 平台上使用 Chocolatey 安装 Packer Chocolatey 是适用于 Windows 的免费开源包管理系统。 如果您使用的是 Windows 和 Chocolatey，则可以通过运行 choco install 命令来安装 Packer： $ choco install packer 请注意，Chocolatey 包目前不是由 HashiCorp 维护的。 在 Ubuntu/Debian 上安装 Packer 添加 HashiCorp GPG 密钥。 $ curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - 添加 HashiCorp 官方 Linux 包仓库： $ sudo apt-add-repository \"deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" 更新仓库信息并执行安装： $ sudo apt-get update && sudo apt-get install packer 在 CentOS/RHEL 上安装 Packer 安装 yum-config-manager 来管理你的仓库： $ sudo yum install -y yum-utils 使用 yum-config-manager 添加 HashiCorp 官方 Linux 仓库： $ sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo 安装： $ sudo yum -y install packer 在 Fedora 上安装 Packer 安装 dnf config-manager 来管理您的仓库： $ sudo dnf install -y dnf-plugins-core 使用 dnf config-manager 添加 HashiCorp 官方 Linux 仓库： $ sudo dnf config-manager --add-repo https://rpm.releases.hashicorp.com/fedora/hashicorp.repo 安装： $ sudo dnf -y install packer 在 Amazon Linux 上安装 Packer 安装 yum-config-manager 来管理您的仓库： $ sudo yum install -y yum-utils 使用 yum-config-manager 添加 HashiCorp 官方 Linux 仓库： $ sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo 安装： $ sudo yum -y install packer 验证安装 安装 Packer 后，可以打开新的命令提示符或控制台并检查 packer 是否可用来验证安装是否有效： $ packer Usage: packer [--version] [--help] [] Available commands are: build build image(s) from template console creates a console for testing variable interpolation fix fixes templates from old versions of packer fmt Rewrites HCL2 config files to canonical format hcl2_upgrade transform a JSON template into an HCL2 configuration init Install missing plugins or upgrade plugins inspect see components of a template validate check that a template is valid version Prints the Packer version 如果看到 packer could not be found 的错误，那么您的 PATH 环境变量设置不正确。请返回并确保您的 PATH 变量包含安装 Packer 的目录。 如果一切正常，Packer 已安装，您就可以开始体验了！ 错误排查 在某些发行版中，可能默认安装了另一个名为 packer 的工具。以下错误表明存在名称冲突： $ packer /usr/share/cracklib/pw_dict.pwd: Permission denied /usr/share/cracklib/pw_dict: Permission denied 请注意，在 Arch Linux 上，主存储库和 AUR 中有一个名为 packer 的包。 AUR 中的 packer 包是 Arch 包管理工具的旧名称，它不是 HashiCorp Packer。 要修复该问题，请创建一个指向使用不同名称（如 packer.io）的 packer 的符号链接，或使用其绝对路径调用所需的 packer 程序二进制文件，例如：/usr/local/packer。 "},"4.cli/overview.html":{"url":"4.cli/overview.html","title":"命令行(CLI)","keywords":"","body":"Packer 命令行 (CLI) 原文 我们通过命令行界面操作 Packer，所有与 Packer 的交互都是通过 packer 工具完成的。与许多其他命令行工具一样，packer 工具需要一个子命令，并且该子命令也可能有其他选项。子命令使用 packer SUBCOMMAND 执行，其中 SUBCOMMAND 是您希望执行的实际命令。 如果单独运行 packer，将显示所有可用的子命令和它们所做的简要概要的帮助信息。除此之外，您还可以运行带有 -h 标志的任意 packer 命令来为特定子命令输出更详细的帮助。 本书将包含有关每个子命令的信息。 机器可读的输出 默认情况下，Packer 的输出非常易于人类阅读。它使用漂亮的格式、间距和颜色，以使 Packer 易于使用。但是，Packer 也考虑到了自动化场景。为此，Packer 也支持机器可读的输出设置，允许您在自动化环境中使用 Packer。 因为机器可读的输出格式是面向 Unix 工具设计的，所以它是易于被 awk/sed/grep 以及其他工具处理的，并提供了熟悉的接口，无需您学习新格式。 启用机器可读输出 可以通过对任意 Packer 命令添加 -machine-readable 标志位来启用机器可读的输出格式。这立即使所有输出在标准输出流上的信息变为机器可读的。日志信息（如果启用）会继续出现在标准错误流上。输出示例如下所示： $ packer -machine-readable version 1498365963,,version,1.0.2 1498365963,,version-prelease, 1498365963,,version-commit,3ead2750b+CHANGES 1498365963,,ui,say,Packer v1.0.2 我们将在后面的章节种将更详细地介绍该格式。但正如您所见，输出立即变得对机器友好。尝试其他的一些带有 -machine-readable 标志的命令看看！ 备注：-machine-readable 标志是为自动化环境设计的，并且与 -debug 标志是互斥的，后者是为交互式环境设计的。 机器可读的格式 机器可读格式是面向行的、以逗号分隔的文本格式。这使得使用标准 Unix 工具（例如 awk 或 grep）以及通用编程语言（例如 Ruby 或 Python）更加方便地进行解析。 格式为： timestamp,target,type,data... 每个组件解释如下： timestamp - 是消息打印时的 UTC Unix 时间戳。 target - 当调用 packer build 时，target 可以为空，也可以指定构建的名称，例如:amazon-ebs。当构建正在进行时它通常是空的，当引用特定构建的制品时它是构建名称。 type - 是正在输出的机器可读消息的类型。最常见的两种类型是 ui 和 artifact。 data - 是零个或多个与先前 type 关联的用逗号分隔的值。该数据的数量和含义取决于 type，因此我们必须阅读与类型相关的文档才能完全理解。 在格式化的过程中，如果数据包含逗号，它将替换为 %!(PACKER_COMMA)。这比用诸如 \\' 之类的转义字符要更好，因为它对 awk 之类的工具更友好。 格式化中遇到的换行符被替换为各自的标准转义序列。换行符在输出中变为 \\n。回车变为 \\r。 机器可读消息的类型 以下是一份我们可能会在机器可读输出中看到的类型的不完整列表，当你运行 packer build 时，你会看到这些数据类型： ui: 这表示所提供的信息是一个人类可读的字符串，即使我们设置成机器可读模式，它也会被发送到 stdout。与此类型相关联的有三种“数据”子类型： say: 在非机器可读的格式中，该类型表示加粗。通常它用于关于在构建过程中开始新步骤的公告 message: 最常用的消息类型，用于构建过程中的基本更新信息 error: 错误信息 artifact-count: 该类型数据告诉我们一个特定的构建产生了多少制品 artifact: 该数据类型告诉我们 Packer 在构建期间创建什么。输出的格式模式为： timestamp, buildname, artifact, artifact_number, key, value，其中 key 和 value 包含有关制品的信息。 一个例子：1539967803,,ui,say,\\n==> Builds finished. The artifacts of successful builds are: 1539967803,amazon-ebs,artifact-count,2 1539967803,amazon-ebs,artifact,0,builder-id,mitchellh.amazonebs 1539967803,amazon-ebs,artifact,0,id,eu-west-1:ami-04d23aca8bdd36e30 1539967803,amazon-ebs,artifact,0,string,AMIs were created:\\neu-west-1: ami-04d23aca8bdd36e30\\n 1539967803,amazon-ebs,artifact,0,files-count,0 1539967803,amazon-ebs,artifact,0,end 1539967803,,ui,say,--> amazon-ebs: AMIs were created:\\neu-west-1: ami-04d23aca8bdd36e30\\n 1539967803,amazon-ebs,artifact,1,builder-id, 1539967803,amazon-ebs,artifact,1,id, 1539967803,amazon-ebs,artifact,1,string, 1539967803,amazon-ebs,artifact,1,files-count,0 2018/10/19 09:50:03 waiting for all plugin processes to complete... 1539967803,amazon-ebs,artifact,1,end 运行 packer version 时，会看到这些数据类型： version: 正在运行的 Packer 的版本 version-prerelease: 如果当前版本是预发布版该值为 dev，否则为空字符串 version-commit: 当前使用的 Packer 所属分支的 git hash；一般用于 Packer 开发人员 自动补全 packer 命令具有可选的子命令启用自动补全功能，可以运行 packer -autocomplete-install 为您使用的 shell 启用该功能。这样做之后，您可以打开一个新的 shell 并使用该功能。 例如，假如我们在每个提示行的末尾输入一个 tab： $ packer p plugin build $ packer build - -color -debug -except -force "},"4.cli/1.init.html":{"url":"4.cli/1.init.html","title":"init","keywords":"","body":"init 命令 原文 ~> 注意：Packer 的 init 命令不适用于旧版 JSON 模板。您可以使用 hcl2_upgrade 命令将 JSON 配置文件升级到 HCL。 ~> 注意：Packer 的 init 命令仅适用于多组件插件 —— 也就是名字带有 packer-plugin- 前缀的插件。要安装单组件插件 —— 就是名字带有 packer-provisioner-、packer-builder-* 等前缀的插件 —— 您必须手动安装插件。 packer init 命令用于下载 Packer 插件二进制可执行文件。使用模板时应首先执行该命令。多次运行此命令总是安全的。尽管运行过程可能会出错，但此命令永远不会删除任何内容。 Packer 目前没有像 Terraform 那样的状态概念。也就是说，目前 packer init 只负责安装Packer插件。 目前，packer init 只能从 GitHub 上的公开项目中下载二进制文件。 GitHub 的公共 API 对每个 IP 每小时可以执行的未经身份验证的请求数做了限制。 Packer 将尽最大努力避免达到这些限制，在本机运行 Packer 的一般场景中，这应该不是问题。否则，您可以设置 PACKER_GITHUB_API_TOKEN 这个环境变量，以便每小时发起更多请求。前往您的个人访问令牌页面以生成新的 Github 令牌。 packer init 将列出所有已安装的插件，然后下载当前缺少的插件的最新版本。 packer init -upgrade 将尝试获取所有插件的最新版本。 使用 required_plugin 块引用一个插件： packer { required_plugins { happycloud = { version = \">= 2.7.0\" source = \"github.com/azr/happycloud\" } } } HashiCorp 官方没有对第三方 Packer 插件以及命名空间不在 hashicorp/* 下的插件进行验证；与所有开源工具一样，在使用新工具时请自行尽职调查。 插件的选择 插件的选择取决于 required_plugins 块中定义的源和版本约束。对于 github.com/azr/happycloud 这个声明所引用的插件，Packer 将查询其完全限定地址 https://github.com/azr/packer-plugin-happycloud 以查找与主机操作的版本约束相匹配的插件系统。 packer init 将安装与 required_plugins 部分中的定义的版本约束相匹配的最新版本。确保设置正确的版本约束。插件将被安装在插件目录中。 如果想要了解更多插件安装的原理，请阅读相关文档。 隐式引用插件 这是为将 Packer 发布与插件发布解耦而进行的一系列重大破坏性变更的一部分。为了使转换更容易，我们将把这些插件的组件标记为“已移出(moved out)”。如果在配置文件中引用了某个属于已移出插件的组件，但在 required_plugin 块中没有引用该插件，那么 packer init 将自动下载并安装该插件。然后 Packer 将显示警告并建议您将插件添加到 required_plugin 块中。我们建议您使用 required_plugin 块，即使您只使用官方插件，因为它允许您限制插件版本以避免将来出现意外。 选项 -upgrade - 除了安装缺少的插件，还会将已安装的插件更新到最新的可用版本（如果有新的更高版本）。请注意，升级行为仍然是遵守配置的版本约束的。 "},"4.cli/2.plugin/overview.html":{"url":"4.cli/2.plugin/overview.html","title":"plugin","keywords":"","body":"plugins 命令 原文 plugins 命令包含了一组与 Packer 的插件交互的子命令： $ packer plugins -h Usage: packer plugins [options] [args] This command groups subcommands for interacting with Packer plugins. Related but not under the \"plugins\" command : - \"packer init \" will install all plugins required by a config. Subcommands: install Install latest Packer plugin [matching version constraint] installed List all installed Packer plugin binaries remove Remove Packer plugins [matching a version] required List plugins required by a config 相关命令 packer init 将安装所有所需的插件 "},"4.cli/2.plugin/1.install.html":{"url":"4.cli/2.plugin/1.install.html","title":"install","keywords":"","body":"plugins install 原文 plugins install 子命令安装符合版本约束的 Packer 插件 $ packer plugins install -h Usage: packer plugins install [] This command will install the most recent compatible Packer plugin matching version constraint. When the version constraint is omitted, the most recent version will be installed. Ex: packer plugins install github.com/hashicorp/happycloud v1.2.3 相关命令 packer init 将安装所有所需的插件 "},"4.cli/2.plugin/2.installed.html":{"url":"4.cli/2.plugin/2.installed.html","title":"installed","keywords":"","body":"plugin installed 原文 plugins installed 子命令列出已安装的 Packer 插件 $ packer plugins installed -h Usage: packer plugins installed This command lists all installed plugin binaries that match with the current OS and architecture. Packer's API version will be ignored. 相关命令 packer init 将安装所有所需的插件 "},"4.cli/2.plugin/3.remove.html":{"url":"4.cli/2.plugin/3.remove.html","title":"remove","keywords":"","body":"plugins remove 原文 plugins remove 子命令删除符合版本约束的 Packer 插件 $ packer plugins remove -h Usage: packer plugins remove [] This command will remove all Packer plugins matching the version constraint for the current OS and architecture. When the version is omitted all installed versions will be removed. Ex: packer plugins remove github.com/hashicorp/happycloud v1.2.3 相关命令 packer init 将安装所有所需的插件 "},"4.cli/2.plugin/4.required.html":{"url":"4.cli/2.plugin/4.required.html","title":"required","keywords":"","body":"plugins required 原文 plugins required 命令列出了 Packer 配置所引用的所有插件以及符合约束限制的所有已安装二进制文件。对特定插件，Packer 在构建中将选择最新版本的插件二进制文件。 $ packer plugins required -h Usage: packer plugins required This command will list every Packer plugin required by a Packer config, in packer.required_plugins blocks. All binaries matching the required version constrain and the current OS and Architecture will be listed. The most recent version (and the first of the list) will be the one picked by Packer during a build. Ex: packer plugins required require.pkr.hcl Ex: packer plugins required path/to/folder/ 相关命令 packer init 将安装所有所需的插件 "},"4.cli/3.build.html":{"url":"4.cli/3.build.html","title":"build","keywords":"","body":"build 命令 原文 packer build 命令读取一个模板并运行其中定义的所有构建以生成一组制品。除非另有说明，否则模板中指定的各种构建是并行执行的。创建的制品将在构建结束时输出。 选项 -color=false - 禁用彩色输出。默认启用。 -debug - 禁用并行运行并启用调试模式。调试模式通知构建器输出调试信息。调试模式的确切行为由构建者定义。一般来说，构建者通常会在每个步骤之间停下来，等待键盘输入后再继续。这将允许用户进行状态检查等。 -except=foo,bar,baz - 在运行时排除具有给定逗号分隔名称的构建和后处理器。在遗留的 JSON 格式模板中，构建的默认名称为其构建器的类型（例如 docker 或 amazon-ebs 或 virtualbox-iso），除非是在配置中指定了特定的名称属性。在 HCL2 模板中，“名称”是 source 代码块的 name 标签，除非构建中 source 的定义添加了 name 配置选项。被跳过的后处理器之后定义的其他后处理器都不会运行。因为后处理器可以嵌套在数组中，所以不同的后处理器链仍然可以运行。名称为空的后处理器将被忽略。 -force - 当来自上游构建的制品阻止了构建运行时强制构建器运行。强制构建的确切行为由构建器来定义。通常，支持强制构建的构建器会从之前的构建中删除制品。这将允许用户重复构建，而无需事先手动清理这些制品。 -on-error - 选择在配置期间构建失败时要执行的操作，可设置为：cleanup、abort、ask 或是 run-cleanup-provisioner。默认值为 cleanup。请注意，这只会在配置器运行期间对构建产生影响，而在后处理器运行期间则不会生效，因为错误处理机制与是否保留运行中的实例以及相关制品有关，例如配置程序失败时在运行 Packer 的机器上生成的 SSH 密钥。 cleanup 清理之前工序留下的资源，删除临时文件和虚拟机。 abort 退出而不进行任何清理，这可能需要下一个构建使用 -force。 ask 给出提示并等待用户决定要清理、中止还是重试失败的步骤。 run-cleanup-provisioner 中止并退出，除了 error-cleanup-provisioner（如果有定义）之外不执行其他清理。 -only=foo,bar,baz - 仅运行指定的构建，名字用逗号分隔。在遗留 JSON 模板中，构建名称默认为其构建器的类型（例如 docker 、 amazon-ebs 、 virtualbox-iso），除非在配置中指定了特定的名称属性。在 HCL2 模板中，指定的名称是 source 块的 name 标签，除非内置的 source 定义添加了 name 配置选项。 -parallel-builds=N - 限制并行运行的构建数量，0 表示没有限制（默认为 0）。 -timestamp-ui - 在每个 ui 输出前添加一个 RFC3339 时间戳作为前缀。 -var - 设置一个 Packer 模板定义的变量的值。该选项可以多次使用。该功能在设置构建的版本号时很有用。 -var-file - 指定一个变量文件。 -warn-on-undeclared-var - 设置此标志后如果变量定义文件 (.pkrvars.hcl | .pkrvars.json) 中存在无匹配 variable 块的变量时返回一条警告。如果用 HCL2 模板定义构建，光是在变量文件中设置一个变量值不足以让其生效，因为还需要在模板文件 pkr.hcl 中为变量定义一个对应的 variable 块。默认情况下，当变量文件包含一个或多个未声明的变量时，packer build 不会发出警告。 "},"4.cli/4.console.html":{"url":"4.cli/4.console.html","title":"console","keywords":"","body":"console 命令 原文 packer console 命令允许您调试 Packer 变量插值(variable interpolations)。您可以在调用控制台时搭配正在使用的 Packer 配置来读取变量值，或者在调用控制台时使用 -var 或 -var-file 命令行选项设置变量值。 注意：console 命令自从 1.4.2 及以上版本可用。 注意：对于 HCL2 的 console 支持从 1.6.0 及更高版本起可用，不用指定配置文件，直接使用 packer console --config-type=hcl2 即可使用。 Go 模板（在代码中使用 {{..}}）在 HCL2 模式下不起作用。 输入要测试的插值，然后按 查看结果。 要退出控制台，请键入 exit 并按 ，或使用 Control-C。 $ packer console my_template.json console 命令支持选项的完整列表在帮助输出中可见，可以通过 packer console -h 查看。 选项 -var - 设置 Packer 模板中定义的一个变量的值。该选项可以多次使用。该功能在设置构建的版本号时很有用。示例：-var \"myvar=asdf\" -var-file - 从变量文件读取模板变量值。示例：-var-file myvars.json 交互模式命令 help - 显示 Packer 控制台的帮助文本。 exit - 退出控制台 variables - 打印从 -var 选项、-var-files 选项和模板读入控制台的所有变量的列表。 使用示例 —— JSON 模板的交互环境 我们假设使用名为 example_template.json 的 Packer 模板文件启动控制台： $ packer console example_template.json 我们将看到一个提示光标，允许我们输入模板函数并查看它们是如何计算的；例如，如果 example_template 模板有这样一个名为 myvar 的变量： \"variables\":{ \"myvar\": \"asdfasdf\" } 然后在 Packer 控制台中输入 {{user myvar}}，我们将看到 myvar 的值： > {{user \"myvar\"}} asdfasdf 在这里我们可以测试更复杂的插值： > {{user \"myvar\"}}-{{timestamp}} asdfasdf-1559854396 使用完控制台后，只需键入 exit 或 CTRL-C > exit $ 如果想设置一个变量值或指定一个变量文件，可以这样做： $ packer console -var \"myvar=fdsafdsa\" -var-file myvars.json example_template.json 如果不想设置变量值或指定变量文件，只想用 Packer 的引擎试验指定的模板，可以通过简单地调用 packer console ，不指定模板文件来实现。 使用示例 —— JSON 模板结合管道命令 如果我们只想查看特定的单个插值而不启动交互界面，我们可以通过打印字符串并通过管道传输到控制台命令来实现： $ echo | packer console 1559855090 使用示例 —— HCL2 模板的交互环境 如果没有指定配置文件，可以使用 packer console 来调试表达式语法和内置函数。 启动 要在包含 HCL2 配置文件的文件夹里启动会话，请运行： $ packer console folder/ Packer 将以 HCL2 模式在 folder/ 文件夹中启动。我们也可以直接设置一个 HCL2 格式的配置文件： $ packer console file.pkr.hcl 因为文件的后缀是 .pkr.hcl 所以 Packer会以 HCL2 模式启动。 如果我们不想指定配置文件，你可以设置 --config-type=hcl2 选项，Packer 将以 HCL2 模式启动： $ packer console --config-type=hcl2 执行脚本 packer console 命令可以在非交互式模式下使用，方法是通过管道将换行符分隔的命令传递给它。除非脚本中间发生错误，否则只会打印命令的最终输出。 例如： $ echo \"1 + 5\" | packer console 6 "},"4.cli/5.fix.html":{"url":"4.cli/5.fix.html","title":"fix","keywords":"","body":"fix 命令 原文 请注意：此命令在 HCL2 模板上尚不可用，当 Packer 对 HCL2 模板引入了破坏性变更以至于需要“修复”时会添加对应的支持。 packer fix 命令读取一个模板，并找到它向后不兼容的部分并将其更新，以便它可以与最新版本的 Packer 一起使用。更新了 Packer 版本后，应该运行 fix 命令以确保使用的模板适用于新版本。 fix 命令会将更改后的模板输出到标准输出，因此如果要将其保存到文件，则应使用标准操作系统特定技术重定向标准输出。例如，在 Linux 系统上，您可能想要这样做： $ packer fix old.json > new.json 如果由于任何原因修复失败，修复命令将以非零状态码退出。错误消息出现在标准错误上，因此如果我们重定向了输出，我们会看到错误消息。 即使 packer fix 没有对模板做任何事情，模板也会输出到标准输出。配置的顺序和缩进等内容可能会更改。然而，输出格式为了人类可读性而进行了美化的格式化。 一份 fix 命令执行的修复的完整列表可以在帮助输出中获得，可以通过 packer fix -h 查看。 选项 -validate=false - 关闭对模板的验证。默认情况下为 true。 "},"4.cli/6.fmt.html":{"url":"4.cli/6.fmt.html","title":"fmt","keywords":"","body":"fmt 命令 原文 packer fmt 命令可以用来将 HCL2 配置文件格式化为规范格式和样式。它不修改 JSON 文件 (.json)。此命令执行一个 HCL 语言样式习俗的子集，以及其他为了可读性所做的小幅调整。 packer fmt 显示将需要格式化的配置文件的名称，并将任何格式化的更改写回原始配置文件。 用法示例： 检查配置文件是否需要格式化，但不会写入更改： $ packer fmt -check . my-template.pkr.hcl 格式化一个配置文件，将变更写回原始文件： $ packer fmt my-template.pkr.hcl my-template.pkr.hcl 格式化配置文件，从 stdin 读取并写入 stdout： $ packer fmt - // You can use pipes to combine this feature with other command line options $ cat my-template.pkr.hcl | packer fmt - 选项 -check - 检查输入是否已正确格式化。如果所有输入的格式正确，退出状态将为 0，否则为非零 -diff - 显示任何格式更改的差异 -write=false - 不要将格式变更写入源文件（如果使用 -check，则始终禁用） - 从标准输入流读取格式更改并将它们写入标准输出流 "},"4.cli/7.inspect.html":{"url":"4.cli/7.inspect.html","title":"inspect","keywords":"","body":"inspect 命令 原文 packer inspect 命令读取模板并输出模板定义的各种组件。这可以帮助我们快速了解模板，而无需深入研究 HCL 本身。该命令会告诉我们诸如模板接收哪些变量、定义的构建器、配置器以及它们运行的​​顺序等信息。 当启用机器可读输出时，此命令非常有用。该命令以机器可解析的格式输出组件。 该命令不会验证各种组件的实际配置（这就是 validate 命令的用途），但它会根据需要验证模板的语法。 使用示例 给定一个基本的模板，一个可能的输出示例是： $ packer inspect template.pkr.hcl > input-variables: var.aws_access_key: \"\" var.aws_secret_key: \"\" > local-variables: > builds: > : sources: amazon-ebs.foo amazon-instance.bar virtualbox-iso.basic provisioners: shell post-processors: "},"4.cli/8.validate.html":{"url":"4.cli/8.validate.html","title":"validate","keywords":"","body":"validate 命令 原文 packer validate 命令被用于验证模板的语法和配置。该命令将在成功时返回零值退出，在失败时返回非零值退出。此外，如果模板未通过验证，则会输出所有的错误消息。 用法示例： $ packer validate my-template.pkr.hcl Template validation failed. Errors are shown below. Errors validating build 'vmware'. 1 error(s) occurred: * Either a path or inline script must be specified. 选项 -syntax-only - 只检查模板的语法，不验证配置。 -evaluate-datasources - 在验证模板时读取所有数据源。这只针对 HCL2 模板有效，因为 JSON 模板没有数据源，因此将忽略此选项。 警告：数据源可能依赖于外部服务来获取数据，如果所调用的服务涉及计费，可能会在验证时产生一些成本。 -except=foo,bar,baz - 在验证时排除具有给定逗号分隔名称的构建。在遗留的 JSON 格式模板中，构建的默认名称为其构建器的类型（例如 docker 或 amazon-ebs 或 virtualbox-iso），除非是在配置中指定了特定的名称属性。在 HCL2 模板中，“名称”是 source 代码块的 name 标签，除非构建中 source 的定义添加了 name 配置选项。 -no-warn-on-undeclared-var - 当变量定义文件包含未声明变量的变量赋值时，不发出警告。当传递给 HCL2 模板的变量文件含有大量未在模板中声明的变量时该选项将很有用。如果用 HCL2 模板定义构建，光是在变量文件中设置一个变量值不足以让其生效，因为还需要在模板文件 pkr.hcl 中为变量定义一个对应的 variable 块。默认情况下，当变量文件包含一个或多个未声明的变量时，packer validate 会发出警告。 -only=foo,bar,baz - 在验证时只验证具有给定逗号分隔名称的构建。在遗留的 JSON 格式模板中，构建的默认名称为其构建器的类型（例如 docker 或 amazon-ebs 或 virtualbox-iso），除非是在配置中指定了特定的名称属性。在 HCL2 模板中，“名称”是 source 代码块的 name 标签，除非构建中 source 的定义添加了 name 配置选项。 -machine-readable 将所有输出设置为机器可读的标准输出。日志记录（如果启用）会继续出现在标准错误流上。 -var - 设置一个 Packer 模板定义的变量的值。该选项可以多次使用。该功能在设置构建的版本号时很有用。 -var-file - 指定一个变量文件。 "},"5.template/overview.html":{"url":"5.template/overview.html","title":"模板","keywords":"","body":"Packer 模板 原文 Packer 的行为由 Packer 模板决定，模板由一系列让 Packer 遵循的声明和命令组成。模板告诉 Packer 使用什么插件（构建器、配置器、后处理器），如何配置每个插件，以及它们的运行顺序。 模板包含灵活的变量注入工具，以及可以帮助我们对构建进行定制化的内置函数。 Packer 过去一直使用 JSON 模板进行配置，但 Packer 正在过渡到使用 HCL2 的新模板配置格式 —— 与 Terraform 以及 HashiCorp 的其他产品使用的配置语言相同。这种格式比原来的 JSON 模板格式更灵活、更模块化、更简洁。虽然仍然支持 JSON 格式，但 Packer 核心中的某些新功能将仅针对较新的 HCL 格式实现。请在边栏中查找不同模板格式的文档。 从 1.7.0 版本开始，HCL2 正式成为编写 Packer 配置的首选方式。 如果您需要获得将 JSON 模板升级到 HCL 模板方面的帮助，请在此处查看我们的升级指南。 "},"5.template/1.hcl/overview.html":{"url":"5.template/1.hcl/overview.html","title":"HCL 模板","keywords":"","body":"HCL 配置语言 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 Packer 使用 HashiCorp 配置语言 - HCL - 来对获取构建文件所需的步骤进行简明描述。本页详尽描述了 HCL2 的特性，如果您想快速尝试 HCL2，您还可以阅读 HCL2 入门指南。 构建(Builds) 使用 HCL 的主要目的是定义构建和构建源(sources)。所有其他语言特性的存在只是为了使构建的定义更加灵活和方便。 packer build 需要一个参数。当参数是目录时，将使用 HCL2 格式解析文件夹中名称以 .pkr.hcl 或 .pkr.json 结尾的所有文件。当参数是以 .pkr.hcl 或 .pkr.json 结尾的文件名时，将使用 HCL2 模式对其进行解析。对于所有其他情况；将使用仅解析 JSON 格式的 Packer 旧模式。 参数、块和表达式 HCL 语言的语法由几个基本元素组成： source \"amazon-ebs\" \"main\" { ami_name = \"main-ami\" } \"\" \"\" { # Block body = # Argument } 块(Blocks)是其他内容的容器，通常表示某种对象的配置，如 soruce。块有一个块类型，可以有零个或多个标签，并且有一个包含任意数量的参数和嵌套块的主体。Packer 的大部分功能都由配置文件中的顶级块控制。 参数(Arguments)为名称分配一个值。它们出现在块内。 表达式(表达式)表示一个值，可以是字面值，也可以是通过引用和组合其他值来表示的。它们作为参数的值出现，或出现在其他表达式中。 有关 Packer 语法的完整详细信息，请参阅： 配置语法 表达式 代码组织 HCL 语言使用以 .pkr.hcl 文件扩展名命名的配置文件。还有一种基于 JSON 的语言变体，以 .pkr.json 文件扩展名命名。 配置文件必须始终使用 UTF-8 编码，并且按照惯例通常使用 Unix 样式的行结尾 (LF) 而不是 Windows 样式的行结尾 (CRLF) 进行维护，尽管两者都被接受。 配置顺序 顶级块的顺序并不重要。build 块中 provisioner 块或 post-processor 块的顺序是唯一需要注意排序的例子。 "},"5.template/1.hcl/1.blocks/overview.html":{"url":"5.template/1.hcl/1.blocks/overview.html","title":"代码块","keywords":"","body":"内建代码块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅遗留的 Json 模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 Packer - HCL2 语言包含许多可用于配置构建的内建块。块是配置的容器。 最重要的块可以分为几个主要类型： builder 块包含用于创建特定镜像制品的构建器、配置器和后处理器的组合配置。 source 块包含构建器插件的配置。一旦定义，可以在 builder 块中使用并进一步配置源信息。 provisioner 块包含配置器插件的配置。provisioner 块是存在于 builder 块内部的嵌套块。 post-processor 和 post-processors 包含后处理器插件和后处理器插件序列的配置。这两个块也是存在于 builder 块内部的嵌套块。 variable 块包含变量的配置，这些变量可以在配置中设置默认值，也可以由用户在运行时设置。 locals 块包含中间变量的配置，这些中间变量可以使用 HCL 函数或数据源创建，或者由 variable 块中声明的变量组合而成。 本电子书包含每种块类型的信息。 其他块，例如 packer 块，对 Packer 进程提供了该配置文件允许运行哪个版本 Packer 执行的信息。 required_plugins 块有助于 Packer 进程了解配置文件所需要的插件来源及版本信息。 块可以在多个文件中定义，packer build folder 命令将仅使用名为 folder 的目录中的文件进行构建。 Packer 不支持用户自定义块，因此只能使用语言中内置的块。本电子书包括所有可用的内置 HCL2 块。 配置样例 # variables.pkr.hcl variable \"foo\" { type = string default = \"the default value of the `foo` variable\" description = \"description of the `foo` variable\" sensitive = false # When a variable is sensitive all string-values from that variable will be # obfuscated from Packer's output. } variable 块的文档 # locals.pkr.hcl locals { # locals can be bare values like: wee = local.baz # locals can also be set with other variables : baz = \"Foo is '${var.foo}' but not '${local.wee}'\" } # Use the singular local block if you need to mark a local as sensitive local \"mylocal\" { expression = \"${var.secret_api_key}\" sensitive = true } locals 块的文档 # sources.pkr.hcl source \"happycloud\" \"foo\" { // ... } source 块的文档 # build.pkr.hcl build { # use the `name` field to name a build in the logs. # For example this present config will display # \"buildname.amazon-ebs.example-1\" and \"buildname.amazon-ebs.example-2\" name = \"buildname\" sources = [ # use the optional plural `sources` list to simply use a `source` # without changing any field. \"source.amazon-ebs.example-1\", ] source \"source.amazon-ebs.example-2\" { # Use the singular `source` block set specific fields. # Note that fields cannot be overwritten, in other words, you cannot # set the 'output' field from the top-level source block and here. output = \"different value\" name = \"differentname\" } provisioner \"shell\" { scripts = fileset(\".\", \"scripts/{install,secure}.sh\") } post-processor \"shell-local\" { inline = [\"echo Hello World from ${source.type}.${source.name}\"] } } builder 块的文档 # datasource.pkr.hcl data \"amazon-ami\" \"basic-example\" { // ... } data 块的文档 "},"5.template/1.hcl/1.blocks/1.build/overview.html":{"url":"5.template/1.hcl/1.blocks/1.build/overview.html","title":"build","keywords":"","body":"build 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 build 块定义了构建器的启动方式、如何用 provision 块配置镜像，以及如何在必要时使用 post-process 块处理的制品。 要在 build 块中使用构建器，您可以： 定义引用了预先定义的 source 块的 sources 数组。 定义 build 级 source 块。我们也可以在这里设置特定字段。 # build.pkr.hcl build { # use the `name` field to name a build in the logs. # For example this present config will display # \"buildname.amazon-ebs.example-1\" and \"buildname.amazon-ebs.example-2\" name = \"buildname\" sources = [ # use the optional plural `sources` list to simply use a `source` # without changing any field. \"source.amazon-ebs.example-1\", ] source \"source.amazon-ebs.example-2\" { # Use the singular `source` block set specific fields. # Note that fields cannot be overwritten, in other words, you cannot # set the 'output' field from the top-level source block and here. output = \"different value\" name = \"differentname\" } provisioner \"shell\" { scripts = fileset(\".\", \"scripts/{install,secure}.sh\") } post-processor \"shell-local\" { inline = [\"echo Hello World from ${source.type}.${source.name}\"] } } 可以定义顶级 source 块以配置构建器。可以在构建器部分找到可用构建器列表。 为构建命名 build 块的有一个可选的 name 字段可用于设置构建的名称。命名构建在 packer build 中的日志行前面将会有 build 块的名称作为前缀。例如： source \"null\" \"first-example\" { communicator = \"none\" } source \"null\" \"second-example\" { communicator = \"none\" } build { name = \"a\" sources = [ \"sources.null.first-example\", \"sources.null.second-example\", ] } build { sources = [\"sources.null.second-example\"] } 其输出是： > packer build ./folder Build 'a.null.first-example' finished. Build 'a.null.second-example' finished. Build 'null.second-example' finished. ==> Builds finished. The artifacts of successful builds are: --> a.null.first-example: Did not export anything. This is the null builder --> a.null.second-example: Did not export anything. This is the null builder --> null.second-example: Did not export anything. This is the null builder 运行特定的构建 -only/-except 标志将匹配 source 的 type.name 并“只运行”或是“不运行”匹配的 builder/source，例如对同一份配置文件使用这两个标志： > packer build -only \"*.second\" ./folder Build 'null.second-example' finished. Build 'a.null.second-example' finished. ==> Builds finished. The artifacts of successful builds are: --> a.null.second-example: Did not export anything. This is the null builder --> null.second-example: Did not export anything. This is the null builder 这个例子里 a.null.first-example 就被跳过了。 注意：目前还不可能匹配命名 build 块来执行此操作，但将来会支持。所以这里的“a.*”将匹配不到任何内容。 "},"5.template/1.hcl/1.blocks/1.build/1.hcp_packer_registry.html":{"url":"5.template/1.hcl/1.blocks/1.build/1.hcp_packer_registry.html","title":"hcp_packer_registry","keywords":"","body":"hcp_packer_registry 块 原文 hcp_packer_registry 块允许您对 Packer 发送到 HCP Packer Registry（译者注：HashiCorp 提供的云服务） 的元数据进行定制。它配置在 HCP Packer Registry 中创建或更新的镜像的详细信息。 要开始使用 HCP Packer，请参阅 HCP Packer 文档或访问《开始使用 HCP Packer 教程》。 使用方法 该块从 1.7.7 版的 Packer 开始提供支持。 构建块中声明了 hcp_packer_registry 块将启用 HCP Packer 模式。如果设置了适当的 HCP 凭据（HCP_CLIENT_ID 和 HCP_CLIENT_SECRET），Packer 会把该构建块中的所有构建推送到远程注册表。如果没有设置 HCP 凭据，构建失败并立即退出，以避免在定义的 builder/source 块和 HCP Packer 注册表之间出现任何潜在的制品漂移。 注意：如果您尝试从已停用或已删除的注册表中引用元数据，您将收到错误消息。管理员可以手动停用或删除注册表，HCP Packer 会自动停用存在计费问题的注册表。如有问题，请联系 HashiCorp 支持。 # file: builds.pkr.hcl source \"happycloud\" \"macos\" { os = \"macos_amd64\" } build { hcp_packer_registry { bucket_name = \"ios-dev\" description = bucket_name (string) - 发布到 HCP Packer 注册表时的镜像名。应该始终保持相同名称，否则将创建一个新镜像。如果未设置，则默认为 build.name。如果设置了 HCP_PACKER_BUCKET_NAME 环境变量，将被覆盖。 bucket_labels (map[string]string) - 标签映射。可以记录任意信息，例如工具版本（例如 Go 1.17、Python 3.5 等）。存储桶标签将出现在镜像的主页上，并会在变更后，包含变更的新构建推送到 HCP Packer 注册表时更新。 build_labels (map[string]string) - 标签映射。可以记录任意信息，例如工具版本（例如 Go 1.17、Python 3.5 等）。构建标签将出现在迭代的 build 部分。构建标签特定于迭代，并在推送到 HCP Packer 注册表时添加到构建中。不允许更改已完成的迭代的构建标签。 description (string) - 镜像描述。用来提供有关镜像的摘要。该描述将出现在镜像的主页上，并会在变更后，包含变更的新构建推送到 HCP Packer 注册表时更新。最多可以包含 255 个字符。如果未设置，则默认为 build.description。 labels (map[string]string) - 在 Packer 1.7.9 中已弃用。有关详细信息，请参阅 bucket_labels。 "},"5.template/1.hcl/1.blocks/1.build/2.source.html":{"url":"5.template/1.hcl/1.blocks/1.build/2.source.html","title":"source","keywords":"","body":"source 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 嵌套在 builder 块中的 source 块允许您使用已定义的顶级 source 块并“补充”那些尚未在顶级 source 块中设置的字段。 builder 级 source 块是通过将它们的内容与相应的顶级 source 块合并来实现的，当遇到 source 块某个参数有被定义了两次时，packer build 将会失败。例如，在下面的示例中，如果顶级 lxd.arch source 块也定义了一个 output_image 字段（或者如果其中一个 builder 级的 source 块有 image 定义），Packer 将出错。 # file: builds.pkr.hcl source \"lxd\" \"arch\" { image = \"archlinux\" } build { # Use the singular `source` block set specific fields. # Note that fields cannot be overwritten, in other words, you cannot # set the 'image' field from the top-level source block in here, as well as # the 'name' and 'output_image' fields cannot be set in the top-level source block. source \"lxd.arch\" { # Setting the name field allows to rename the source only for this build section. name = \"nomad\" output_image = \"nomad\" } provisioner \"shell\" { inline = [ \"echo installing nomad\" ] } } build { source \"lxd.arch\" { name = \"consul\" output_image = \"consul\" } provisioner \"shell\" { inline = [ \"echo installing consul\" ] } } "},"5.template/1.hcl/1.blocks/1.build/3.provisioner.html":{"url":"5.template/1.hcl/1.blocks/1.build/3.provisioner.html","title":"provisioner","keywords":"","body":"provisioner 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 provisioner 块声明了配置器的配置方式。 # builds.pkr.hcl build { # ... provisioner \"shell\" { inline = [ \"echo provisioning all the things\", \"echo the value of 'foo' is '${var.foo}'\", ] } } 配置器通过内置的和第三方软件在启动后安装和配置机器镜像。Provisioner 使得镜像系统做好了可以被直接使用的准备。 有关配置器的更多信息可以在这里找到。 在指定的 source 上运行 您可以使用 only 或 except 配置来指定仅在特定 source 上运行配置器。only 将只在指定的 source 上运行配置器，except 将阻止在指定 source 上运行配置器。 这里有一个 only 的示例，但 except 的用法实际上是相同的： # builds.pkr.hcl source \"amazon-ebs\" \"first-example\" { #... } source \"amazon-ebs\" \"second-example\" { #... } build { sources = [ \"source.amazon-ebs.first-example\", \"source.amazon-ebs.second-example\", ] provisioner \"shell\" { # This provisioner only runs for the 'first-example' source. only = [\"amazon-ebs.first-example\"] inline = [ \"echo provisioning all the things\", \"echo the value of 'foo' is '${var.foo}'\", ] } provisioner \"shell\" { # This runs with all sources. inline = [ \"echo Hi World!\" ] } } only 和 except 中的 source 名称必须去掉 source. 的前缀。 only 或 except 中的值是 source 块的名称，而不是构建器类型或构建名称。 注意：仅在参数中，except 将匹配构建名称（例如：my_build.amazon-ebs.first-example），但在配置器中，它们将匹配 source 名称（例如：amazon-ebs.third-example）。 builder 块的 override 配置 虽然 Packer 的目标是生成相同的机器镜像，但有时在机器最终收敛为相同配置之前有一段时间内它们是不同的。在这些情况下，配置器可能需要为不同的构建设置不同的配置。我们可以在 builder 块中声明 override 参数来完成。 一个例子是构建 EC2 AMI 和 VMware 镜像。默认情况下，源 EC2 AMI 可能会配置有一个具有管理权限的用户，而 VMware 虚拟机没有这些权限。在这种情况下，可能需要以不同方式执行 shell 脚本。当然，目标是希望 shell 脚本能够最终将这两个镜像收敛为相同的。但是，它们最初可能需要以不同方式运行。 这个例子如下所示： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } source \"null\" \"example3\" { communicator = \"none\" } build { sources = [\"source.null.example2\", \"source.null.example3\"] source \"source.null.example1\" { // Give a name to this source name = \"renamed\" } provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example3 = { inline = [\"echo overrides for example3\"] } // Refer to the source with the given name renamed = { inline = [\"echo overrides for renamed\"] } } } } 在这里例子里，使用了 override 配置。此参数的值是另一个 HCL 映射，其中键是source 块的名称，它的值又是另一个 HCL 映射。这一层的 HCL 属性映射仅包含正常的 provisioner 块的配置，这个配置会与默认的 provisioner 块配置进行合并。 错误处理器 有一个可选的名为 error-cleanup-provisioner 的专用配置器。该配置器只有在正常的配置器运行失败时，在实例关闭之前运行。这允许我们在最后一刻进行变更并清理 Packer 可能无法自行清理的资源。 例如，用户可以使用此配置器来确保实例正确地取消了对它在构建运行期间连接到的所有服务的订阅。 错误清理脚本的一个玩具示例： source \"null\" \"example\" { communicator = \"none\" } build { sources = [\"source.null.example\"] provisioner \"shell-local\" { inline = [\"exit 2\"] } error-cleanup-provisioner \"shell-local\" { inline = [\"echo 'rubber ducky'> ducky.txt\"] } } 运行前暂停 对于某些配置器，有时需要在运行之前暂停一段时间。具体的例子，在配置器重启机器的情况下，我们可能会希望在启动下一个配置器之前等待一段时间。 Packer 模板中的每个配置器定义都可以声明一个特殊配置 pause_before，这是运行该配置器之前暂停的时长。默认情况下不会暂停。一个例子如下所示： # builds.pkr.hcl build { # ... provisioner \"shell\" { inline = [ \"echo provisioning all the things\", \"echo the value of 'foo' is '${var.foo}'\", ] pause_before = \"10s\" } } 对于上面的配置器，Packer 会等待 10 秒，然后再上传和执行 shell 脚本。 错误重试 对于某些配置器，有时需要在失败时重试。一个具体的例子，比如配置器依赖的外部流程尚未完成的情况时。 Packer 模板中的每个配置器定义都可以声明一个特殊配置 max_retries，这是配置器在出错时重试的最大次数。默认情况下，max_retries 为零，并且此时不会进行重试错误。一个例子如下所示： # builds.pkr.hcl build { # ... provisioner \"shell\" { inline = [ \"echo provisioning all the things\", \"echo the value of 'foo' is '${var.foo}'\", ] max_retries = 5 } } 对于上面的配置器，Packer 最多会重试五次，直到停止失败。如果在重试五次后配置器仍然失败，那么整个的构建将失败。 超时设置 有时一个命令可能比预期花费更多的时间 Packer 模板中的每个配置器定义都可以声明一个特殊配置 timeout，即在认定配置器失败之前等待的时长。默认情况下没有超时设置。一个例子如下所示： # builds.pkr.hcl build { # ... provisioner \"shell\" { inline = [ \"echo provisioning all the things\", \"echo the value of 'foo' is '${var.foo}'\", ] timeout = \"5m\" } } 对于上面的配置器，如果超过 5 分钟，Packer 会停止执行脚本。 超时在调试模式下没有影响。 构建上下文变量（Build Contextual Variables） Packer 允许从配置器读取连接信息和实例的基本状态信息。这些信息存储在 build 变量中。查看上下文变量文档以了解更多信息，并查看如何使用它们的示例。 "},"5.template/1.hcl/1.blocks/1.build/4.post-processor.html":{"url":"5.template/1.hcl/1.blocks/1.build/4.post-processor.html","title":"post-processor","keywords":"","body":"post-processor 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 post-processor 块声明了后处理器的配置方式。 # builds.pkr.hcl build { # ... build image post-processor \"checksum\" { # checksum image checksum_types = [ \"md5\", \"sha512\" ] # checksum the artifact keep_input_artifact = true # keep the artifact } post-processor \"amazon-import\" { # upload image to amazon } } 每个 post-processor 会在它存在的 build 完成之后运行。后处理器从构建中获取制品。后处理器是可选的，它们可用于上传制品、重新打包等。可用的后处理器列表可以在后处理器部分找到。 在 post-processors 中定义 post-processor 时，后处理器也可以从另一个后处理器获取制品，这是一个链式后处理器列表。 注意：默认情况下，后处理器接收到的输入制品将被自动删除。 保留输入制品 为防止输入工件被删除，可以将 keep_input_artifact 字段设置为 true 以使 Packer 保留这两个制品。例如，如果我们想对一个制品进行校验和并保留该制品： # builds.pkr.hcl build { # ... post-processor \"checksum\" { checksum_types = [ \"md5\", \"sha512\" ] keep_input_artifact = true } } 选择 source 运行 您可以使用 only 或 except 配置来仅使用特定 source 运行后处理器：only 将仅在指定 source 上运行后处理器，except 将阻止在指定 source 上运行后处理器。 only 的示例如下所示，但 except 的用法实际上是相同的： # builds.pkr.hcl build { # ... post-processor \"checksum\" { checksum_types = [ \"md5\", \"sha512\" ] keep_input_artifact = true only = [\"amazon-ebs.example\"] } } only 或 except 中的值是 source 的名称，而不是构建器类型。 如果你想在从命令行运行 packer build 时排除某些后处理器，你可以这样做： packer build --except=checksum mytemplate.pkr.hcl 将不会运行 checksum 后处理器。此命令通过引用后处理器名称来排除后处理器。默认情况下，后处理器以其类型命名，如上面例子里 checksum 所示。您可以通过向每个后处理器块添加 name 字段来使后处理器的名称唯一。 虽然 -except 标志可用于在命令行上过滤掉后处理器，但 -only 标志对后处理器不起作用。如果您希望只为拥有给定的 source 的构建运行后处理器，则必须在 hcl 模板中使用 only=[source] 语法，如上所述。 构建上下文变量（Build Contextual Variables） Packer 允许从配置器读取连接信息和实例的基本状态信息。这些信息存储在 build 变量中。查看上下文变量文档以了解更多信息，并查看如何使用它们的示例。 相关信息 post-processors 块允许定义一个或多个后处理器链，这个 post-processor 链将从 build 和 provision 步骤中获取输出。 "},"5.template/1.hcl/1.blocks/1.build/5.post-processors.html":{"url":"5.template/1.hcl/1.blocks/1.build/5.post-processors.html","title":"post-processors","keywords":"","body":"post-processors 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 post-processors 允许我们定义一组 post-processor，这些后处理器会搭配定义的 build 块的制品运行。 # builds.pkr.hcl build { # ... post-processors { post-processor \"shell-local\" { # create an artifice.txt file containing \"hello\" inline = [ \"echo hello > artifice.txt\" ] } post-processor \"artifice\" { # tell packer this is now the new artifact files = [\"artifice.txt\"] } post-processor \"checksum\" { # checksum artifice.txt checksum_types = [ \"md5\", \"sha512\" ] # checksum the artifact keep_input_artifact = true # keep the artifact } } } post-processors 块允许定义要为构建的制品运行的多个后处理器。阅读 post-processor 文档以了解如何使用后处理器。 post-processors 块与 post-processor 块的区别 这两个模板做的是相同的事： # builds.pkr.hcl build { # ... build image post-processor \"checksum\" { # checksum image checksum_types = [ \"md5\", \"sha512\" ] # checksum the artifact } post-processor \"amazon-import\" { # upload image to AWS } post-processor \"googlecompute-import\" { # upload image to GCP } } # builds.pkr.hcl build { # ... build image post-processors { post-processor \"checksum\" { # checksum image checksum_types = [ \"md5\", \"sha512\" ] # checksum the artifact } } post-processors { post-processor \"amazon-import\" { # upload image to AWS } } post-processors { post-processor \"googlecompute-import\" { # upload image to GCP } } } 所有这些 post-processors 都将在每次构建之后启动 —— 也就是说，在每个 source 上运行完所有 provisioner 步骤之后 —— 在所有情况下，源镜像都将被删除。 "},"5.template/1.hcl/1.blocks/2.locals.html":{"url":"5.template/1.hcl/1.blocks/2.locals.html","title":"locals","keywords":"","body":"locals 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 locals 块，也称为 local-variable 块，用来在 Packer 配置中定义局部变量。 # locals.pkr.hcl locals { # locals can be bare values like: wee = local.baz # locals can also be set with other variables : baz = \"Foo is '${var.foo}' but not '${local.wee}'\" } # Use the singular local block if you need to mark a local as sensitive local \"mylocal\" { expression = \"${var.secret_api_key}\" sensitive = true } 相关内容 阅读 locals 描述获取更多信息 阅读 variables 获取更多的例子 "},"5.template/1.hcl/1.blocks/3.source.html":{"url":"5.template/1.hcl/1.blocks/3.source.html","title":"source","keywords":"","body":"source 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 顶层 source 块定义了可重用的 builder 块配置： # sources.pkr.hcl source \"happycloud\" \"foo\" { // ... } 第一个标签 happycloud 是构建器类型。第二个标签是您要赋予 source 的独特的名称或标识符。地址为 source.happycloud.foo 的顶级 source 块只能有一个；但它可以多次使用。除了将保留在 Packer 核心中的 file 和 null 构建器以外，其他构建器通常由插件提供。 您可以通过从 build 块中引用这些 source 块来启动构建器： build { sources = [ # Here Packer will use a default ami_name when saving the image. \"source.happycloud.example\", \"source.happycloud.foo\", ] } build 级的 source 块允许设置指定的 source 参数。每个参数只能赋值一次，目前不允许使用 override。 build { source \"source.happycloud.example\" { # Here Packer will use the provided image_name instead of defaulting it. # Note that fields cannot be overwritten, in other words, you cannot # set the 'image_name' field in the top-level source block and here at the # same time image_name = \"build_specific_field\" } } Source 变量 可以从 provisioner 块和 post-processor 块中访问 source 的 name 和 type： source \"null\" \"first-example\" { communicator = \"none\" } build { name = \"roles\" source \"null.first-example\" { name = \"consul\" } source \"null.first-example\" { name = \"nomad\" } source \"null.first-example\" { name = \"vault\" } sources = [\"null.first-example\"] provisioner \"shell-local\" { inline = [\"echo ${source.name} and ${source.type}\"] } } # This will echo something like: # # roles.null.consul: consul and null # roles.null.nomad: nomad and null # roles.null.vault: vault and null # roles.null.first-example: first-example and null "},"5.template/1.hcl/1.blocks/4.variable.html":{"url":"5.template/1.hcl/1.blocks/4.variable.html","title":"variable","keywords":"","body":"variable 块 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 variable 块，也称为 input-variable 块，用以在 Packer 配置中定义变量。在一个输入变量中不能使用另一个输入变量，我们建议改用本地变量。 # variables.pkr.hcl variable \"foo\" { type = string default = \"the default value of the `foo` variable\" description = \"description of the `foo` variable\" sensitive = false # When a variable is sensitive all string-values from that variable will be # obfuscated from Packer's output. } 默认值 如果设置了默认值，则该变量是可选的。否则，必须设置变量的值。 为输入变量赋值 有以下几种为配置文件中声明的输入变量赋值的方法： 用 -var foo=bar 这样的命令行参数对一个输入变量赋值 使用变量文件，要么用 -var-files values.pkrvars.hcl 这样的命令行参数，要么使用自动加载的变量文件(文件名以 *.auto.pkrvars.hcl 为后缀) 使用环境变量，例如：PKR_VAR_foo=bar 定制输入参数校验规则 除了类型约束之外，您还可以在 variable 块中定义一个或多个 validation 块为特定变量指定任意自定义验证规则： variable \"image_id\" { type = string description = \"The ID of the machine image (AMI) to use for the server.\" validation { condition = length(var.image_id) > 4 && substr(var.image_id, 0, 4) == \"ami-\" error_message = \"The image_id value must be a valid AMI ID, starting with \\\"ami-\\\".\" } } condition 参数是一个表达式，如果值有效则必须使表达式返回 true，否则返回 false。表达式只能引用声明该 validation 块的变量，并且不能产生错误。 如果要用表达式是否失败是验证参数的有效性，请使用 can 函数来检测此类错误。例如： variable \"image_id\" { type = string description = \"The ID of the machine image (AMI) to use for the server.\" validation { # regex(...) fails if it cannot find a match condition = can(regex(\"^ami-\", var.image_id)) error_message = \"The image_id value must be a valid AMI ID, starting with \\\"ami-\\\".\" } } 如果 condition 的计算结果为 false，将产生一条错误消息，其中包含 error_message 中给出的句子。错误消息字符串应该是一个完整地解释约束为什么失败的句子，使用与上述示例类似的句子结构。 验证也适用于更复杂的情况： variable \"image_metadata\" { default = { key: \"value\", something: { foo: \"bar\", } } validation { condition = length(var.image_metadata.key) > 4 error_message = \"The image_metadata.key field must be more than 4 runes.\" } validation { condition = can(var.image_metadata.something.foo) error_message = \"The image_metadata.something.foo field must exist.\" } validation { condition = substr(var.image_metadata.something.foo, 0, 3) == \"bar\" error_message = \"The image_metadata.something.foo field must start with \\\"bar\\\".\" } } 上面的例子可以搭配这样一个变量文件： # foo.pkrvars.hcl foo = \"value\" Packer 执行时输入变量值必须是已知的 假设这样一个输入变量： variable \"foo\" { type = string } 我们必须为 foo 设定一个值，但也可以将其 default 设置为 null 从而不需要设置值： no default default = null default = \"xy\" foo unused error, \"foo needs to be set\" - - var.foo error, \"foo needs to be set\" null¹ xy PKR_VAR_foo=yzvar.foo yz yz yz -var foo=yzvar.foo yz yz yz null 是一个合法值。Packer 只会在一个输入变量没有值的时候报错，例如： variable \"example\" { type = string default = null } source \"example\" \"foo\" { arg = var.example } 在上面的例子里，只要 arg 在使用 example 这个 source 时是可选的，那不对 arg 设置值就不会有错误。 隐藏敏感输入变量值 当变量包含敏感信息时，来自该变量的所有字符串值将在 Packer 的输出中进行混淆： # var-foo.pkr.hcl variable \"foo\" { sensitive = true default = { key = \"SECR3TP4SSW0RD\" } } $ packer inspect var-foo.pkr.hcl Packer Inspect: HCL2 mode > input-variables: var.foo: \"{\\n \\\"key\\\" = \\\"\\\"\\n }\" ... "},"5.template/1.hcl/1.blocks/5.packer.html":{"url":"5.template/1.hcl/1.blocks/5.packer.html","title":"packer","keywords":"","body":"Packer 配置 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 请注意：packer 块仅在 Packer v1.6.5 及更高版本中可用。 packer 配置块用于配置 Packer 本身的一些行为，例如运行本配置文件所需的最低要求 Packer 版本。 Packer 块的语法 每个 packer 块都可以包含一些与 Packer 行为相关的设置。在 packer 块中，只能使用常量值； 参数值不能引用命名对象，如资源、输入变量等，也不能使用任何 Packer 语言内建函数。 packer 块支持的各种选项在以下部分中描述。 设定所需要的 Packer 版本 required_version 设置可以设置一个版本约束字符串，它指定哪些版本的 Packer 可以运行当前的配置文件。 如果 Packer 的运行版本与设定的约束不匹配，Packer 将抛出错误并退出而不采取任何进一步的操作。 可以在多人协作环境中使用 Packer 版本约束以确保每个人都使用特定的 Packer 版本，或者限制可以使用的 Packer 的最低版本。 设置插件需求 请注意，required_plugins 块仅在 Packer v1.7.0 及更高版本中可用。 required_plugins 块指定运行当前配置文件所需要的所有插件，每个本地插件名称都映射到对应的源地址和版本约束。 packer { required_plugins { happycloud = { version = \">= 2.7.0\" source = \"github.com/hashicorp/happycloud\" } } } 可以访问插件获取更多信息。 版本约束字符串 在 Packer 允许为某物设置可接受版本范围的任何地方，都需要使用一个特殊格式的字符串，称为版本约束。 版本约束语法 Packer 的版本约束语法与其他依赖管理系统（如 Bundler 和 NPM）使用的语法非常相似。 required_version = \">= 1.2.0, 版本约束是包含一个或多个条件的字符串，这些条件由逗号分隔。 每个条件都包含一个运算符和一个版本号。 版本号应该是一系列由句点分隔的数字（如 1.2.0），可以选择带有后缀以代表是测试版。 以下是合法的运算符： =（或者忽略不写）：只允许使用确定的版本号。不能与其他条件结合。 !=：排除指定的版本号。 >、>=、：与指定版本进行比较，允许计算结果为真的版本。 >/>= 请求较新的版本，/ 请求较旧的版本。 ~>：允许指定版本，以及更新的版本，只增加指定版本号的最特定段。例如，~> 0.9 相当于 >= 0.9，，而 ~> 0.8.4，相当于 >= 0.8.4，。这通常称为悲观约束算子(pessimistic constraint operator)。 版本约束的行为 满足所有约束的版本号是可以使用的。 Packer 参考版本约束来确定当前是否有可接受的版本。 预发布版本是一个版本号，其中包含一个减号引入的后缀，例如 1.2.0-beta。只能通过精确的版本约束（= 运算符或不写运算符）来选择预发布版本。预发布版本无法匹配 >=、~> 等不精确的运算符。 "},"5.template/1.hcl/1.blocks/6.data.html":{"url":"5.template/1.hcl/1.blocks/6.data.html","title":"data","keywords":"","body":"data 块 原文 配置文件中的 data 块定义了使用的数据源： # datasource.pkr.hcl data \"amazon-ami\" \"basic-example\" { // ... } 我们将在后续的数据源章节进行详细介绍。 "},"5.template/1.hcl/2.variables.html":{"url":"5.template/1.hcl/2.variables.html","title":"输入变量","keywords":"","body":"输入变量 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 Packer HCL 模板中有两种变量：输入变量，简称为 variables，和局部变量，也称为 locals。输入变量可能有默认值，但可以从命令行或特殊变量文件读取覆盖这些默认值。局部变量可以被认为是常量，并且不能在运行时被覆盖。 这个页面是关于输入变量的。要了解局部变量，请参阅局部变量页面。 输入变量用作 Packer 构建的参数，让我们可以在不更改 build 代码的情况下定制构建的各个方面。 当您在配置构建中声明变量时，您可以使用命令行参数和环境变量设置它们的值。 变量指南中介绍了输入变量和局部变量的使用。 请注意：为简洁起见，当从上下文中可以清楚地了解所讨论的变量类型时，输入变量通常仅称为“变量”或“Packer 变量”。 Packer 中的其他类型的变量包括环境变量（由运行 Packer 的 shell 设置）和表达式变量（用于间接表示表达式中的值）。 声明一个输入变量 构建接收的每个输入变量都必须声明一个对应的 variable 块： variable \"image_id\" { type = string } variable \"availability_zone_names\" { type = list(string) default = [\"us-west-1a\"] } variable \"docker_ports\" { type = list(object({ internal = number external = number protocol = string })) default = [ { internal = 8300 external = 8300 protocol = \"tcp\" } ] } 或者不是那么精确的 variables 块： variables { foo = \"value\" my_secret = \"foo\" } variable 关键字后的标签或变量块的标签是变量的名称，该名称在同一构建中的所有变量中必须是唯一的。此名称用于从外部为变量赋值，并在构建中引用变量的值。 参数 Packer 声明变量时可以对以下参数赋值： default - 变量拥有一个默认值从而变成选填变量。 type - 变量接受的值的类型。 description - 输入变量的描述文档。 validation - 定义除了类型约束之外的验证规则的块。 sensitive - 宣告输入变量含有敏感信息，导致该变量的字符串值在 Packer 的输出中被混淆。 默认值 变量声明可以包含 default 参数。如果设置了该参数，则该变量被认为是选填的，如果在运行 Packer 时未设置值，则将使用默认值。默认参数需要一个常量字面值，不能引用配置中的其他对象。 类型约束 variable 块中的 type 参数允许您限制将被接收为变量值的类型。如果未设置类型约束，则接受任何类型的值。 虽然类型约束是可选的，但我们建议设置它；它们可以为构建用户提供的简单提醒，并允许 Packer 在使用错误类型时返回有用的错误消息。 类型约束是通过 type 关键字和类型的构造表达式创建的。支持的类型关键字是： string number bool 可以用类型构造表达式指定复杂的集合类型： list() set() map() object({ = , ... }) tuple([, ...]) 关键字 any 可以用来表示任意类型。有关类型约束的详细信息，可以参阅Terraform 文档。 如果同时指定了 type 和 default 参数，则给定的 default 值必须可转换为指定的 type。 如果仅指定 default ，将使用 default 的类型。 当未指定类型和默认值并且您尝试从环境变量或命令行设置变量时，该变量将始终被解释为 string。 输入变量的描述文档 因为构建的输入变量是其用户交互界面的一部分，我们可以使用可选的 description 参数简要描述每个变量的用途： variable \"image_id\" { type = string description = \"The ID of the machine image (AMI) to use for the server.\" } description 应简明扼要地解释变量的用途以及期望的值类型。此描述字符串可能包含在有关构建的文档中，因此应该从构建用户而不是其维护者的角度来编写。面向编写构建代码的维护者的评论，请使用代码注释。 定制输入参数校验规则 此节内容已经在variable 块有所描述。 使用输入参数的值 在声明变量的构建中，可以从表达式中访问输入变量的值，如 var.，其中 与声明块中定义的标签相匹配： source \"googlecompute\" \"debian\" { zone = var.gcp_zone tags = var.gcp_debian_tags } 分配给变量的值只能被声明该变量的文件夹中的表达式访问。 为输入变量赋值 有以下几种为配置文件中声明的输入变量赋值的方法： 用 -var foo=bar 这样的命令行参数对一个输入变量赋值 使用变量文件，要么用 -var-files values.pkrvars.hcl 这样的命令行参数，要么使用自动加载的变量文件(文件名以 *.auto.pkrvars.hcl 为后缀) 使用环境变量，例如：PKR_VAR_foo=bar 下面的段落将详细描述这些赋值方式 命令行赋值 要在命令行上为指定的单个变量赋值，请在运行 packer build 命令时使用 -var 选项： $ packer build -var=\"image_id=ami-abc123\" $ packer build -var='image_id_list=[\"ami-abc123\",\"ami-def456\"]' $ packer build -var='image_id_map={\"us-east-1\":\"ami-abc123\",\"us-east-2\":\"ami-def456\"}' -var 选项可以在单个命令中多次使用。 如果您打算通过命令行对变量赋值，我们强烈建议至少设置一个默认类型而不是使用空块；这有助于 HCL 解析器了解正在设置的内容。否则，解释器将假定命令行上赋值的任何变量都是字符串。 标准变量文件赋值 要设置多个变量，更方便的方法是在文件名以 .pkrvars.hcl 或 .pkrvars.json 结尾的变量定义文件中指定它们的值，然后在命令行上使用 -var-file 指定该文件： $ packer build -var-file=\"testing.pkrvars.hcl\" 变量定义文件使用与 Packer 语言文件相同的基本语法，但仅包含变量名及其赋予的值： image_id = \"ami-abc123\" availability_zone_names = [ \"us-east-1a\", \"us-west-1c\", ] 重要提示：与遗留 JSON 模板不同，变量定义文件中的输入变量必须在标准 HCL2 模板文件 *.pkr.hcl 中有对应的 variable 块声明，然后才能为其赋值。如果不这样做，将导致 Packer 运行时出现 unknown variable 错误。 自动加载变量文件赋值 Packer 还可以自动加载一个或多个变量定义文件（如果存在）： 名称以 .auto.pkrvars.hcl 或 .auto.pkrvars.json 结尾的任何文件。 名称以 .json 结尾的文件被解析为 JSON 对象而不是 HCL，根对象属性对应于变量名： { \"image_id\": \"ami-abc123\", \"availability_zone_names\": [\"us-west-1a\", \"us-west-1c\"] } 重要提示：与遗留 JSON 模板不同，变量定义文件中的输入变量必须在标准 HCL2 模板文件 *.pkr.hcl 中有对应的 variable 块声明，然后才能为其赋值。如果不这样做，将导致 Packer 运行时出现 unknown variable 错误。 环境变量赋值 相对于其他为变量赋值方式的后备方案，Packer 在其自身进程的环境中搜索名为 PKR_VAR_ 的环境变量，后跟已声明变量的名称。 对于自动化运行 Packer 或使用相同变量连续运行一系列 Packer 命令时该功能非常有用。例如，在 Unix 系统的 bash 提示符下： $ export PKR_VAR_image_id=ami-abc123 $ packer build gcp/debian/ ... 在环境变量名称区分大小写的操作系统上，Packer 会完全按照配置中给定的变量名称进行匹配，因此所需的环境变量名称通常会像上例中的同时包含大小写字母。 复杂类型值 当在变量定义文件中提供变量值时，Packer 的常用语法可用于分配复杂类型的值，如列表和映射。 一些特殊规则适用于 -var 命令行选项和环境变量。为方便起见，Packer 默认将 -var 和环境变量值解释为字符串，不需要加引号： $ export PKR_VAR_image_id=ami-abc123 但是，如果输入变量定义为一个复杂类型（list/set/map/object/tuple），Packer 将改为尝试使用变量定义文件中使用的相同语法来解析其值，这需要特别注意到 shell 中的字符串转义规则： $ export PKR_VAR_availability_zone_names='[\"us-west-1b\",\"us-west-1d\"]' 为了可读性，也为了避免 shell 转义引发的错误，我们建议始终通过变量定义文件设置复杂的变量值。 变量赋值的优先级 上述变量赋值的机制可以任意组合使用。 Packer 按以下顺序加载变量，优先级递增： 环境变量（最低优先级） 任何 *.auto.pkrvars.hcl 或 *.auto.pkrvars.json 文件，按其文件名的字典顺序排序。 命令行上的任何 -var 和 -var-file 选项，按它们出现的顺序排列。 （最高优先级） 如果使用不同的机制为同一个变量分配了多个值，Packer 将使用它找到的最后一个值，覆盖任何以前的值。请注意，同一变量不能在单个来源中分配多个值。 重要提示：映射和对象值的变量与其他变量的行为方式相同：高优先级的值会覆盖低优先级值。 Packer 执行时输入变量值必须是已知的 假设这样一个输入变量： variable \"foo\" { type = string } 我们必须为 foo 设定一个值，但也可以将其 default 设置为 null 从而不需要设置值： no default default = null default = \"xy\" foo unused error, \"foo needs to be set\" - - var.foo error, \"foo needs to be set\" null¹ xy PKR_VAR_foo=yzvar.foo yz yz yz -var foo=yzvar.foo yz yz yz null 是一个合法值。Packer 只会在一个输入变量没有值的时候报错，例如： variable \"example\" { type = string default = null } source \"example\" \"foo\" { arg = var.example } 在上面的例子里，只要 arg 在使用 example 这个 source 时是可选的，那不对 arg 设置值就不会有错误。 为一个不存在的输入变量赋值并不一定会报错 Usage packer validate any other packer command bar=yz in .pkrvars.hcl file. error, \"bar undeclared\" warning, \"bar undeclared\" var.bar in .pkr.hcl file error, \"bar undeclared\" error, \"bar undeclared\" -var bar=yz argument error, \"bar undeclared\" error, \"bar undeclared\" export PKR_VAR_bar=yz - - "},"5.template/1.hcl/3.locals.html":{"url":"5.template/1.hcl/3.locals.html","title":"局部变量","keywords":"","body":"局部变量 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 Packer HCL 模板中有两种变量：输入变量，简称为 variables，和局部变量，也称为 locals。输入变量可能有默认值，但可以从命令行或特殊变量文件读取覆盖这些默认值。局部变量可以被认为是常量，并且不能在运行时被覆盖。 这个页面是关于局部变量的。要了解输入变量，请参阅输入变量页面。 局部变量就是为一个表达式分配一个名称，然后可以在一个文件夹中多次使用该名称。 如果输入变量类似于函数参数，那么局部变量就相当于函数内部的局部变量。 变量指南中介绍了输入变量和局部变量的使用。 例子 局部变量在 local 和 locals 块中定义： # Using the local block allows you to mark locals as sensitive, which will # filter their values from logs. local \"mylocal\" { expression = \"${var.secret_api_key}\" sensitive = true } # Using the locals block is more compact and efficient for declaring many locals # Ids for multiple sets of EC2 instances, merged together locals { instance_ids = \"${concat(aws_instance.blue.*.id, aws_instance.green.*.id)}\" } # A computed default name prefix locals { default_name_prefix = \"${var.project_name}-web\" name_prefix = \"${var.name_prefix != \"\" ? var.name_prefix : local.default_name_prefix}\" } # Local values can be interpolated elsewhere using the \"local.\" prefix. source \"virtualbox-iso\" \"example\" { output = \"${local.name_prefix}-files\" # ... } 命名的局部变量可以与其他局部变量合并(merge)来实现默认值的功能： # Define the common tags for all resources locals { common_tags = { Component = \"awesome-app\" Environment = \"production\" } } # Create a resource that blends the common tags with instance-specific tags. source \"amazon-ebs\" \"server\" { source_ami = \"ami-123456\" instance_type = \"t2.micro\" tags = \"${merge( local.common_tags, { \"Name\" = \"awesome-app-server\", \"Role\" = \"server\" } )}\" # ... } 单个 local 块 local 块仅定义一个文件夹中的一个局部变量。块的标签是局部变量的名称，expression 是创建局部变量时应计算的表达式。您可以在 local 块中可选地声明一个 sensitive 布尔值以将变量标记为敏感并从日志中过滤它。 local \"mylocal\" { expression = \"${var.secret_api_key}\" sensitive = true } local 块对于定义复杂的局部变量也非常有用。 Packer 可能需要一些时间来展开和计算含有依赖于其他局部变量的复杂表达式的 locals 块。locals 块被解释为一个映射。映射未经排序，因此表达式被计算的顺序是不确定的。 为避免这种情况，应改用单一的 local 块。这些块将按照定义的顺序进行计算，计算顺序将始终相同。 locals 块 locals 块定义文件夹内的一个或多个局部变量。 为 locals 块中声明的变量设定的名称在整个文件夹中必须是唯一的。设置的值可以是当前文件夹中任意有效的表达式。 局部变量的表达式可以引用其他局部变量，但不允许循环引用。也就是说，局部变量不能引用自身或引用（直接或间接）返回它的变量。 建议将逻辑上相关的局部变量统一声明到一个块中，尤其是当它们相互依赖时。这将有助于读者理解变量之间的关系。同样的，最好把不相关的局部变量声明在不同的块中，并考虑使用注释来说明每个块，该注释描述所有包含的本地值共有的上下文。 已知的限制 目前不支持在数据源(data source)中使用局部变量，例如下面的示例。 locals { cloud_owners = [\"happycloud\"] cloud_base_filter_name = \"cloud-hvm-2.0.*-x86_64-gp2\" } data \"happycloud\" \"happycloud-linux2-east\" { filters = { name = local.cloud_base_filter_name } most_recent = true owners = local.cloud_owners } 局部变量可以引用数据源，但数据源为了避免循环依赖所以不能引用局部变量，因为被引用的局部变量可能引用了数据源自身，或者引用了那些引用了该数据源的局部变量。目前，在数据源中引用用户输入数据的首选方法是使用 variable 块。 variable \"cloud_base_filter_name\" { type = string default = \"cloud-hvm-2.0.*-x86_64-gp2\" } variable \"cloud_owners\" { type = string default = \"happycloud\" } data \"happycloud\" \"happycloud-linux2-east\" { filters = { name = var.cloud_base_filter_name } most_recent = true owners = var.cloud_owners } "},"5.template/1.hcl/4.contextual_variables.html":{"url":"5.template/1.hcl/4.contextual_variables.html","title":"上下文变量","keywords":"","body":"上下文变量 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 source 变量 在配置器和后处理器中可以访问 source 的名称和类型： source \"null\" \"first-example\" { communicator = \"none\" } build { name = \"roles\" source \"null.first-example\" { name = \"consul\" } source \"null.first-example\" { name = \"nomad\" } source \"null.first-example\" { name = \"vault\" } sources = [\"null.first-example\"] provisioner \"shell-local\" { inline = [\"echo ${source.name} and ${source.type}\"] } } # This will echo something like: # # roles.null.consul: consul and null # roles.null.nomad: nomad and null # roles.null.vault: vault and null # roles.null.first-example: first-example and null build 变量 build 变量将允许我们访问构建器的连接信息和基本实例状态信息： source \"null\" \"first-example\" { communicator = \"none\" } build { name = \"my-build-name\" sources = [\"null.first-example\"] provisioner \"shell-local\" { environment_vars = [\"TESTVAR=${build.PackerRunUUID}\"] inline = [\"echo source.name is ${source.name}.\", \"echo build.name is ${build.name}.\", \"echo build.PackerRunUUID is $TESTVAR\"] } } 以下是可用 build 变量的列表： name： 表示正在运行的构建块的名称。这与正在运行的 source 块的名称不同。 ID：表示正在配置的 VM。例如，如果是 Amazon 主机则是实例 ID；如果是 DigitalOcean 主机则是 Droplet ID；如果是 VMware 虚拟机则是虚拟机名称。 Host、Port、User、Password：Packer 用于访问机器的主机、端口、用户和密码。对于使用 shell 本地配置器连接正在被配置的实例运行 Ansible 或 Inspec 很有用。 ConnType：正在使用的通信器类型。例如，对于 SSH 通信器，该值会是 ssh。 PackerRunUUID：当前构建的唯一 ID。可用于指定构建制品。这方面的一个例子是多个构建同时运行产生相同的制品。可以通过使用构建的唯一 ID 为它们命名来区分这些制品。 PackerHTTPIP、PackerHTTPPort 和 PackerHTTPAddr：Packer 创建的文件服务器的 HTTP IP、端口和地址，用于将“http”目录中的项目提供给虚拟机。 HTTP 地址以 IP:PORT 格式显示。 SSHPublicKey 和 SSHPrivateKey：Packer 用于连接实例的公钥和私钥。这些对于 SSH 通信器是唯一的，使用其他通信器时不会设置。 SSHPublicKey 和 SSHPrivateKey 可以包含转义序列和特殊字符，因此它们的输出应该用单引号引起来以避免意外。例如： provisioner \"shell\" { inline = [\"echo '${build.SSHPrivateKey}' > /tmp/packer-session.pem\"] } 为了向后兼容，shell 中也可以使用 WinRMPassword ，尽管它与更通用的 Password 用起来没有什么不同。 所有 build 变量都可以搭配任意 HCL2 函数一起使用。将构建 ID 转为大写的示例： post-processor \"shell-local\" { inline = [\"echo ${upper(build.ID)}\"] } 对于特定于构建器的构建器变量，另请参阅构建器文档： Amazon EC2: chroot, EBS Volume, EBS, EBS Surrogate, Instance HCL2 的特殊 build 变量处于测试阶段；请在 GitHub 上的 Packer issues 上报告任何问题或请求。 Packer 版本 此变量设置为当前运行的 Packer 版本： source \"null\" \"first-example\" { communicator = \"none\" } build { sources = [\"null.first-example\"] provisioner \"shell-local\" { inline = [\"echo packer_version is '${packer.version}'\"] } } 如果您正在运行 Packer 的开发版本，版本变量将包含已发布的版本号、开发标志和当前的 git commit hash： PACKER_LOG=0 packer build packer_version_demo.pkr.hcl null.first-example: output will be in this color. ==> null.first-example: Running local shell script: /var/folders/8t/0yb5q0_x6mb2jldqq_vjn3lr0000gn/T/packer-shell083160352 null.first-example: packer_version is 1.6.5-dev (a69392129+CHANGES) 如果您正在运行 Packer 的发布版本，则版本变量将仅包含发布的版本号： PACKER_LOG=0 packer build packer_version_demo.pkr.hcl null.first-example: output will be in this color. ==> null.first-example: Running local shell script: /var/folders/8t/0yb5q0_x6mb2jldqq_vjn3lr0000gn/T/packer-shell718995312 null.first-example: packer_version is 1.6.5 确保用单引号将变量引起来以转义返回的字符串，否则如果您运行的是开发版本的 Packer 程序，则括号可能会被您的 shell 转义。 HCP Packer Iteration ID 如果您的构建将元数据推送到 HCP Packer 注册表，则此变量将设置为与此运行关联的 Iteration ID 的值： source \"amazon-ebs\" \"cannonical-ubuntu-server\" { ami_name = \"packer-example\" // ... run_volume_tags = { hcp_iteration_id = packer.iterationID } } ==> vanilla.amazon-ebs.cannonical-ubuntu-server: Adding tags to source instance vanilla.amazon-ebs.cannonical-ubuntu-server: Adding tag: \"Name\": \"Packer Builder\" vanilla.amazon-ebs.cannonical-ubuntu-server: Adding tag: \"hcp_iteration_id\": \"01FHGF3M2AK4TS6PCZES4VX5E7\" 您还可以将此值添加到后处理器，例如添加到清单文件： post-processor \"manifest\" { output = \"manifest.json\" strip_path = true custom_data = { iteration = \"${packer.iterationID}\" } } "},"5.template/1.hcl/5.data_sources.html":{"url":"5.template/1.hcl/5.data_sources.html","title":"数据源","keywords":"","body":"数据源 原文 请注意：数据源是从 Packer 1.7 及之后的版本开始支持的。 数据源允许在 locals 和 sources 配置中查询或计算数据。使用数据源使得我们可以在构建器中使用在 Packer 之外定义的信息。 使用数据源 使用 data 块声明数据源，配置如下所示： data \"amazon-ami\" \"example\" { filters = { virtualization-type = \"hvm\" name = \"ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*\" root-device-type = \"ebs\" } owners = [\"099720109477\"] most_recent = true } data 块请求 Packer 从给定的数据源（“amazon-ami”）读取并在给定的本地名称（“example”）下输出结果。该名称可以被用于从同一 Packer 配置中的其他地方引用此数据源。 data 块创建一个指定类型（第一个块标签）和名称（第二个块标签）的 data 实例。类型和名称的组合在配置文件中必须是唯一的。 在块（{}）内是 data 实例的参数。参数取决于类型，并在数据源部分按类型分开说明。比如，我们可以在这里访问类型为 amazon-ami 的数据源文档。 数据源可以输出一个或多个属性，可以通过将它们的键名添加到数据源唯一标识符后面来使用，如data...。 上面例子里的 amazon-ami.example 的输出可以按如下方式访问： 输出数据： \"data.amazon-ami.example\" { id = \"ami12345\" name = \"MyAMI\" creation_date = \"01/01/2021\" owner = \"123456789\" owner_name = \"Some Name\" tags = {\"tag1\": \"value\"} } 用法： // in a local locals { source_ami_id = data.amazon-ami.example.id source_ami_name = data.amazon-ami.example.name } // in a source source \"amazon-ebs\" \"basic-example\" { source_ami = locals.source_ami // ... } 已知的限制 目前不支持在数据源(data source)中使用局部变量，例如下面的示例。 locals { cloud_owners = [\"happycloud\"] cloud_base_filter_name = \"cloud-hvm-2.0.*-x86_64-gp2\" } data \"happycloud\" \"happycloud-linux2-east\" { filters = { name = local.cloud_base_filter_name } most_recent = true owners = local.cloud_owners } 局部变量可以引用数据源，但数据源为了避免循环依赖所以不能引用局部变量，因为被引用的局部变量可能引用了数据源自身，或者引用了那些引用了该数据源的局部变量。目前，在数据源中引用用户输入数据的首选方法是使用 variable 块。 variable \"cloud_base_filter_name\" { type = string default = \"cloud-hvm-2.0.*-x86_64-gp2\" } variable \"cloud_owners\" { type = string default = \"happycloud\" } data \"happycloud\" \"happycloud-linux2-east\" { filters = { name = var.cloud_base_filter_name } most_recent = true owners = var.cloud_owners } "},"5.template/1.hcl/6.path_variables.html":{"url":"5.template/1.hcl/6.path_variables.html","title":"路径变量","keywords":"","body":"路径变量 原文 请注意：如果可能，尽量始终使用正斜杠 / 作为路径分隔符，尤其是在处理相对路径时。反斜杠 \\ 在 Windows 上是可以工作的，并且是官方的 Windows 路径分隔符，但是当在任何非 Windows 系统上运行构建时，Packer 只会将斜杠 / 视为路径分隔符，并将反斜杠视为纯文本。这可能会导致路径错误。 path.cwd：启动 Packer 时所在的路径。 path.root：正在执行的 HCL 文件或文件夹的路径。 例子 locals { settings_file = \"${path.cwd}/settings.txt\" scripts_folder = \"${path.root}/scripts\" root = path.root } 相关函数 abspath 接受一个包含文件系统路径的字符串并将其转换为绝对路径。 basename 只返回文件系统路径的最后部分，丢弃 dirname 返回的部分。 fileset 枚举给定路径下符合模式的文件名。 dirname 返回除最后一个文件系统路径的所有段，丢弃 basename 返回的部分。 "},"5.template/1.hcl/7.syntax.html":{"url":"5.template/1.hcl/7.syntax.html","title":"语法","keywords":"","body":"HCL 语法 原文 有关 HCL 语法的内容，已经在我之前的电子书《Terraform 入门教程》相关章节中有所叙述，在此不再赘述，有兴趣的读者可以移步阅读我的译文或是原文。 "},"5.template/1.hcl/8.only_except.html":{"url":"5.template/1.hcl/8.only_except.html","title":"Only 和 Except","keywords":"","body":"Only 与 Except 原文 only 和 except 是用于过滤 Packer 构建中运行步骤的关键字，它们可以被视为命令行参数： -except=foo,bar,baz - 阻止运行具有给定逗号分隔名称的构建和后处理器。在遗留 JSON 模板中，构建名称默认为其构建器的类型（例如 docker 或 amazon-ebs 或 virtualbox-iso），除非在配置中指定了特定的名称属性。在 HCL2 模板中，“名称”是 source 块的 name 标签，除非内置 source 定义添加了 name 配置参数。被跳过的后处理器之后的所有后处理器都不会运行。因为后处理器可以存在于数组中，所以不同的后处理器链仍然可以运行。名称为空的后处理器将被忽略。 -only=foo,bar,baz - 仅运行具有给定逗号分隔名称的构建。在遗留 JSON 模板中，构建名称默认为其构建器的类型（例如 docker 或 amazon-ebs 或 virtualbox-iso），除非在配置中指定了特定的名称属性。在 HCL2 模板中，“名称”是 source 块的 name 标签，除非内置 source 定义添加了 name 配置参数。 它们也可以在模板中设置，以选择或跳过在特定构建上运行配置器和/或后处理器： source \"amazon-ebs\" \"first-example\" { } source \"amazon-ebs\" \"second-example\" { } source \"amazon-ebs\" \"third-example\" { } build { name = \"my_build\" sources = [ \"source.amazon-ebs.first-example\", ] source \"source.amazon-ebs.second-example\" { // setting the name field allows you to rename the source only for this // build section. To match this builder, you need to use // second-example-local-name, not second-example name = \"second-example-local-name\" } provisioner \"shell-local\" { only = [\"amazon-ebs.first-example\"] inline = [\"echo I will only run for the first example source\"] } provisioner \"shell-local\" { except = [\"amazon-ebs.second-example-local-name\"] inline = [\"echo I will never run for the second example source\"] } } build { sources = [ \"source.amazon-ebs.third-example\", ] } # this file will result in Packer creating three builds named: # my_build.amazon-ebs.first-example # my_build.amazon-ebs.second-example # amazon-ebs.third-example 请注意，上面演示的配置文件，命令行参数可以与 * 运算符一起使用： packer build -only 'my_build.*' dir: 只会在名为 my_build 的块中运行构建。 packer build -only '*.amazon-ebs.*' dir: 将只运行带有 amazon-ebs 类型源的构建。 packer build -only '*.second-example-local-name' dir: 只会运行含有指定名称的构建。 请注意：在命令行参数中，only 和 except 将匹配构建名称（例如：my_build.amazon-ebs.first-example），但在配置器中，它们将匹配源名称（例如：amazon-ebs.third-example）。 "},"5.template/1.hcl/9.expression.html":{"url":"5.template/1.hcl/9.expression.html","title":"表达式","keywords":"","body":"表达式 基础类型 基础类型分三类：string、number、bool。 string 代表一组 Unicode 字符串，例如：\"hello\"。 number 代表数字，可以为整数，也可以为小数。 bool 代表布尔值，要么为 true，要么为 false。bool 值可以被用做逻辑判断。 number 和 bool 都可以和 string 进行隐式转换，当我们把 number 或 bool 类型的值赋给 string 类型的值，或是反过来时，Packer 会自动替我们转换类型，其中： true 值会被转换为\"true\"，反之亦然 false 值会被转换为\"false\"，反之亦然 15 会被转换为 \"15\"，3.1415 会被转换为 \"3.1415\"，反之亦然 复杂类型 复杂类型是一组值所组成的符合类型，有两类复杂类型。 一种是集合类型。一个集合包含了一组同一类型的值。集合内元素的类型成为元素类型。一个集合变量在构造时必须确定集合类型。集合内所有元素的类型必须相同。 Packer 支持三种集合： list(...)：列表是一组值的连续集合，可以用下标访问内部元素，下标从 0 开始。例如名为 l 的 list，l[0] 就是第一个元素。list 类型的声明可以是 list(number)、list(string)、list(bool)等，括号中的类型即为元素类型。 map(...)：字典类型(或者叫映射类型)，代表一组键唯一的键值对，键类型必须是 string，值类型任意。map(number) 代表键为 string 类型而值为 number 类型，其余类推。map 值有两种声明方式，一种是类似 {\"foo\": \"bar\", \"bar\": \"baz\"}，另一种是 {foo=\"bar\", bar=\"baz\"}。键可以不用双引号，但如果键是以数字开头则例外。多对键值对之间要用逗号分隔，也可以用换行符分隔。推荐使用 = 号(HCL 代码规范中规定按等号对齐，使用等号会使得代码在格式化后更加美观) set(...)：集合类型，代表一组不重复的值。 以上集合类型都支持通配类型缩写，例如 list 等价于 list(any)，map 等价于 map(any)，set 等价于 set(any)。any 代表支持任意的元素类型，前提是所有元素都是一个类型。例如，将 list(number) 赋给 list(any) 是合法的，list(string) 赋给 list(any) 也是合法的，但是 list 内部所有的元素必须是同一种类型的。 第二种复杂类型是结构化类型。一个结构化类型允许多个不同类型的值组成一个类型。结构化类型需要提供一个 schema 结构信息作为参数来指明元素的结构。 Packer 支持两种结构化类型： object(...)：对象是指一组由具有名称和类型的属性所构成的符合类型，它的 schema 信息由 { \\=\\, \\=\\,...} 的形式描述，例如 object({age=number, name=string})，代表由名为 \"age“ 类型为number，以及名为 \"name\" 类型为 string 两个属性组成的对象。赋给 object 类型的合法值必须含有所有属性值，但是可以拥有多余的属性(多余的属性在赋值时会被抛弃)。例如对于 object({age=number,name=string}) 来说，{ age=18 } 是一个非法值，而 { age=18, name=\"john\", gender=\"male\" } 是一个合法值，但赋值时 gender 会被抛弃 tuple(...)：元组类似 list，也是一组值的连续集合，但每个元素都有独立的类型。元组同 list 一样，也可以用下标访问内部元素，下标从 0 开始。元组 schema 用 [\\, \\, ...] 的形式描述。元组的元素数量必须与 schema 声明的类型数量相等，并且每个元素的类型必须与元组 schema 相应位置的类型相等。例如，tuple([string, number, bool]) 类型的一个合法值可以是 [\"a\", 15, true] 复杂类型也支持隐式类型转换。 Packer 会尝试转换相似的类型，转换规则有： object 和 map：如果一个 map 的键集合含有 object 规定的所有属性，那么 map 可以被转换为 object，map 里多余的键值对会被抛弃。由 map -> object -> map 的转换可能会丢失数据。 tuple 和 list：当一个 list 元素的数量正好等于一个 tuple 声明的长度时，list 可以被转换为 tuple。例如：值为 [\"18\", \"true\", \"john\"] 的 list 转换为 tuple([number,bool, string]) 的结果为 [18, true, \"john\"] set 和 tuple：当一个 list 或是 tuple 被转换为一个 set，那么重复的值将被丢弃，并且值原有的顺序也将丢失。如果一个 set 被转换到 list 或是 tuple，那么元素将按照以下顺序排列：如果 set 的元素是 string，那么将按照字段顺序排列；其他类型的元素不承诺任何特定的排列顺序。 复杂类型转换时，元素类型将在可能的情况下发生隐式转换，类似上述 list 到 tuple 转换举的例子。 如果类型不匹配，Packer 会报错，例如我们试图把 object({name = [\"Kristy\", \"Claudia\", \"Mary Anne\", \"Stacey\"], age = 12}) 转换到 map(string) 类型，这是不合法的，因为 name 的值为 list，无法转换为 string。 any any 是 Packer 中非常特殊的一种类型约束，它本身并非一个类型，而只是一个占位符。每当一个值被赋予一个由 any 约束的复杂类型时，Packer 会尝试计算出一个最精确的类型来取代 any。 例如我们把 [\"a\", \"b\", \"c\"] 赋给 list(any)，它在 Packer 中实际的物理类型首先被编译成 tuple([string, string, string])，然后 Packer 认为 tuple 和 list 相似，所以会尝试将它转换为 list(string)。然后 Packer 发现 list(string) 符合 list(any) 的约束，所以会用 string 取代 any，于是赋值后最终的类型是 list(string)。 由于即使是 list(any)，所有元素的类型也必须是一样的，所以某些类型转换到 list(any) 时会对元素进行隐式类型转换。例如将 [\"a\", 1, \"b\"] 赋给 list(any)，Packer 发现 1 可以转换到 \"1\"，所以最终的值是 [\"a\", \"1\", \"b\"]，最终的类型会是 list(string)。再比如我们想把 [\"a\", \\[\\], \"b\"] 转换成 list(any)，由于 Packer 无法找到一个一个合适的目标类型使得所有元素都能成功隐式转换过去，所以 Packer 会报错，要求所有元素都必须是同一个类型的。 声明类型时如果不想有任何的约束，那么可以用 any： variable \"no_type_constraint\" { type = any } 这样的话，Packer 可以将任何类型的数据赋予它。 null 存在一种特殊值是无类型的，那就是 null。null 代表数据缺失。如果我们把一个参数设置为 null，Packer 会认为你忘记为它赋值。如果该参数有默认值，那么 Packer 会使用默认值；如果没有又恰巧该参数是必填字短，Packer 会报错。null 在条件表达式中非常有用，你可以在某项条件不满足时跳过对某参数的赋值。 字面表达式(Literal Expressions) 字面表达式是直接表示特定常量值的表达式。 Packer 对上述每种值类型都有一个文字表达式语法： 字符串通常由 Unicode 字符的双引号序列表示，\"like this\"。对于更复杂的字符串，还有一种“heredoc”语法。字符串文字是 Packer 中最复杂的一种文字表达式，本页另有详细说明： 字符串字面量 字符串模版 数字由带或不带小数点的不带引号的数字序列表示，例如 15 或 6.283185。 布尔值由未加引号的符号 true 和 false 表示。 null 值由未加引号的符号 null 表示。 list/tuple 由一对包含以逗号分隔的值序列的方括号表示，如 [\"a\", 15, true]。 列表文字可以分成多行以提高可读性，但始终需要在值之间使用逗号。允许在最终值后使用逗号，但不是必需的。列表中的值可以是任意表达式。 map/object 由一对包含一系列 = 对的花括号表示： { name = \"John\" age = 52 } 键/值对可以用逗号或换行符分隔。值可以是任意表达式。键必须是字符串；如果它们是有效标识符，则可以不加引号，否则必须加引号。您可以通过将非字面表达式括在括号中来将其用作键，例如 (var.business_unit_tag_name) = \"SRE\"。 下标和属性 list 和 tuple 可以通过下标访问成员，例如local.list[3]、var.tuple[2]。map和object可以通过属性访问成员，例如local.object.attrname、local.map.keyname。由于 map 的键是用户定义的，可能无法成为合法的 Packer 标识符，所以访问 map 成员时我们推荐使用方括号：local.map[\"keyname\"]。 引用命名值 Packer 目前只有一种命名值可用： source.. 是表示给定类型和名称的 source 对象。 算数和逻辑操作符 一个操作符是一种用以转换或合并一个或多个表达式的表达式。操作符要么是把两个值计算为第三个值，也就是二元操作符；要么是把一个值转换成另一个值，也就是一元操作符。 二元操作符位于两个表达式的中间，类似 1+2。一元操作符位于一个表达式的前面，类似!true。 Packer 语言支持一组算数和逻辑操作符，它们的功能类似于 JavaScript 或 Ruby 里的操作符功能。 当一个表达式中含有多个操作符时，它们的优先级顺序时： !，- (负号) *，/，% +，- (减号) >，>=，， ==，!= && || 可以使用小括号覆盖默认优先级。如果没有小括号，高优先级操作符会被先计算，例如 1+2\\*3 会被解释成 1+(2\\*3) 而不是 (1+2)\\*3。 不同的操作符可以按它们之间相似的行为被归纳为几组，每一组操作符都期待被给予特定类型的值。Packer 会在类型不符时尝试进行隐式类型转换，如果失败则会抛错。 算数操作符 a + b：返回a与b的和 a - b：返回a与b的差 a * b：返回a与b的积 a / b：返回a与b的商 a % b：返回a与b的模。该操作符一般仅在a与b是整数时有效 -a：返回a与-1的商 相等性操作符 a == b：如果a与b类型与值都相等返回true，否则返回false a != b：与==相反 比较操作符 a ：如果a比b小则为true，否则为false a > b：如果a比b大则为true，否则为false a ：如果a比b小或者相等则为true，否则为false a >= b：如果a比b大或者相等则为true，否则为false 逻辑操作符 a || b：a或b中有至少一个为true则为true，否则为false a && b：a与比都为true则为true，否则为false !a：如果a为true则为false，如果a为false则为true 条件表达式 条件表达式是判断一个布尔表达式的结果以便于在后续两个值当中选择一个： condition ? true_val : false_val 如果 condition 表达式为 true，那么结果是 true_value，反之则为 false_value。 一个常见的条件表达式用法是使用默认值替代非法值： var.a != \"\" ? var.a : \"default-a\" 如果输入变量 a 的值是空字符串，那么结果会是 default-a，否则返回输入变量 a 的值。 条件表达式的判断条件可以使用上述的任意操作符。供选择的两个值也可以是任意类型，但它们的类型必须相同，这样 Packer 才能判断条件表达式的输出类型。 函数调用 Packer 支持在计算表达式时使用一些内建函数，函数调用表达式类似操作符，通用语法是： (, ) 函数名标明了要调用的函数。每一个函数都定义了数量不等、类型不一的入参以及不同类型的返回值。 有些函数定义了不定长的入参表，例如，min 函数可以接收任意多个数值类型入参，返回其中最小的数值： min(55, 3453, 2) 完整的函数列表请参阅文档。 展开函数入参 如果想要把列表或元组的元素作为参数传递给函数，那么我们可以使用展开符： min([55, 2453, 2]...) 展开符使用的是三个独立的.号组成的...，不是Unicode中的省略号…。展开符是一种只能用在函数调用场景下的特殊语法。 有关完整的内建函数我们可能会在今后撰写相应的章节介绍。 for 表达式 for 表达式是将一种复杂类型映射成另一种复杂类型的表达式。输入类型值中的每一个元素都会被映射为一个或零个结果。 举例来说，如果 var.list 是一个字符串列表，那么下面的表达式将会把列表元素全部转为大写： [for s in var.list : upper(s)] 在这里 for 表达式迭代了 var.list 中每一个元素(就是 s)，然后计算了 upper(s)，最后构建了一个包含了所有 upper(s) 结果的新元组，元组内元素顺序与源列表相同。 for 表达式周围的括号类型决定了输出值的类型。上面的例子里我们使用了方括号，所以输出类型是元组。如果使用的是花括号，那么输出类型是对象，for 表达式内部冒号后面应该使用以 => 符号分隔的表达式： {for s in var.list : s => upper(s)} 该表达式返回一个对象，对象的成员属性名称就是源列表中的元素，值就是对应的大写值。 一个 for 表达式还可以包含一个可选的 if 子句用以过滤结果，这可能会减少返回的元素数量： [for s in var.list : upper(s) if s != \"\"] 被 for 迭代的也可以是对象或者字典，这样的话迭代器就会被表示为两个临时变量： [for k, v in var.map : length(k) + length(v)] 最后，如果返回类型是对象(使用花括号)那么表达式中可以使用...符号实现 group by： {for s in var.list : substr(s, 0, 1) => s... if s != \"\"} 展开表达式(Splat Expression) 展开表达式提供了一种类似 for 表达式的简洁表达方式。比如说 var.list 包含一组对象，每个对象有一个属性id，那么读取所有id的for表达式会是这样： [for o in var.list : o.id] 与之等价的展开表达式是这样的： var.list[*].id 这个特殊的[*]符号迭代了列表中每一个元素，然后返回了它们在.号右边的属性值。 展开表达式只能被用于列表(所以使用 for_each 参数的资源不能使用展开表达式，因为它的类型是字典)。然而，如果一个展开表达式被用于一个既不是列表又不是元组的值，那么这个值会被自动包装成一个单元素的列表然后被处理。 比如说，var.single_object[*].id 等价于 [var.single_object][*].id。大部分场景下这种行为没有什么意义，但在访问一个不确定是否会定义count参数的资源时，这种行为很有帮助，例如： aws_instance.example[*].id 上面的表达式不论aws_instance.example定义了count与否都会返回实例的id列表，这样如果我们以后为aws_instance.example添加了count参数我们也不需要修改这个表达式。 dynamic块 在顶级块，例如 source 块当中，一般只能以类似 name = expression 或是 key = expression 的形式进行一对一的赋值。大部分情况下这已经够用了，但某些类型的 source 包含了可重复的内嵌块，无法使用表达式循环赋值： source \"amazon-ebs\" \"example\" { name = \"pkr-test-name\" # can use expressions here tag { # but the \"tag\" block is always a literal block } } 你可以用dynamic 块来动态构建重复的 tag 这样的内嵌块： locals { standard_tags = { Component = \"user-service\" Environment = \"production\" } } source \"amazon-ebs\" \"example\" { # ... tag { key = \"Name\" value = \"example-asg-name\" } dynamic \"tag\" { for_each = local.standard_tags content { key = tag.key value = tag.value } } } 一个 dynamic 块类似于 for 表达式，只不过它产生的是内嵌块。它可以迭代一个复杂类型数据然后为每一个元素生成相应的内嵌块。在上面的例子里： dynamic 的标签(也就是 tag)确定了我们要生成的内嵌块种类 for_each 参数提供了需要迭代的复杂类型值 iterator 参数(可选)设置了用以表示当前迭代元素的临时变量名。如果没有设置 iterator，那么临时变量名默认就是 dynamic 块的标签(也就是 tag) labels 参数(可选)是一个表示块标签的有序列表，用以按次序生成一组内嵌块。有 labels 参数的表达式里可以使用临时的 iterator 变量 内嵌的 content 块定义了要生成的内嵌块的块体。你可以在 content 块内部使用临时的 iterator 变量 由于 for_each 参数可以是集合或者结构化类型，所以你可以使用 for 表达式或是展开表达式来转换一个现有集合的类型。 iterator 变量(上面的例子里就是tag)有两个属性： key：迭代容器如果是 map，那么就是当前元素的键；迭代容器如果是 list，那么就是当前元素在 list 中的下标序号；如果是由 for_each 表达式产出的 set，那么 key 和 value 是一样的，这时我们不应该使用 key。 value：当前元素的值 一个 dynamic 块只能生成属于当前块定义过的内嵌块参数。 for_each 的值必须是不为 null 的 map 或者 set。如果你需要根据内嵌数据结构或者多个数据结构的元素组合来声明资源实例集合，你可以使用 Packer 表达式和函数来生成合适的值。 dynamic块的最佳实践 过度使用 dynamic 块会导致代码难以阅读以及维护，所以我们建议只在需要构造可重用的模块代码时使用 dynamic 块。尽可能手写内嵌块。 字符串字面量 Packer 有两种不同的字符串字面量。最通用的就是用一对双引号包裹的字符，比如 \"hello\"。在双引号之间，反斜杠 \\ 被用来进行转义。Packer 支持的转义符有： Sequence Replacement \\n 换行 \\r 回车 \\t 制表符 \\\" 双引号 (不会截断字符串) \\\\ 反斜杠 \\uNNNN 普通字符映射平面的Unicode字符(NNNN代表四位16进制数) \\UNNNNNNNN 补充字符映射平面的Unicode字符(NNNNNNNN代表八位16进制数) 另一种字符串表达式被称为 \"heredoc\" 风格，是受 Unix Shell 语言启发。它可以使用自定义的分隔符更加清晰地表达多行字符串： 标记后面直到行尾组成的标识符开启了字符串，然后 Packer 会把剩下的行都添加进字符串，直到遇到与标识符完全相等的字符串为止。在上面的例子里，EOT 就是标识符。任何字符都可以用作标识符，但传统上标识符一般以 EO 起头。上面例子里的 EOT 代表\"文本的结束(end of text)\"。 上面例子里的 heredoc 风格字符串要求内容必须对齐行头，这在块内声明时看起来会比较奇怪： block { value = 为了改进可读性，Packer 也支持缩进的 heredoc，只要把 改成 ： block { value = 上面的例子里，Packer 会以最靠近行头的行作为基准来调整行头缩进，得到的字符串是这样的： hello world heredoc 中的反斜杠不会被解释成转义，而只会是简单的反斜杠。 双引号和 heredoc 两种字符串都支持字符串模版，模版的形式是 ${...} 以及 %{...}。如果想要表达 ${ 或者 %{ 的字面量，那么可以重复第一个字符：$${和%%{ 。 字符串模版 字符串模版允许我们在字符串中嵌入表达式，或是通过其他值动态构造字符串。 插值(Interpolation) 一个${...}序列被称为插值，插值计算花括号之间的表达式的值，有必要的话将之转换为字符串，然后插入字符串模版，形成最终的字符串： \"Hello, ${var.name}!\" 上面的例子里，输入变量 var.name 的值被访问后插入了字符串模版，产生了最终的结果，比如：\"Hello, Juan!\" 命令(Directive) 一个 %{...} 序列被称为命令，命令可以是一个布尔表达式或者是对集合的迭代，类似条件表达式以及 for 表达式。有两种命令： if \\ / else /endif 命令根据布尔表达式的结果在两个模版中选择一个： \"Hello, %{ if var.name != \"\" }${var.name}%{ else }unnamed%{ endif }!\" else部分可以省略，这样如果布尔表达结果为false那么就会插入空字符串。 for \\ in \\ / endfor 命令迭代一个结构化对象或者集合，用每一个元素渲染模版，然后把它们拼接起来： for 关键字后紧跟的名字（ip）被用作代表迭代器元素的临时变量，可以用来在内嵌模版中使用。 为了在不添加额外空格和换行的前提下提升可读性，所有的模版序列都可以在首尾添加 ~ 符号。如果有 ~ 符号，那么模版序列会去除字符串左右的空白(空格以及换行)。如果 ~ 出现在头部，那么会去除字符串左侧的空白；如果出现在尾部，那么会去除字符串右边的空白： 上面的例子里，命令符后面的换行符被忽略了，但是server ${ip}后面的换行符被保留了，这确保了每一个元素生成一行输出： server 10.1.16.154 server 10.1.16.1 server 10.1.16.34 当使用模版命令时，我们推荐使用 heredoc 风格字符串，用多行模版提升可读性。双引号字符串内最好只使用插值。 "},"5.template/1.hcl/10.json_syntax.html":{"url":"5.template/1.hcl/10.json_syntax.html","title":"JSON 语法","keywords":"","body":"JSON 配置语法 原文 注意：此页面是关于 Packer 的 HCL2 模板的。 HCL2 模板最初作为 Beta 功能被 Packer 1.5 版引入。从 v1.7 开始，HCL2 支持不再处于测试阶段，并且是编写 Packer 配置的首选方式。对于稳定的旧风格配置语言，请参阅模板文档。从 v1.6.2 开始，您可以使用 hcl2_upgrade 命令将遗留的 JSON 模板转换为 HCL2 配置文件。 大多数 Packer 配置都是使用原生 HCL 语法编写的，旨在便于人们阅读和更新。 Packer 还支持与 JSON 兼容的替代语法。当程序生成部分配置时，此语法很有用，因为我们可以使用现有的 JSON 库来生成配置文件。 不要将此语法与 1.5 版之前的“遗留” Packer 模板混淆，后者完全是 JSON 并遵循不同的格式。 JSON 语法是对照原生 HCL 语法定义的。任何可以用原生 HCL 语法表达的东西也可以用 JSON 语法表达，但由于 JSON 语法的限制，一些结构在 JSON 中表示更复杂。 Packer 期望以 .pkr.hcl 后缀命名的文件使用原生 HCL 代码，以 .pkr.json 后缀命名的文件使用 JSON 语法。如果您省略后缀的 .pkr 部分，Packer 将尝试将您的 json 文件作为旧版 Packer 模板读取。 与原生 HCL 语法一样，底层的 JSON 语法是根据 HCL 的规范定义的。无需了解 HCL 语法或其 JSON 对标的所有细节即可使用 Packer，因此本页总结了原生 HCL 语法和 JSON 语法之间最重要的区别。如果您有兴趣，可以在 HCL 规范中找到 HCL 的 JSON 语法的完整定义。 JSON 文件的结构 所有基于 JSON 的 Packer 配置的根都是一个 JSON 对象。该对象的属性对应于 Packer 语言的顶级块类型。例如： { \"variables\": { \"example\": \"value\" } } 每个顶级对象属性必须与预期的顶级块类型之一的名称相匹配。表示块类型所需要的标签，例如上面显示的 variable，由每个标签级别对应的一个嵌套对象值表示。source 代码块需要两个标签，因此需要两层嵌套： { \"source\": { \"amazon-ebs\": { \"example\": { \"instance_type\": \"t2.micro\", \"ami_name\": \"ami-abc123\" } } } } 穿透代表标签的多层嵌套对象之后，最后一个嵌套对象代表块本身的主体。在上面的示例中，指定了 source \"amazon-ebs\" \"example\" 的 instance_type 和 ami_name 参数。 综上所述，上述两个配置文件相当于原生语法中的以下块： variables { example = \"value\" } source \"amazon-ebs\" \"example\" { instance_type = \"t2.micro\" ami_name = \"ami-abc123\" } 在每个顶级块类型中，映射到 JSON 的规则略有不同（请参阅下面特定于块类型的特殊处理），但以下一般规则适用于大多数情况： 表示块主体的 JSON 对象包含对应于参数名称或嵌套块类型名称的属性。 在属性对应于接受本机语法中的任意表达式的参数的情况下，属性值对应到表达式，如下文的表达式映射所述。对于不接受任意表达式的参数，属性值的解释取决于参数，如本页后面给出的特定于块类型的特殊处理中所述。 如果属性名称对应于预期的嵌套块类型名称，则它的值将按照下面的嵌套块映射中的描述进行解释，除非在本页后面给出的特定于块类型的特殊处理中另有说明。 表达式映射 由于 JSON 语法无法表示所有的 Packer 语言表达式语法，因此 JSON 值在对应到表达式时有如下映射关系： JSON Packer Language Interpretation Boolean 一个 bool 类型字面值 Number 一个 number 类型字面值 String 作为字符串模板处理，计算过程在下面会有介绍 Object 每一个属性都按照本表格的规则映射，产生一个 object(...) 类型的值，其属性的类型都被解释成和合适的对应类型 Array 每一个元素都按照本表格的规则映射，产生一个 tuple(...) 类型的值，每个元素的类型都被解释成合适的对应类型 Null 一个 null 字面值. 当在应该设置表达式的位置遇到 JSON 字符串时，会首先将其值解析为字符串模板，然后对其求值以产生最终结果。 如果给定的模板仅包含一个插值序列，则直接获取其表达式的结果，而无需先将其转换为字符串。这允许在 JSON 语法中使用非字符串表达式。 嵌套块映射 当 JSON 对象属性的名字等于一个嵌套块类型名时，此属性的值表示该类型的一个或多个块。该属性的值必须是 JSON 对象或 JSON 数组。 最简单的情况是只表示给定类型的单个块，而该类型不需要标签，就像 source 块中使用的 tags 嵌套块一样： { \"source\": { \"amazon-ebs\": { \"example\": { \"tags\": { \"key\": \"value\" } } } } } 上述代码等价于下面的 HCL 原生代码： source \"amazon-ebs\" \"example\" { tags = { key = \"value\" } } 当嵌套块类型需要一个或多个标签时，或者可以声明多个相同类型的块时，映射会变得稍微复杂一些。例如，build 块中使用的 provisioner 嵌套块类型需要一个标签来提供要使用的配置器类型，并且 provisioner 块的顺序对于决定操作顺序很重要。 以下原生语法示例显示了一个 build 块，包含了许多不同类型的 provisioner： build { # (source configuration omitted for brevity) provisioner \"shell-local\" { inline = [\"echo 'Hello World' >example.txt\"] } provisioner \"file\" { source = \"example.txt\" destination = \"/tmp/example.txt\" } provisioner \"shell\" { inline = [ \"sudo install-something -f /tmp/example.txt\", ] } } 为了保留这些块的顺序，您必须使用 JSON 数组作为表示此块类型的属性的直接值，如在上面例子的 JSON 版本中： { \"build\": { \"//\": \"(source configuration omitted for brevity)\", \"provisioner\": [ { \"shell-local\": { \"inline\": [\"echo 'Hello World' >example.txt\"] } }, { \"file\": { \"source\": \"example.txt\", \"destination\": \"/tmp/example.txt\" } }, { \"shell\": { \"inline\": [\"sudo install-something -f /tmp/example.txt\"] } } ] } } provisioner 数组的每个元素都是一个具有单个属性的对象，其名称代表每个 provisioner 块的标签。对于需要多个标签的块类型，这种交替数组和对象嵌套的模式可用于每个递进的级别。 如果嵌套块类型需要标签但顺序无关紧要，您可以省略数组并只提供一个对象，其属性名称对应了这些标签。对于简单的场景，这可以作为上述方法的简写，但交替数组和对象方法是最通用的。如果系统地从原生 HCL 语法转换为 JSON，我们建议使用最通用的形式，以确保准确保留配置的含义。 注释属性 尽管我们不建议手动编辑 JSON 语法配置文件 —— 这种格式主要用于由程序生成和使用 —— 但可以使用特殊属性名称对表示一个块的 JSON 对象进行有限形式的注释： { \"source\": { \"amazon-ebs\": { \"example\": { \"//\": \"This instance runs the scheduled tasks for backup\", \"instance_type\": \"t2.micro\", \"ami_name\": \"ami-abc123\" } } } } 在任何表示块主体的对象中，名为 \"//\" 的属性将被 Packer 完全忽略。此例外不适用于被解释为表达式的对象，表达式中的 \"//\" 将被解释为名为 \"//\" 的对象类型属性。 这个特殊的属性名称也可以用在基于 JSON 的配置文件的顶层对象中。这对于记录创建文件的程序很有用： { \"//\": \"This file is generated by generate-outputs.py. DO NOT HAND-EDIT!\" } 特定于块类型的特殊处理 特定块类型中的某些参数以特殊方式处理，因此它们到 JSON 语法的映射不遵循上述一般规则。以下小节描述了适用于每个顶级块类型的特殊映射规则。 variable 块 variable 块中的所有参数到 JSON 的映射都是特殊的： type ：包含类型表达式的字符串，如 \"string\" 或 \"list(string)\"。 default ：可以转换为给定类型的 JSON 字面值。此值内的字符串按字面意思获取，不解释为字符串模板。 description ：JSON 字面值，不解释为模板。 { \"variable\": { \"example\": { \"type\": \"string\", \"default\": \"hello\" } } } "},"6.communicators/overview.html":{"url":"6.communicators/overview.html","title":"通信器","keywords":"","body":"通信器 原文 通信器(Communicators) 是 Packer 用来向创建的机器上传文件、执行脚本等的机制。 通信器在构建器部分中配置。 Packer目前支持三种通信器： none - 不使用通信器。如果设置了此项，大多数配置器将无法工作。 ssh - 将建立到机器的 SSH 连接。通常这是默认值。 winrm - 将建立 WinRM 连接。 除了上述三种通信器之外，一些构建器还可以使用自定义通信器。例如，Docker 构建器有一个 docker 通信器，它使用 docker exec 和 docker cp 来执行脚本和复制文件。 "},"6.communicators/1.ssh.html":{"url":"6.communicators/1.ssh.html","title":"SSH","keywords":"","body":"SSH 通信器 原文 通信器(Communicators) 是 Packer 用来向创建的机器上上传文件、执行脚本等的机制。 SSH 通信器通过使用 SSH 协议来执行此操作。它是大多数构建器的默认通信器。 如果您在运行 Packer 的主机上配置了 SSH Agent，并且在通信器配置中启用了 SSH Agent 身份验证，则 Packer 会自动将 SSH Agent 转发到远程主机。 使用 SSH 通信器的准备 SSH 通信器是大多数构建器的默认通信器，不是所有的构建器都可以做到\"开箱即用\"的。 如果您正在一台从云镜像创建的主机（例如，在 Amazon 主机上构建）上，您的云提供商很可能已经为您在镜像上预配置了 SSH，这意味着您所要做的就是在 Packer 中配置通信器模板。 但是，如果您是正在一台全新且未配置的操作系统镜像创建的机器上运行构建，您几乎总是必须执行一些额外的工作来在用户操作系统上配置 SSH。对于大多数操作系统发行版，这项工作将由一个引导命令执行，该命令引用一个文件，该文件为您在安装操作系统时会代为应答有关安装选项的交互式提问。该文件的名称因操作系统而异；一些常见的示例是 Debian 所需的 \"preseed\" 文件、CentOS 所需的 \"kickstart\" 文件或 Windows 所需的 \"answer file\"，也称为 \"Autounattend.xml\" 文件。为简单起见，我们将在文档的其余部分将此文件称为\"preseed\"文件。 如果您不熟悉如何使用 preseed 文件自动引导镜像，请查看 HashiCorp 的镜像引导快速指南，或研究特定用户操作系统的自动配置。了解如何自动初始化操作系统对于成功使用 Packer 至关重要。 SSH 通信器 SSH 通信器通过 SSH 连接到主机。如果您在运行 Packer 的主机上配置了 SSH Agent，并且在通信器配置中启用了 SSH Agent 身份验证，则 Packer 会自动将 SSH Agent 转发到远程主机。 SSH 通信器有以下选项： ssh_host (string) - SSH 连接的地址。这通常由构建器自动配置。 ssh_port (int) - SSH 连接 的端口。默认为 22。 ssh_username (string) - 用于连接 SSH 的用户名。如果使用 SSH，则必须填写。 ssh_password（string）- 用于通过 SSH 进行身份验证的密码明文。 ssh_ciphers ([]string) - 该参数会覆盖 Go 默认提供的加密算法。默认值为 [ \"aes128-gcm@openssh.com\", \"chacha20-poly1305@openssh.com\", \"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\", ] 加密算法的有效选项包括：[\"aes128-ctr\"、\"aes192-ctr\"、\"aes256-ctr\"、\"aes128-gcm@openssh.com\"、\"chacha20-poly1305@openssh.com\"、\"arcfour256\"、\"arcfour128\" \", \"arcfour\", \"aes128-cbc\", \"3des-cbc\", ] ssh_clear_authorized_keys (bool) - 如果为 true，Packer 将尝试从 ~/.ssh/authorized_keys 和 /root/.ssh/authorized_keys 中删除其临时密钥。这主要是一个象征性的选项，因为无论是否设置为 true，Packer 都会从主机系统中删除临时私钥（除非用户设置了 -debug 标志）。默认为 false；目前仅适用于安装了 sed 的主机。 ssh_key_exchange_algorithms ([]string) - 如果设置，Packer 将覆盖 Go 提供的默认密钥交换 (kex) 算法的值。可接受的值包括：\"curve25519-sha256@libssh.org\"、\"ecdh-sha2-nistp256\"、\"ecdh-sha2-nistp384\"、\"ecdh-sha2-nistp521\"、\"diffie-hellman-group14-sha1\" 和 \" diffie-hellman-group1-sha1\"。 ssh_certificate_file（string）- 用于通过 SSH 进行身份验证的用户证书的路径。可以在路径中使用 ~，作为当前用户的 home 目录展开。 ssh_pty (bool) - 如果为 true，将为 SSH 连接请求 PTY。默认为 false。 ssh_timeout (duration string | ex: \"1h5m2s\") - 等待 SSH 可用的时间。 Packer 使用它来确定机器何时启动，因此这通常很长。示例值：10m。 ssh_disable_agent_forwarding (bool) - 如果为 true，将禁用 SSH Agent 转发。默认为 false。 ssh_handshake_attempts (int) - 一旦可以连接，尝试使用 SSH 的握手次数。默认为 10。 ssh_bastion_host（string）- 用于 SSH 实际连接的堡垒主机。 ssh_bastion_port (int) - 堡垒主机的端口。默认为 22。 ssh_bastion_agent_auth (bool) - 如果为 true，则本地 SSH Agent 将用于和堡垒主机进行身份验证。默认为 false。 ssh_bastion_username（string）- 连接堡垒主机的用户名。 ssh_bastion_password（string）- 用于向堡垒主机进行身份验证的密码。 ssh_bastion_interactive (bool) - 如果为 true，则用键盘输入交互来与堡垒主机进行身份验证。 ssh_bastion_private_key_file（string）- 用于与堡垒主机进行身份验证的 PEM 编码私钥文件的路径。 可以在路径中使用 ~，作为当前用户的 home 目录展开。 ssh_bastion_certificate_file（string）- 用于与堡垒主机进行身份验证的用户证书的路径。可以在路径中使用 ~，作为当前用户的 home 目录展开。 ssh_file_transfer_method (string) - scp 或 sftp - 如何传输文件，使用 scp（默认）或 SSH 文件传输协议。 ssh_proxy_host (string) - 用于 SSH 连接的 SOCKS 代理主机 ssh_proxy_port (int) - SOCKS 代理的端口。默认为 1080。 ssh_proxy_username（string）- 用于使用代理服务器进行身份验证的可选用户名。 ssh_proxy_password（string）- 用于向代理服务器进行身份验证的可选密码。 ssh_keep_alive_interval (duration string | ex: \"1h5m2s\") - 向服务器发送 \"keep alive\" 消息的频率。设置为负值 (\"-1s\") 以禁用。示例值：\"10s\"。默认为 \"5s\"。 ssh_read_write_timeout (duration string | ex: \"1h5m2s\") - 等待远程命令结束的时间量。有时这可能很有用，比如如果 Packer 程序在连接重启后挂死在连接上。示例：\"5m\"。默认情况下禁用。 ssh_remote_tunnels ([]string) - ssh_local_tunnels ([]string) - 请注意：SSH 通信器选项：ssh_keypair_name、ssh_agent_auth、temporary_key_pair_name 和 ssh_private_key_file 并非被所有构建器支持。请查看构建器特定文档以了解其他 SSH 支持的选项。 SSH 通信器的细节 Packer 只会使用一种身份验证方法，要么使用 publickey，要么使用 ssh_password，Packer 提供两种发送密码的方式： password 和 keyboard-interactive。换句话说，Packer 将无法搭配使用 AuthenticationMethods 配置了多个配置的身份验证方法的 sshd 一起工作。 Packer 支持以下 MAC： hmac-sha1 hmac-sha1-96 hmac-sha2-256 hmac-sha2-256-etm@openssh.com "},"6.communicators/2.winrm.html":{"url":"6.communicators/2.winrm.html","title":"WinRM","keywords":"","body":"WinRM 通信器 原文 通信器(Communicators) 是 Packer 用来向创建的机器上上传文件、执行脚本等的机制。WinRM 通信器使用 Windows 远程管理协议(Windows Remote Management protocol)来执行此操作。 使用 WinRM 通信器的准备 WinRM 通信器不是默认的通信器，因此您始终必须明确设置 \"communicator\": \"winrm\", 模板选项。除此之外，您几乎总是必须提供一个预运行脚本，用于在来宾计算机上启用和配置 WinRM。这通常采用 PowerShell 脚本或批处理文件的形式。 如果您从全新且未配置的操作系统镜像构建，则需要将此预运行脚本作为 Autounattend.xml 文件的一部分提供，这是 Windows 自动安装操作系统所必需的。如果您在云上或从预装的镜像构建，您提供此预运行脚本的方法将因构建器而异。有关如何提供 winrm 配置脚本的更多信息，请参阅每个构建器的文档。 如果您不熟悉如何使用 autounattend 文件，请查看我们的快速指南；了解如何自动初始化操作系统对于成功使用 Packer 从 iso 构建至关重要。 WinRM 通信器选项 winrm_username（string）- 用于连接到 WinRM 的用户名。 winrm_password（string）- 用于连接到 WinRM 的密码。 winrm_host（string）- WinRM 要连接的地址。 注意：如果使用 Amazon EBS 构建器，您可以指定 WinRM 通过 ssh_interface 连接的接口 winrm_no_proxy (bool) - 将此设置为 true 将远程 host:port 添加到 NO_PROXY 环境变量。这可以连接到远程主机时绕过所有配置的代理。默认为 false。 winrm_port (int) - 要连接的 WinRM 端口。当 winrm_use_ssl 设置为 true 时，普通未加密连接默认为 5985，SSL 默认为 5986。 winrm_timeout (duration string | ex: \"1h5m2s\") - 等待 WinRM 可用的时间量。默认为 \"30m\"，因为设置 Windows 机器通常需要很长时间。 winrm_use_ssl (bool) - 如果为 true，则对 WinRM 使用 HTTPS。 winrm_insecure (bool) - 如果为 true，则不检查服务器证书链和主机名。 winrm_use_ntlm (bool) - 如果为 true，WinRM 将启用 NTLMv2 身份验证（具有会话安全性），而不是默认值（基本身份验证），从而消除了在发起连接的目标来宾机器上启用基本身份验证的要求。可以在此处.aspx)找到有关远程连接身份验证的进一步阅读。 例子 WinRM 连接基础 请注意，WinRM 不是 Packer 特有的协议。 Microsoft 有大量关于 WinRM 的文档。如果您在阅读本指南后发现仍然无法通过 WinRM 进行连接，请查看 Microsoft 文档以确保没有遗漏任何内容。 为了使 Packer 能够通过 WinRM 进行连接，您通常需要执行一些步骤： 设置 Packer 连接用的用户名和密码。 对注册表进行必要的设置以启用远程执行（如果需要，还可以启用提权的远程执行） 启动 WinRM，对设置进行必要的修改以允许基本身份验证 根据您的连接方式打开端口 5985 和/或 5986 启动 WinRM 并将其设置为在计算机重新启动时自动启动 如有必要，生成自签名证书或向 WinRM 侦听器提供真实证书。 在 VMWare 中配置 WinRM 如果您使用 Autounattend.xml 配置 WinRM，设置 WinRM 的最简单方法是像这样将配置命令直接放入 Autounattend 文件中。 您还可以将一个批处理文件添加到您的 autounattend，而不是单独输入每一行，其中包含用于配置 winrm 的命令。根据您的 winrm 设置，这可能是一个复杂的批处理文件，也可能是一个非常简单的批处理文件。 下面是我们如何从 Autounattend 文件中调用批处理文件的示例： ... cmd.exe /c a:\\winrmConfig.bat Configure WinRM 3 true ... 也可以用类似的方式调用 PowerShell 脚本。 上面引用的 winrmConfig.bat 可以很简单： rem basic config for winrm cmd.exe /c winrm quickconfig -q rem allow unencrypted traffic, and configure auth to use basic username/password auth cmd.exe /c winrm set winrm/config/service @{AllowUnencrypted=\"true\"} cmd.exe /c winrm set winrm/config/service/auth @{Basic=\"true\"} rem update firewall rules to open the right port and to allow remote administration cmd.exe /c netsh advfirewall firewall set rule group=\"remote administration\" new enable=yes rem restart winrm cmd.exe /c net stop winrm cmd.exe /c net start winrm 请注意，上面的批处理文件是极度简化的，而且不安全，它只是提供了一个刚好能够运行的例子。下面，我们将提供一个更安全也更复杂的 WinRM 配置过程的示例。 此批处理文件仅适用于 HTTP 连接，不适用于 HTTPS，但可让您仅使用之前在 Autounattend 文件中创建的用户名和密码进行连接。下面的批处理文件将允许您使用非常简单的 Packer 配置进行连接： \"communicator\": \"winrm\", \"winrm_username\": \"packeruser\", \"winrm_password\": \"SecretPassword\" 下面是一个更复杂的用于配置的 PowerShell 脚本示例： # A Packer config that works with this example would be: # # # \"winrm_username\": \"Administrator\", # \"winrm_password\": \"SuperS3cr3t!!!\", # \"winrm_insecure\": true, # \"winrm_use_ssl\": true # # # Create username and password net user Administrator SuperS3cr3t!!! wmic useraccount where \"name='Administrator'\" set PasswordExpires=FALSE Set-ExecutionPolicy Unrestricted -Scope LocalMachine -Force -ErrorAction Ignore # Don't set this before Set-ExecutionPolicy as it throws an error $ErrorActionPreference = \"stop\" # Remove HTTP listener Remove-Item -Path WSMan:\\Localhost\\listener\\listener* -Recurse # Create a self-signed certificate to let ssl work $Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\\LocalMachine\\My -DnsName \"packer\" New-Item -Path WSMan:\\LocalHost\\Listener -Transport HTTPS -Address * -CertificateThumbPrint $Cert.Thumbprint -Force # WinRM write-output \"Setting up WinRM\" write-host \"(host) setting up WinRM\" # Configure WinRM to allow unencrypted communication, and provide the # self-signed cert to the WinRM listener. cmd.exe /c winrm quickconfig -q cmd.exe /c winrm set \"winrm/config/service\" '@{AllowUnencrypted=\"true\"}' cmd.exe /c winrm set \"winrm/config/client\" '@{AllowUnencrypted=\"true\"}' cmd.exe /c winrm set \"winrm/config/service/auth\" '@{Basic=\"true\"}' cmd.exe /c winrm set \"winrm/config/client/auth\" '@{Basic=\"true\"}' cmd.exe /c winrm set \"winrm/config/service/auth\" '@{CredSSP=\"true\"}' cmd.exe /c winrm set \"winrm/config/listener?Address=*+Transport=HTTPS\" \"@{Port=`\"5986`\";Hostname=`\"packer`\";CertificateThumbprint=`\"$($Cert.Thumbprint)`\"}\" # Make sure appropriate firewall port openings exist cmd.exe /c netsh advfirewall firewall set rule group=\"remote administration\" new enable=yes cmd.exe /c netsh firewall add portopening TCP 5986 \"Port 5986\" # Restart WinRM, and set it so that it auto-launches on startup. cmd.exe /c net stop winrm cmd.exe /c sc config winrm start= auto cmd.exe /c net start winrm 请注意，如果您将来不需要服务器接收 WinRM 连接，那么让 WinRM 保持自动启动可能不是正确的选择。自行清理并在最后的配置步骤关闭不必要的防火墙端口，以确保镜像安全。 在云端配置 WinRM 大多数云允许我们提供在实例启动时运行的配置脚本。在 AWS 上是 user_data_file。在 Google Cloud 上，这是使用 windows-startup-script-cmd 元数据标签提供的功能（例子）。 本质上，这些文件是配置 winrm 的 powershell 或 cmd 脚本，无需包装在 Autounattend 中。以各家云厂商要求的格式提供脚本，并确保您手动配置云厂商不允许内部管理的防火墙规则。各家云厂商的更多具体细节可以在构建器部分找到。 "},"7.builders/overview.html":{"url":"7.builders/overview.html","title":"构建器","keywords":"","body":"构建器 原文 构建器创建机器，配置这些机器，然后为各个目标平台生成镜像。Packer 执行辅助任务的组件，例如配置器。 Packer 有以下类型的构建器： Plugin：每个插件都有自己的一组相关联的构建器。例如，EC2、VMware、VirtualBox 等都有单独的构建器。 File：file 生成器从文件创建制品。 Null：null 构建器建立 SSH 连接并运行配置器。 自定义：您可以为新平台或现有平台编写新的构建器。 社区构建器：Packer 社区为多个其他平台开发和维护构建器。 请参阅 source 块文档以了解有关使用 Packer 模板语言配置构建器的更多信息。 这里有一份完整的 Packer 插件列表，有大量面向第三方平台的构建器、配置器、后处理器和数据源可用。 "},"7.builders/1.file.html":{"url":"7.builders/1.file.html","title":"File Builder","keywords":"","body":"File 构建器 原文 类型：file Artifact BuilderId：packer.file file 构建器并不是真正的构建器，它只是从文件创建一个制品。它可用于调试后处理器而不会导致长时间等待。 基础用法 下面是一个功能齐全的示例。它在 target 处创建一个具有指定 content 的文件。 source \"file\" \"basic-example\" { content = \"Lorem ipsum dolor sit amet\" target = \"dummy_artifact\" } build { sources = [\"sources.file.basic-example\"] } 配置参数 有两类配置参数：必须的和可选的。可用选项按英文字母顺序排列和描述。 所有的通信器都将被忽略。 必须 target (string) - 将创建的制品文件的路径。如果路径包含不存在的目录，Packer 也会创建它们。 可选 您只能定义 source 或 content 之一。如果它们都未定义，则制品将为空。 source (string) - 将作为制品被复制到的文件的路径。 content (string) - 将被写入制品中的内容。 "},"7.builders/2.null.html":{"url":"7.builders/2.null.html","title":"Null Builder","keywords":"","body":"Null 构建器 原文 类型：null null 构建器并不是真正的构建器，它只是建立一个 SSH 连接并运行配置器。它可以在不导致长时间等待的情况下调试配置器。它不会创建任何类型的制品或是镜像。 基础用法 下面是一个功能齐全的示例。它没有做任何有用的事情，因为没有定义配置器，但它会通过 ssh 连接到指定的主机。 source \"null\" \"basic-example\" { ssh_host = \"127.0.0.1\" ssh_username = \"foo\" ssh_password = \"bar\" } build { sources = [\"sources.null.basic-example\"] } 配置参数 null 构建器除了通信器之外没有其他参数。 "},"7.builders/3.aws/overview.html":{"url":"7.builders/3.aws/overview.html","title":"Aws","keywords":"","body":"Amazon AMI 构建器 原文 Amazon 插件能够创建 Amazon AMI。为实现这一点，该插件带有多个构建器，具体取决于您要用于构建 AMI 的策略。 目前本书只翻译其中一种构建器： amazon-ebs - 通过启动源 AMI 并在配置后将其重新打包到新的 AMI 中来创建基于 EBS 的 AMI。如果有疑问，请使用这个最容易上手的构建器。 如何使用 amazone 插件 从 Packer v1.7.0 开始，可以在 Packer 配置中声明以下代码以安装此插件。然后，运行 packer init： packer { required_plugins { amazon = { version = \">= 1.1.1\" source = \"github.com/hashicorp/amazon\" } } } 认证 AWS Provider 提供了一种灵活的方式来提供身份验证凭据。按此优先级顺序支持以下方法： 静态凭证 环境变量 共享凭证文件 EC2 角色 静态凭证 静态凭证设置 access_key 以及 secret_key，看起来像这样： source \"amazon-ebs\" \"basic-example\" { access_key = \"AKIAIOSFODNN7EXAMPLE\" secret_key = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\" region = \"us-east-1\" } 如果愿意，您还可以使用 assume_role 配置选项 assume 一个角色。您仍然必须拥有上面解释的有效凭证资源之一，并且您的用户必须有权承担相关角色。这是一种使用的账号所拥有的权限更严格的权限子集运行 Packer 的方法。 AssumeRoleConfig 允许用户配置在执行 Packer 时 assume 的角色。 使用示例： source \"amazon-ebs\" \"example\" { assume_role { role_arn = \"arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME\" session_name = \"SESSION_NAME\" external_id = \"EXTERNAL_ID\" } } role_arn（string）- 要 assume 的 IAM 角色的 Amazon 资源名称 (ARN)。 duration_seconds (int) - 限制 assume 角色的会话持续时间的秒数。 external_id (string) - assume 角色时使用的外部 ID。如果忽略，则不会将外部 ID 传递给 AssumeRole 调用。 policy (string) - IAM 策略 JSON，进一步限制所 assume 的 IAM 角色的权限。 policy_arns ([]string) - IAM 策略的 Amazon 资源名称 (ARN) 集，进一步限制 IAM 角色的权限 session_name (string) - assume 角色时使用的会话名称。 tags (map[string]string) - assume 角色会话标签的映射。 transitive_tag_keys ([]string) - 一组假定角色会话标签键，用以传递给所有后续的会话。 环境变量 您可以通过 AWS_ACCESS_KEY_ID 和 AWS_SECRET_ACCESS_KEY 环境变量配置您的凭据，分别代表您的 AWS 访问密钥和 AWS 机密密钥。请注意，这些环境变量生效的优先级高于 AWS_SHARED_CREDENTIALS_FILE 和 AWS_PROFILE。另外还可以搭配使用 ​​AWS_DEFAULT_REGION 和 AWS_SESSION_TOKEN 环境变量： $ export AWS_ACCESS_KEY_ID=\"anaccesskey\" $ export AWS_SECRET_ACCESS_KEY=\"asecretkey\" $ export AWS_DEFAULT_REGION=\"us-west-2\" $ packer build template.pkr.hcl 共享凭证文件 您可以使用 AWS 凭证文件来指定您的凭证。在 Linux 和 OS X 上，默认位置是 $HOME/.aws/credentials，对于 Windows 用户，默认位置是 %USERPROFILE%.aws\\credentials。如果我们未能在代码或者环境变量中检测到凭证，Amazon 插件将检查该位置。您可以选择通过使用 AWS_SHARED_CREDENTIALS_FILE 环境变量来指定指定不同的位置。 凭据文件的格式如下 [default] aws_access_key_id= aws_secret_access_key= 您还可以通过设置 profile 参数或设置 AWS_PROFILE 环境变量来配置要使用的配置文件： source \"amazon-ebs\" \"basic-example\" { profile = \"customprofile\" region = \"us-east-1\" } 任务或实例的 IAM 角色 最后，插件将使用任务或实例的 IAM 角色提供的凭证（如果有的话）。 在 EC2 中运行时，这是最好的方法，因为这样可以避免对凭证进行硬编码。相反，这些凭证是由插件即时生成的租约，这减少了泄漏的机会。 以下策略文档提供了 Amazon 插件运行所需的最小设置权限： { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"ec2:AttachVolume\", \"ec2:AuthorizeSecurityGroupIngress\", \"ec2:CopyImage\", \"ec2:CreateImage\", \"ec2:CreateKeypair\", \"ec2:CreateSecurityGroup\", \"ec2:CreateSnapshot\", \"ec2:CreateTags\", \"ec2:CreateVolume\", \"ec2:DeleteKeyPair\", \"ec2:DeleteSecurityGroup\", \"ec2:DeleteSnapshot\", \"ec2:DeleteVolume\", \"ec2:DeregisterImage\", \"ec2:DescribeImageAttribute\", \"ec2:DescribeImages\", \"ec2:DescribeInstances\", \"ec2:DescribeInstanceStatus\", \"ec2:DescribeRegions\", \"ec2:DescribeSecurityGroups\", \"ec2:DescribeSnapshots\", \"ec2:DescribeSubnets\", \"ec2:DescribeTags\", \"ec2:DescribeVolumes\", \"ec2:DetachVolume\", \"ec2:GetPasswordData\", \"ec2:ModifyImageAttribute\", \"ec2:ModifyInstanceAttribute\", \"ec2:ModifySnapshotAttribute\", \"ec2:RegisterImage\", \"ec2:RunInstances\", \"ec2:StopInstances\", \"ec2:TerminateInstances\" ], \"Resource\": \"*\" } ] } 请注意，如果您想创建一个竞价型实例，您还必须添加： ec2:CreateLaunchTemplate, ec2:DeleteLaunchTemplate, ec2:CreateFleet 如果您将 spot_price 参数设置为 auto，您还必须添加： ec2:DescribeSpotPriceHistory 如果您使用 vpc_filter 选项，您还必须添加： ec2:DescribeVpcs 故障排查 将 IAM 策略关联到角色上 IAM 策略可以与用户或角色相关联。如果您的插件运行时使用了 IAM 角色，您可能会遇到如下错误： ==> amazon-ebs: Error launching source instance: You are not authorized to perform this operation. 您可以在 Amazon 安全博客上详细了解为什么会发生这种情况。下面的示例策略可能有助于插件使用 IAM 角色。请注意，此示例提供的不仅仅是 Amazon 插件工作所需的最小权限集，但具体情况将取决于您的用例。 { \"Sid\": \"PackerIAMPassRole\", \"Effect\": \"Allow\", \"Action\": [\"iam:PassRole\", \"iam:GetInstanceProfile\"], \"Resource\": [\"*\"] } 如果使用具有竞价实例/竞价定价的现有实例配置文件，则还需要 iam:CreateServiceLinkedRole 权限： { \"Sid\": \"PackerIAMPassRole\", \"Effect\": \"Allow\", \"Action\": [\"iam:PassRole\", \"iam:GetInstanceProfile\", \"iam:CreateServiceLinkedRole\"], \"Resource\": [\"*\"] } 如果您创建临时实例配置文件，您将需要赋予以下 IAM 策略: { \"Sid\": \"PackerIAMCreateRole\", \"Effect\": \"Allow\", \"Action\": [ \"iam:PassRole\", \"iam:CreateInstanceProfile\", \"iam:DeleteInstanceProfile\", \"iam:GetRole\", \"iam:GetInstanceProfile\", \"iam:DeleteRolePolicy\", \"iam:RemoveRoleFromInstanceProfile\", \"iam:CreateRole\", \"iam:DeleteRole\", \"iam:PutRolePolicy\", \"iam:AddRoleToInstanceProfile\" ], \"Resource\": \"*\" } 如果您使用 KMS 密钥进行加密，您的密钥至少需要以下策略： { \"Sid\": \"Allow use of the key\", \"Effect\": \"Allow\", \"Action\": [\"kms:ReEncrypt*\", \"kms:GenerateDataKey*\"], \"Resource\": \"*\" } 如果您使用的密钥由与您用于运行 Packer 构建的帐户不同的帐户提供，您的密钥还需要： (\"kms:CreateGrant\", \"kms:DescribeKey\") 检查系统时间是否准确 Amazon 使用当前时间作为请求签名过程的一部分。如果您的系统时钟与当前时间偏差太大，您的请求可能会失败。这时您可能会看到如下错误： ==> amazon-ebs: Error querying AMI: AuthFailure: AWS was not able to validate the provided access credentials 如果您怀疑系统的日期有误，可以将其与 http://www.time.gov/ 进行比较。在 Linux/OS X 上，您可以运行 date 命令来获取当前时间。如果您使用的是 Linux，则可以通过运行 sudo ntpd -q 尝试使用 ntp 设置时间。 ResourceNotReady 错误 此错误通常显示为 ResourceNotReady: exceeded wait attempts 或 ResourceNotReady: failed waiting for successful resource state。 通常是在镜像复制/加密期间从 AWS 的 API 返回此令人费解的错误，原因可能有多种。错误的可能原因包括： 等待时间不够长。在这里您这样的错误消息 exceeded wait attempts：我们使用 AWS SDK 内置的等待方法来等待运行时间较长的任务完成。这些等待方法默认的延迟最大重试次数并不总是对当前操作适用。 如果您发现您受到速率限制或已超过您的最大等待重试次数，您可以通过设置以下 Packer 环境变量来覆盖默认值（请注意，这些将适用于我们必须等待的所有 AWS 任务）： AWS_MAX_ATTEMPTS - 这是重新发送状态更新请求的次数。除了我们知道可能需要很长时间的任务外，默认重试 40 次。 AWS_POLL_DELAY_SECONDS - 状态更新请求之间等待的秒数。通常默认为 2 或 5 秒，具体取决于任务。 或者，您可以在 Packer 配置文件的 source 部分配置这些设置，例如： aws_polling { delay_seconds = 40 max_attempts = 5 } 您使用的是在构建期间过期的短生命周期凭据。如果这是问题所在，您可能在Packer 输出中看到 RequestExpired: Request has expired.： 如果您使用的是 STS 凭据，请确保它们仅在构建完成后过期 如果您链接角色，请确保您的构建不会持续超过一个小时，因为当您链接角色时，您的凭证将持续的最长时间为一个小时：https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html 您的 KMS 密钥有问题。您将在此处看到各种 ResourceNotReady: failed waiting for successful resource state 错误消息。这里的问题有： KMS 密钥无效，可能是因为输入错误 KMS 密钥有效但没有必要的权限（必要的密钥权限见上文） KMS 密钥有效，但不在您告诉我们使用它的区域。 "},"7.builders/3.aws/1.ebs.html":{"url":"7.builders/3.aws/1.ebs.html","title":"ebs","keywords":"","body":"AMI 构建器 (基于 EBS) 原文 类型：amazon-ebs Artifact BuilderId：mitchellh.amazonebs Packer 的 amazon-ebs 构建器能够创建由 EBS 卷支持的 Amazon AMI，以便在 EC2 中使用。有关基于 EBS 启动的实例和基于实例存储启动的实例二者之间差异的更多信息，请参阅 EC2 文档中的\"根设备的存储\"部分。 该构建器通过从指定的源 AMI 启动 EC2 实例、在运行的机器上运行配置器，然后从该机器创建 AMI。这一切都在您自己的 AWS 账户中完成。构建器将创建临时密钥对、安全组规则等，在创建镜像时为其提供对实例的临时访问权限。这大大简化了配置。 构建器不负责管理 AMI。一旦它创建了一个 AMI 并将其存储在您的账户中，您就可以对 AMI 进行使用、删除等操作。 注意：默认情况下，临时资源的名字都以 packer 为前缀。如果您想限制 Packer 能够操作的安全组和密钥对，这将很有用。 属于 EBS 的配置参数 构建器有许多可用的配置选项。除了此处列出的项目之外，您还需要查看 AMI、BlockDevices、Access、Run 和 Communicator 的配置参数，这些配置是本构建器成功运行所必需的，可以在页面下方找到。 可选： skip_create_ami (bool) - 如果为 true，Packer 将不会创建 AMI。在测试构建阶段时设置为 true 很有用。默认为 false。 ami_block_device_mappings (awscommon.BlockDevices) - 将一个或多个块设备映射添加到 AMI。当从您的 AMI 启动新实例时，这些将被附加。要在 Packer 构建期间添加块设备，请参阅下面的 launch_block_device_mappings。根据您使用的不同的 VM 类型，您在此处的选项可能会有所不同。有关字段，请参阅 BlockDevices 文档。 run_volume_tags (map[string]string) - 应用于为创建 AMI 而启动的卷的标签。这些标签不会应用于生成的 AMI，除非它们在 tags 中重复。这是一个模板引擎，有关更多信息，请参阅构建模板数据。 run_volume_tag ([]{name string, value string}) - 与 run_volume_tags 相同，但定义为包含 name 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 no_ephemeral (bool) - 仅与 Windows 虚拟机相关：如果您设置此标志，我们将向 launch_block_device_mappings 添加子句，以确保临时驱动器不会显示在 EC2 控制台中。从 EC2 控制台启动虚拟机时该行为是默认行为，但通过 SDK 启动时则不是。有关详细信息，请参阅 https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html。因为我们不会验证您的虚拟机的操作系统类型，所以请确保您不为 *nix 虚拟机设置此设置，否则可能导致不可预测的行为。 deprecate_at（string）- AMI 过期的日期和时间，采用 UTC 格式，格式如下：YYYY-MM-DDTHH:MM:SSZ。如果设置了秒数，Amazon EC2 会将秒舍入到最接近的分钟。您不能指定过去的日期。 过期时间的上限是从现在起 10 年。 AMI 配置项 必须 ami_name（string）- 在 AWS 控制台中或通过 API 管理 AMI 时将显示的结果 AMI 的名称。这必须是唯一的。为了确保使其独一无二，请使用像 timestamp 这样的函数。 可选 ami_description（string）- 为生成的 AMI 设置的描述。默认情况下，此描述为空。 ami_virtualization_type（string）- 您正在构建的 AMI 的虚拟化类型。此选项是注册 HVM 镜像所必需的。可以是 paravirtual（默认）或 hvm。 ami_users ([]string) - 有权使用构建的 AMI 启动虚拟机的帐户 ID 列表。默认情况下，除创建 AMI 的用户外，其他用户均无权使用它。 ami_groups ([]string) - 有权使用构建的 AMI 启动虚拟机的组列表。默认情况下，任何组都无权使用构建的 AMI。设置为 all 将使 AMI 可公开访问。 AWS 目前不接受除 all 以外的任何值。 ami_org_arns ([]string) - 有权使用构建的 AMI 启动虚拟机的 AWS 组织的 Amazon 资源名称 (ARN) 列表。默认情况下，任何组织都无权使用构建的 AMI。 ami_ou_arns ([]string) - 有权使用构建的 AMI 启动虚拟机的 AWS Organizations 组织单位 (OU) 的 Amazon 资源名称 (ARN) 列表。默认情况下，任何组织单位都无权使用构建的 AMI。 ami_product_codes ([]string) - 与 AMI 关联的产品代码列表。默认情况下，不会有产品代码与 AMI 关联。 ami_regions ([]string) - AMI 将被复制到的区域列表。tags 和属性将随 AMI 一起复制。 AMI 复制需要时间，具体时间取决于 AMI 的大小，但通常需要很多分钟。 skip_region_validation (bool) - 如果您想跳过 ami_regions 配置选项的验证，则设置为 true。默认为 false。 tags (map[string]string) - 应用于 AMI 的键/值对标签。构建器不再向 tags 添加\"name\"：\"Packer Builder\"条目。 tag ([]{name string, value string}) - 与 tags 相同，但定义为包含 name 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 ena_support（bool）- 在与 HVM 兼容的 AMI 上启用增强网络（ENA 而不是 SriovNetSupport）。如果设置为 true，请将 ec2:ModifyInstanceAttribute 添加到您的 AWS IAM 策略。注意：您必须确保在您的实例上启用了网络增强。请参阅 Amazon 关于启用网络增强的文档。 sriov_support (bool) - 在 HVM 兼容的 AMI 上启用网络增强（SriovNetSupport 而不是 ENA）。如果为 true，请将 ec2:ModifyInstanceAttribute 添加到您的 AWS IAM 策略。注意：您必须确保在您的实例上启用了网络增强。请参阅 Amazon 关于启用网络增强的文档。 force_deregister (bool) - 如果同名的 AMI 已经存在，则 Packer 首先强制注销现有的 AMI。默认为 false。 force_delete_snapshot (bool) - Packer 强制删除已被 force_deregister 注销的镜像所关联的快照。默认为 false。 encrypt_boot (boolean) - 在将完成配置的实例复制到 AMI 时是否加密生成的 AMI。默认情况下，Packer 会使用源镜像中的加密设置。设置 false 将生成非加密镜像，而 true 将生成加密镜像。 如果您已经使用 launch_block_device_mappings 设置了一个加密密钥，并且该密钥与您希望在最后加密镜像的密钥相同，那么您不需要设置该字段；将其留空将避免不必要的额外复制步骤并为您节省一些时间。 请注意，如果您使用的帐户的全局\"Always encrypt new EBS volumes\"选项设置为 true，则 Packer 将无法覆盖此设置，并且无论您是否设置此值，最终镜像都将被加密。 kms_key_id（string）- 用来加密 AMI 的 KMS 密钥的 ID、别名或 ARN。这仅适用于主region —— AMI 复制到的任何目标区域都将由该区域的默认 EBS KMS 密钥加密，除非您在 AMIRegionKMSKeyIDs 中为特定区域设置了对应的密钥。 如果您选择 encrypt_boot，但不想使用该区域的默认 KMS 密钥，请设置此值。 如果您有一个自定义的 kms 密钥，您希望将其应用于启动卷，并且只在一个区域中构建，不设置本配置项以及 encrypt_boot ，改为在 launch_block_device_mappings 中设置密钥 ID 会更有效（您可以找到下面的例子）。通过防止 Packer 在构建结束时复制和重新加密镜像，这可能会在构建结束时节省很多时间。 有关有效格式，请参阅 AWS API 文档 - CopyImage 中的 KmsKeyId。此字段由 Packer 验证，当使用别名时，您必须在 kms_key_id 前加上 alias/ 前缀。 region_kms_key_ids (map[string]string) - 将 ami 复制到的区域，以及用于该区域加密的自定义 kms 密钥 ID（别名或 arn）。密钥必须与 ami_regions 中提供的区域相匹配。如果您只想使用默认 ID 进行加密，则可以只使用 kms_key_id 和 ami_regions。如果您希望某个区域使用该区域的默认密钥进行加密，您可以在此映射中使用空字符串 \"\" 而不是密钥 ID。 （例如\"us-east-1\"：\"\"）但是，如果您将其与 snapshot_users 结合使用，则不能使用默认密钥 ID —— 在这种情况下，您必须使用自定义密钥。有关有效格式，请参阅 AWS API 文档 - CopyImage 中的 KmsKeyId。 此选项优先级高于 kms_key_id 选项 —— 如果您同时设置了两者，并且它们不同，Packer 将使用构建区域的 region_kms_key_ids 中的值，并静默忽略 kms_key_id 中提供的值。 skip_save_build_region (bool) - 如果为 true，Packer 将不会检查其正在构建的区域中是否存在具有 ami_name 的 AMI。它将使用临时 AMI 名称，Packer 不会在构建区域中将其转换为 AMI。它会将临时 AMI 复制到 ami_regions 中设置的所有区域，然后删除临时 AMI。默认为 false。 snapshot_tags (map[string]string) - 应用于快照的键/值对标签。如果快照上已经有 AMI 的标签，它们将覆盖 AMI 标签。 snapshot_tag ([]{key string, value string}) - 与 snapshot_tags 相同，但定义为包含 key 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 snapshot_users ([]string) - 有权使用快照创建磁盘卷的帐户 ID 列表。默认情况下，除创建 AMI 的用户外，其他用户均无权从快照创建磁盘卷。 snapshot_groups ([]string) - 有权从快照创建磁盘卷的组列表。默认情况下，任何组都无权从快照创建卷。 all 将使快照可公开访问。 身份验证配置项 必须 access_key (string) - 用于与 AWS 通信的访问密钥。阅读配置教程。在 EBS 上，如果您使用 use_vault_aws_engine 进行身份验证，则无需配置。 region（string）- 区域的名称，例如 us-east-1，在该区域启动 EC2 实例以创建 AMI。当 chroot 构建时，这个值是根据环境来推测的。 secret_key（string）- 用于与 AWS 通信的机密密钥。阅读配置教程。如果您使用 use_vault_aws_engine 进行身份验证，则无需设置。 可选 assume_role (AssumeRoleConfig) - 如果设置了角色 ARN，Packer 将尝试使用提供的凭据代入此角色。有关所有可用选项的更多详细信息以及用法示例，请参阅下面的 AssumeRoleConfig。 custom_endpoint_ec2（string）- 如果您使用的云平台提供的 API 与 aws EC2 兼容，则可以使用该配置项指定另一个端点，例如 https://ec2.custom.endpoint.com。 shared_credentials_file (string) - 用以​​加载凭证的凭证文件的路径 decode_authorization_messages (bool) - 启动自动使用 sts:DecodeAuthorizationMessage API 对所有经编码的授权（错误）消息进行自动解码。注意：要求有效用户/角色对资源 * 拥有 sts:DecodeAuthorizationMessage 权限。默认为 false。 insecure_skip_tls_verify (bool) - 这允许略过 AWS EC2 端点的 TLS 验证。默认为 false。 max_retries (int) - API 调用重试的最大次数，在请求被限制或遇到暂时性故障的情况下。后续 API 调用之间的延迟呈指数增长。 mfa_code（string）- MFA TOTP 代码。这应该是一个由用户输入的变量，因为它一直在变化。 profile（string）- 使用的 AWS 的共享凭证文件。有关详细信息，请参阅亚马逊关于设置配置文件的文档。 skip_metadata_api_check (bool) - 不进行元数据 API 检查 skip_credential_validation (bool) - 如果想在运行前跳过验证 AWS 凭证，则设置为 true。 token (string) - 要使用的访问令牌。这不同于访问密钥和机密密钥。如果您不确定这是什么，那么您可能不需要它。也可以通过 AWS_SESSION_TOKEN 环境变量来设置。 vault_aws_engine (VaultAWSEngineOptions) - 从 HashiCorp Vault 的 aws 机密引擎获取凭证。您必须拥有一个 Vault 角色才能使用。有关通过 Vault 引擎生成凭据的更多信息，请参阅 Vault 文档。如果设置此配置，则还必须设置以下选项： name（string）- 必需。指定要生成凭据所使用的角色的名称。这是请求 URL 的一部分。 engine_name (string) - aws 机密引擎的名称。在 Vault 文档中，这通常称为 aws，如果未设置 engine_name，Packer 将默认为 aws。 role_arn（string）- 如果 Vault 角色上的 credential_type 为 assumed_role，则代入的角色的 ARN。必须匹配 Vault 角色所配置的允许使用的 Aws 角色之一的 ARN。如果 Vault 角色只配置了一个 AWS 角色 ARN，则可选；否则必填。 ttl（string）- 指定使用 STS 令牌的 TTL。格式是带有时间单位后缀的字符串。仅当 credential_type 为 assumed_role 或 federation_token 时有效。如果未指定，将使用为角色设置的 default_sts_ttl。如果 default_sts_ttl 也未设置，则将使用默认值 3600s。 AWS 对允许的最大 TTL 进行了限制。有关更多详细信息，请参阅有关 AssumeRole（对应于 assumed_role 凭证类型）和 GetFederationToken（对应于 federation_token 凭证类型）的 DurationSeconds 参数的 AWS 文档。 HCL2 样例： vault_aws_engine { name = \"myrole\" role_arn = \"myarn\" ttl = \"3600s\" } JSON 样例： { \"vault_aws_engine\": { \"name\": \"myrole\", \"role_arn\": \"myarn\", \"ttl\": \"3600s\" } } aws_polling (*AWSPollingConfig) - AWS 轮询等待的配置，设置检查资源状态的长轮询配置。 代入角色的配置 AssumeRoleConfig 允许用户设置配置选项以在执行 Packer 时代入指定角色。 HCL 配置样例： source \"amazon-ebs\" \"example\" { assume_role { role_arn = \"arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME\" session_name = \"SESSION_NAME\" external_id = \"EXTERNAL_ID\" } } JSON 配置样例： builder{ \"type\": \"amazon-ebs\", \"assume_role\": { \"role_arn\" : \"arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME\", \"session_name\": \"SESSION_NAME\", \"external_id\" : \"EXTERNAL_ID\" } } role_arn（string）- 要代入的 IAM 角色的 Amazon 资源名称 (ARN)。 duration_seconds (int) - 限制代入角色会话持续时间的秒数。 external_id (string) - 代入角色时使用的外部 ID。如果省略，则不会将外部 ID 传递给 AssumeRole 调用。 policy (string) - IAM 策略 JSON，进一步限制所代入的 IAM 角色的权限。 policy_arns ([]string) - IAM 策略的 Amazon 资源名称 (ARN) 集，描述进一步限制 IAM 角色的权限 session_name (string) - 代入角色时使用的会话名称。 tags (map[string]string) - 代入角色时使用的会话的标签。 transitive_tag_keys ([]string) - 一组代入角色时使用的会话标签键，这些键会被传递给所有后续会话。 长轮询配置 AWS 长轮询配置。为创建资源\\附加卷或导入镜像等操作配置长轮询参数。 HCL 样例： aws_polling { delay_seconds = 30 max_attempts = 50 } JSON 样例： \"aws_polling\" : { \"delay_seconds\": 30, \"max_attempts\": 50 } max_attempts (int) - 指定长轮询检查资源状态的最大尝试次数。该值也可以通过环境变量 AWS_MAX_ATTEMPTS 设置。如果同时设置了配置项和环境变量，则将优先使用 max_attempts 而不是 AWS_MAX_ATTEMPTS。如果未设置，则使用 AWS 长轮询默认值，即 40 作为 max_attempts。 delay_seconds (int) - 指定尝试检查资源状态之间的延迟秒数。该值也可以通过环境变量 AWS_POLL_DELAY_SECONDS 设置。如果同时设置了配置项和环境变量，则优先使用 delay_seconds 而不是环境变量。如果未设置，则使用 AWS 长轮询默认值，即 15 秒。 运行时配置 必须 instance_type（string）- 构建 AMI 时要使用的 EC2 实例类型，例如 t2.small。 source_ami（string）- 将在当前运行的实例上复制和配置其根卷的源 AMI。必须是一个您有权访问的基于 Ebs 的根卷 AMI。 可选 associate_public_ip_address (confighelper.Trilean) - 如果使用非默认 VPC，默认情况下不分配公共 IP 地址。如果配置该选项，您的新实例将获得一个公共 IP。默认值：unset availability_zone (string) - 启动实例的目标可用区。不设置该配置项则会交由亚马逊自动分配。 block_duration_minutes (int64) - 需要同时设置 spot_price。 Spot 实例所需的持续时间（也称为 Spot 块）。该值必须是 60 的倍数（60、120、180、240、300 或 360）。如果设置了本配置项，则无法指定可用区或启动组(launch group)。注意：此参数自 2021 年 7 月 1 日起不再对新客户可用。请参阅亚马逊的文档。 capacity_reservation_preference（string）- 设置是否优先使用容量预留的配置（如果存在）。可配置的值有：open 与 none。默认为 none。 capacity_reservation_id（string）- 设置将由 Packer 使用的指定 EC2 容量预留 ID。 capacity_reservation_group_arn（string）- 设置将由 Packer 使用的 EC2 容量预留组的 ARN。 disable_stop_instance (bool) - Packer 通常会在所有配置程序运行后停止构建实例。对于 Windows 实例，有时需要运行 Sysprep 来为您停止实例。如果将其设置为 true，Packer 将不会停止实例，但会假设您将通过最后一个配置器发送停止信号。你可以使用 windows-shell provisioner 来实现这一点。请注意，Packer 仍将等待实例停止，如果您将此标志设置为 true，则配置器运行失败导致没能发送停止信号将导致超时。 一个 windows-shell provisioner 中有效的 windows 关机命令的示例是： ec2config.exe -sysprep 或者是： \"%programfiles%\\amazon\\ec2configservice\\\"ec2config.exe -sysprep\"\" 注意：如果您的 CMD shell 当前路径已经在 C:\\Program Files\\Amazon\\EC2ConfigService\\ 目录中，则命令中不需要双引号。 ebs_optimized (bool) - 将实例配置为启用 EBS 优化。默认为 false。 enable_nitro_enclave (bool) - 在实例上启用对 Nitro Enclaves 的支持。请注意，实例类型必须能够支持 N​​itro Enclaves。 Spot 实例不支持此选项。 enable_t2_unlimited (bool) - 已废弃的参数 - 请使用 enable_unlimited_credits。启用 T2 Unlimited 允许源实例在必要时，在其可用 CPU 积分之外突发使用额外的 CPU。这与仅允许实例消耗其可用 CPU 积分的标准配置形成对比。有关更多信息，请参阅 T2 Unlimited 的 AWS 文档和 Amazon EC2 按需实例定价文档的 T2 Unlimited 定价部分。默认情况下，此选项处于禁用状态，Packer 将使用 T2 标准实例。 要使用 T2 Unlimited，您必须使用 T2 实例类型，例如 t2.micro。此外，T2 Unlimited 不能与 Spot 实例结合使用，例如当配置了 spot_price 选项时。尝试这样做会导致错误。 警告！启用 T2 Unlimited 可能会产生额外费用 - 即使对于通常符合 AWS 免费套餐资格的实例也是如此。 enable_unlimited_credits (bool) - 启用无限积分，允许源实例在必要时突发使用超出其可用 CPU 积分的额外 CPU。这与仅允许实例消耗其可用 CPU 积分的标准配置形成对比。有关更多信息，请参阅 T2 Unlimited 的 AWS 文档和 Amazon EC2 按需定价文档的 Unlimited 定价部分。默认情况下，此选项是禁用的，Packer 使用标准实例。 要使用 Unlimited，您必须使用 T2/T3/T3a/T4g 实例类型，例如（t2.micro，t3.micro）。此外，Unlimited 不能与 T2 类型实例的 Spot 实例结合使用，例如当配置了 spot_price 选项时。如果基础实例类型是 T2 类型实例，尝试这样做将导致错误。默认情况下，受支持的可突增实例类型（包括 t3/t3a/t4g）将配置为标准的 CPU 积分，只有当 enable_unlimited_credits 为 true 时，才会为实例提供无限的 CPU 积分。 iam_instance_profile（string）- 用于启动 EC2 实例的 IAM 实例配置文件的名称。 fleet_tags (map[string]string) - 将应用于发布的 fleet 的键/值对标签。 fleet_tag ([]{key string, value string}) - 与 fleet_tags 相同，但定义为包含 key 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 skip_profile_validation (bool) - 是否检查 IAM 实例配置文件是否存在。默认为 false。 temporary_iam_instance_profile_policy_document (*PolicyDocument) - 临时 IAM 实例配置文件策略文档。如果设置了 IamInstanceProfile，则不会使用该配置。 HCL 样例： temporary_iam_instance_profile_policy_document { Statement { Action = [\"logs:*\"] Effect = \"Allow\" Resource = [\"*\"] } Version = \"2012-10-17\" } JSON 样例： { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"logs:*\" ], \"Effect\": \"Allow\", \"Resource\": [\"*\"] } ] } shutdown_behavior (string) - 在 Packer 发生异常退出时自动终止实例。可能的值是 stop 和 terminate。默认是 stop。 security_group_filter (SecurityGroupFilterOptions) - 用来生成 security_group_ids 字段的过滤器。 HCL 样例： security_group_filter { filters = { \"tag:Class\": \"packer\" } } JSON 样例： { \"security_group_filter\": { \"filters\": { \"tag:Class\": \"packer\" } } } 该样例过滤出 tag 中 Class 为 packer 的安全组以供使用。 filters（map[string,string] 或是用逗号分隔的多个过滤器）- 用于过滤 security_group_ids 的过滤器。 DescribeSecurityGroups 文档中描述的所有过滤器均有效。 security_group_ids 的优先级更高。 run_tags (map[string]string) - 应用于生成的密钥对、安全组、快照和为创建 EBS 卷而启动的实例的键/值对标签。生成的 AMI 也将继承这些标签。 run_tag ([]{key string, value string}) - 与 run_tags 相同，但定义为包含 key 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 security_group_id (string) - 要分配给实例的安全组的 ID（不是名称）。默认不设置，Packer 将自动创建一个新的临时安全组以允许 SSH 访问。请注意，如果配置，则必须确保安全组允许访问 ssh_port 配置指定的端口。 security_group_ids ([]string) - 如上所述的安全组列表。请注意，如果设置本参数，则不能设置 security_group_id。 source_ami_filter (AmiFilterOptions) - 用于生成 source_ami 字段的过滤器。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { source_ami_filter { filters = { virtualization-type = \"hvm\" name = \"ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*\" root-device-type = \"ebs\" } owners = [\"099720109477\"] most_recent = true } } JSON 样例： \"builders\" [ { \"type\": \"amazon-ebs\", \"source_ami_filter\": { \"filters\": { \"virtualization-type\": \"hvm\", \"name\": \"ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*\", \"root-device-type\": \"ebs\" }, \"owners\": [\"099720109477\"], \"most_recent\": true } } ] 该配置将从 Canonical 选出最新的 Ubuntu 16.04 HVM EBS AMI。注意：除非恰好返回一个 AMI，否则 Packer 会失败。在上面的示例中，most_recent 将通过只选择最新的镜像使运行成功。 filters（map[string,string] 或是用逗号分隔的多个过滤器）- 用于选择 source_ami 的过滤器。注意：除非恰好返回一个 AMI，否则将触发失败。 DescribeImages 文档中描述的所有过滤器均有效。 owners（[]string）- 按所有者过滤镜像。您可以指定一个或多个 AWS 账户 ID、\"self\"（它将使用您用来运行 Packer 的凭据的账户）或 AWS 所有者别名：例如，amazon、aws-marketplace 或 microsoft。出于安全原因，此选项是必需的。 most_recent (boolean) - 为 true 时只选择最新创建的镜像。这对于选择每日发行版本最常用的。 您可以设置该参数来代替 source_ami 或与之结合使用。如果将它与 source_ami 一起设置，则 source_ami 将被添加到过滤器中。提供的 source_ami 必须满足 source_ami_filter 中设置的所有过滤条件；这会锁定过滤器返回的 AMI，但如果 source_ami 不存在，则会导致 Packer 失败。 spot_instance_types ([]string) - 用于运行构建的可接受实例类型列表。我们将使用 spot_price 的最高价格和分配策略的\"最低价格\"来请求 spot 实例。您的实例将以您列表中可用价格最低的实例类型启动。该参数将代替 instance_type。您只能设置 spot_instance_types 或 instance_type，不能同时设置。此功能的存在是为了帮助防止 Packer 构建失败的情况，因为指定的可用区可能没有 instance_type 中请求的特定实例类型的资源。 spot_price（string）- 对于 Spot 实例，您需要支付在您的实例运行期间有效的 Spot 价格。 Spot 实例价格由 Amazon EC2 设定，并根据 Spot 实例容量供需的长期趋势逐步调整。 设置此字段时，它表示您愿意为 Spot 实例支付的最高小时价格。如果您不设置此值，它默认为等于实例的按需价格的最高价格。在当前亚马逊设置的 Spot 价格超过该字段设置值的情况下，Packer 不会启动实例，构建会报错。在亚马逊 Spot 价格低于该字段设定值的情况下，Packer 将启动，您将支付亚马逊 Spot 价格，而不是该参数配置的最大值。有关详细信息，请参阅有关 Spot 定价的 Amazon 文档。 spot_tags (map[string]string) - 需要设置 spot_price 参数才能设置本参数。键/值对标签，代表将应用于发出的 Spot 请求上附加的标签。 spot_tag ([]{key string, value string}) - 与 spot_tags 相同，但定义为包含 key 和 value 字段的单一块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 subnet_filter (SubnetFilterOptions) - 用于生成 subnet_id 字段的过滤器。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { subnet_filter { filters = { \"tag:Class\": \"build\" } most_free = true random = false } } JSON 样例： \"builders\" [ { \"type\": \"amazon-ebs\", \"subnet_filter\": { \"filters\": { \"tag:Class\": \"build\" }, \"most_free\": true, \"random\": false } } ] 该配置选择带有标签 Class 和值 build 的子网，该子网拥有最多的空闲 IP 地址。注意：除非恰好返回一个子网，否则这段代码将会失败。通过使用 most_free 或 random 将从匹配过滤器的那些中选择一个。 filters（map[string,string] 或是用逗号分隔的多个过滤器）- 用于选择 subnet_id 的过滤器。注意：除非恰好返回一个子网，否则这段代码将会报错。 DescribeSubnets 文档中描述的所有过滤器均有效。 most_free (boolean) - 如果过滤器匹配多个子网，将使用具有最多空闲 IPv4 地址的子网。 random (boolean) - 如果过滤器匹配多个子网，将使用随机子网。 most_free 的优先级更高。 subnet_id 的优先更高。 subnet_id（string）- 如果使用 VPC，该参数指定使用的子网的 ID，例如 subnet-12345def，Packer 将在该子网中启动 EC2 实例。如果您使用的是非默认 VPC，则此字段是必需的。 license_specifications ([]LicenseSpecification) - 许可证配置。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { license_specifications { license_configuration_request = { license_configuration_arn = \"${var.license_configuration_arn}\" } } } JSON 样例： \"builders\" [ { \"type\": \"amazon-ebs\", \"license_specifications\": [ { \"license_configuration_request\": { \"license_configuration_arn\": \"{{user `license_configuration_arn`}}\" } } ] } ] 每个 license_configuration_request 描述了一个许可配置，其属性是： license_configuration_arn（string）- 许可证配置的 Amazon 资源名称 (ARN)。 placement（Placement）——描述实例的置放信息。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { placement = { host_resource_group_arn = \"${var.host_resource_group_arn}\" tenancy = \"${var.placement_tenancy}\" } } JSON 样例： \"builders\" [ { \"type\": \"amazon-ebs\", \"placement\": { \"host_resource_group_arn\": \"{{user `host_resource_group_arn`}}\", \"tenancy\": \"{{user `placement_tenancy`}}\" } } ] host_resource_group_arn（string）- 将要启动实例的主机资源组的 ARN。如果指定主机资源组 ARN，请省略 Tenancy 参数或将其设置为 host。 tenancy (string) - 实例的租赁(tenancy)（如果实例在 VPC 中运行）。设置为 dedicated 租赁的实例在单租户硬件上运行。默认是 default，意思是共享租赁。允许的值为 default、dedicated 和 host。 tenancy (string) - 已弃用：改为使用 Placement Tenancy。 temporary_security_group_source_cidrs ([]string) - 当 Packer 程序创建临时安全组时，授权访问实例的 IPv4 CIDR 块列表。默认值为 [0.0.0.0/0]（即允许任何 IPv4 源）。如果设置了 temporary_security_group_source_public_ip 则只允许当前运行 Packer 的主机的公共 IP，阻止其他所有 IPv4 源。该配置仅在未指定 security_group_id 或 security_group_ids 时有效。 temporary_security_group_source_public_ip (bool) - 设置该参数后，当 Packer 程序创建临时安全组时，使用当前运行 Packer 的主机的公共 IP（从 https://checkip.amazonaws.com 获得）作为 CIDR 块以授权访问实例。默认为 false。该参数仅在未指定 security_group_id、security_group_ids 和 temporary_security_group_source_cidrs 时有效。 user_data (string) - 启动实例时要应用的 User Data。请注意，由于模板是 JSON，因此您需要注意转义字符。相反，使用 user_data_file 通常更方便。 Packer 不会等待 User Data 脚本完成才关闭实例，这必须在配置器中处理。 user_data_file (string) - 启动实例时将用于 User Data 的文件的路径。 vpc_filter (VpcFilterOptions) - 用于生成 vpc_id 字段的过滤器。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { vpc_filter { filters = { \"tag:Class\": \"build\", \"isDefault\": \"false\", \"cidr\": \"/24\" } } } JSON 样例： \"builders\" [ { \"type\": \"amazon-ebs\", \"vpc_filter\": { \"filters\": { \"tag:Class\": \"build\", \"isDefault\": \"false\", \"cidr\": \"/24\" } } } ] 上述配置将选择带有标签 Class 和值 build 的 VPC，它不是默认 VPC，并且具有 /24 的 IPv4 CIDR 块。注意：除非恰好返回一个 VPC，否则这段代码将会失败。 filters (map[string,string] 或是 用逗号分隔的多个过滤器) - 用于选择 vpc_id 的过滤器。注意：除非恰好返回一个 VPC，否则这段代码将会失败。 DescribeVpcs 文档中描述的所有过滤器都是有效的。 vpc_id 参数的优先级更高。 vpc_id（string）- 如果要在指定 VPC 子网中启动，Packer 需要 VPC ID 才能在 VPC 内创建临时安全组。需要设置 subnet_id。如果此字段留空，Packer 将尝试从 subnet_id 中获取 VPC ID。 windows_password_timeout（duration string，例如：\"1h5m2s\"）- 等待 Windows 实例的 Windows 密码的超时时间。默认为 20 分钟。示例值：10m metadata_options (MetadataOptions) - 元数据配置 元数据配置 下列参数可以用来配置元数据选项。相关详细信息，请参阅配置 IMDS。 http_endpoint (string) - 用于启用或禁用实例的 IMDS 端点的字符串。默认为 \"enabled\"。可设置为 \"enabled\" 或 \"disabled\"。 http_tokens（string）- 用于将实例对 IMDSv2 的使用设置为 \"optional\" 或 \"required\"。默认为 \"optional\"。 http_put_response_hop_limit (int64) - 用于设置与 IMDS 端点通信时允许的跳数上限。默认为 1。 instance_metadata_tags（string）- 用于启用或禁用从实例元数据访问实例标签。默认为 \"disabled\"。商业区域可以访问实例元数据标签。对于非商业区域，请在启用前检查可用性。可选项为 \"enabled\" 或 \"disabled\"。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { region = \"us-east-1\" source_ami = \"ami-fce3c696\" instance_type = \"t2.micro\" ssh_username = \"ubuntu\" ami_name = \"packer_AWS_example_\" metadata_options { http_endpoint = \"enabled\" http_tokens = \"required\" http_put_response_hop_limit = 1 } } JSON 样例： { \"variables\": { \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\" }, \"builders\": [ { \"type\": \"amazon-ebs\", \"access_key\": \"{{user `aws_access_key`}}\", \"secret_key\": \"{{user `aws_secret_key`}}\", \"region\": \"us-east-1\", \"source_ami\": \"ami-fce3c696\", \"instance_type\": \"t2.micro\", \"ssh_username\": \"ubuntu\", \"ami_name\": \"packer_AWS {{timestamp}}\", \"metadata_options\": { \"http_endpoint\": \"enabled\", \"http_tokens\": \"required\", \"http_put_response_hop_limit\": 1 } } ] } 会话管理器(Session Manager)连接 对 AWS Systems Manager 会话管理器的支持使用户无需打开入站端口或维护堡垒主机即可管理 EC2 实例。会话管理器连接依赖于使用会话管理器插件来打开本地机器和远程实例之间的安全隧道。创建隧道后，所有 SSH 通信都将通过 SSM 隧道转接到远程实例。 注意：会话管理器连接目前仅针对 SSH 通信器实现，WinRM 通信器无法使用。 要将会话管理器用作 SSH 通信器的连接接口，您需要将以下配置选项添加到 Amazon 构建器选项中： ssh_interface：ssh 接口必须设置为 \"session_manager\"。使用此选项时，构建器将创建到远程主机上配置的 ssh_port（默认为 22）的 SSM 隧道。 iam_instance_profile：aws ssm-agent 需要一个有效的实例配置文件来授予 Systems Manager 管理远程实例的权限来启动和停止会话连接。有关 Systems Manager 的 IAM 实例配置文件的更多详细信息，请参阅下文。 可选参数 session_manager_port：运行 Packer 的主机上的本地端口，用来连接到远程主机的会话隧道。如果未指定，Packer 将寻找一个可用的端口来使用。 temporary_iam_instance_profile_policy_document：创建临时实例配置策略文档以授予 Systems Manager 对 Ec2 实例的权限。这是配置 iam_instance_profile 参数的替代方法。 HCL 样例： # file: example.pkr.hcl # In order to get these variables to read from the environment, # set the environment variables to have the same name as the declared # variables, with the prefix PKR_VAR_. # You could also hardcode them into the file, but we do not recommend that. data \"amazon-ami\" \"example\" { filters = { virtualization-type = \"hvm\" name = \"ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*\" root-device-type = \"ebs\" } owners = [\"099720109477\"] most_recent = true region = \"us-east-1\" } source \"amazon-ebs\" \"ssm-example\" { ami_name = \"packer_AWS \" instance_type = \"t2.micro\" region = \"us-east-1\" source_ami = data.amazon-ami.example.id ssh_username = \"ubuntu\" ssh_interface = \"session_manager\" communicator = \"ssh\" iam_instance_profile = \"myinstanceprofile\" } build { sources = [\"source.amazon-ebs.ssm-example\"] provisioner \"shell\" { inline = [\"echo Connected via SSM at '${build.User}@${build.Host}:${build.Port}'\"] } } JSON 样例： { \"builders\": [ { \"type\": \"amazon-ebs\", \"ami_name\": \"packer-ami-{{timestamp}}\", \"instance_type\": \"t2.micro\", \"source_ami_filter\": { \"filters\": { \"virtualization-type\": \"hvm\", \"name\": \"ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*\", \"root-device-type\": \"ebs\" }, \"owners\": [\"099720109477\"], \"most_recent\": true }, \"ssh_username\": \"ubuntu\", \"ssh_interface\": \"session_manager\", \"communicator\": \"ssh\", \"iam_instance_profile\": \"{{user `iam_instance_profile`}}\" } ], \"provisioners\": [ { \"type\": \"shell\", \"inline\": [ \"echo Connected via SSM at '{{build `User`}}@{{build `Host`}}:{{build `Port`}}'\" ] } ] } 会话管理器插件 通过会话管理器的连接需要使用会话管理器插件（需要与 Packer 一起安装）和能够运行 AWS ssm-agent 的实例 AMI - 有关支持的 AMI 的详细信息，请参阅关于 SSM 代理。 为了让 Packer 启动和关闭将您连接到托管实例的会话，您必须首先在本地计算机上安装会话管理器插件。该插件可以安装在受支持的 Microsoft Windows、macOS、Linux 和 Ubuntu Server 版本上。这里是会话管理器插件的安装说明 Systems Manager 的 IAM 实例配置文件 默认情况下，Systems Manager 无权对创建的实例执行操作，因此必须通过使用 AmazonSSMManagedInstanceCore 策略创建实例配置(instance profile)来授予 SSM 访问权限。然后可以将实例配置附加到您希望通过会话管理器插件管理的任何实例。有关创建所需实例配置文件的详细信息，请参阅添加 System Manager 实例配置。 块存储设备配置 块存储设备可以嵌套在 ami_block_device_mappings 或 launch_block_device_mappings 数组中。 这些磁盘将在您的实例启动时连接。决于您使用的 VM 类型，您在此处的选项可能会有所不同。 示例用例： 以下配置将告诉 Packer 在启动时使用特定的非默认 kms 密钥加密构建实例的根卷： HCL 样例： launch_block_device_mappings { device_name = \"/dev/sda1\" encrypted = true kms_key_id = \"1a2b3c4d-5e6f-1a2b-3c4d-5e6f1a2b3c4d\" } JSON 样例： \"launch_block_device_mappings\": [ { \"device_name\": \"/dev/sda1\", \"encrypted\": true, \"kms_key_id\": \"1a2b3c4d-5e6f-1a2b-3c4d-5e6f1a2b3c4d\" } ] 请注意，此示例中的 kms_key_id 选项存在于 launch_block_device_mappings 而不是 ami_block_device_mappings 当中。 可在此处找到块设备映射的文档：https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html 可选参数： delete_on_termination (bool) - 配置是否在实例终止时删除 EBS 卷。默认为 false。注意：如果此值未明确设置为 true 并且未通过替代方法清理卷，则每次构建后都会累积额外的卷。 device_name（string）- 向实例注册的设备名称（例如，/dev/sdh 或 xvdh）。块设备映射中的每个设备都需要配置。 encrypted (boolean) - 配置是否加密卷。默认情况下，Packer 会沿用源镜像中的加密设置。设置 false 将创建未加密的设备，而 true 将创建加密的设备。 iops (*int64) - 卷支持的每秒 I/O 操作数 (IOPS)。有关详细信息，请参阅有关 IOPS 的文档 no_device (bool) - 禁止包含在 AMI 的块设备映射中的指定设备。 snapshot_id (string) - 快照的 ID。 throughput (*int64) - gp3 卷的吞吐量，仅对 gp3 类型有效，请参阅有关吞吐量的文档以获取更多信息 virtual_name (string) - 虚拟设备名称。有关详细信息，请参阅有关块设备映射的文档。 volume_type（string）- 卷类型。 设置为 gp2 和 gp3 使用通用 (SSD) 卷，io1 和 io2 使用预置 IOPS (SSD) 卷，st1 用于吞吐量优化 HDD，sc1 用于冷 HDD，以及标准磁性卷。 volume_size (int64) - 卷的大小，以 GiB 为单位。如果未指定 snapshot_id，则为必需。 kms_key_id（string）- 用于引导卷加密的 KMS 密钥的 ID、别名或 ARN。此选项存在于 launch_block_device_mappings 而不是 ami_block_device_mappings。此处定义的 kms key id 仅适用于执行构建的区域；如果 AMI 被复制到其他区域，这些区域中的卷将由默认的 EBS KMS 密钥加密。有关有效格式，请参阅 AWS API 文档中的 KmsKeyId - CopyImage 此字段由 Packer 验证。使用别名时，您必须在 kms_key_id 前加上 alias/。 通信器配置 可选 communicator (string) - Packer 目前支持三种通信器： none - 不使用通信器。如果设置了此项，大多数配置器也无法使用。 ssh - 将建立到机器的 SSH 连接。这通常是默认值。 winrm - 将建立 WinRM 连接。 除了这些通信器之外，一些构建器还可以使用自定义通信器。例如，Docker 构建器有一个 \"docker\" 通信器，它使用 docker exec 和 docker cp 来执行脚本和复制文件。 pause_before_connecting (duration string | ex: \"1h5m2s\") - 我们建议您启用 SSH 或 WinRM 作为访客引导程序脚本的最后一步，但有时您可能会遇到竞争条件，您需要 Packer 在尝试连接之前等待您的系统就绪。 如果您遇到这种情况，您可以使用模板选项 pause_before_connecting。默认情况下，没有暂停。例如，如果您将 pause_before_connecting 设置为 10m，Packer 将检查它是否可以正常连接。但是一旦连接尝试成功，它将断开连接，然后等待 10 分钟，然后连接到系统并开始配置。 ssh_host (string) - SSH 的目标地址。这通常由构建器自动配置。 ssh_port (int) - SSH 的目标端口。默认为 22。 ssh_username (string) - 用于连接 SSH 的用户名。如果使用 SSH，则必须配置。 ssh_password（string）- 用于通过 SSH 进行身份验证的明文密码。 ssh_ciphers ([]string) - 这会覆盖 golang 默认支持的算法。默认值为 [ \"aes128-gcm@openssh.com\", \"chacha20-poly1305@openssh.com\", \"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\", ] 算法的有效选项包括：\"aes128-ctr\"、\"aes192-ctr\"、\"aes256-ctr\"、\"aes128-gcm@openssh.com\"、\"chacha20-poly1305@openssh.com\"、\"arcfour256\"、\"arcfour128\"、\"arcfour\"、\"aes128-cbc\"、\"3des-cbc\", ssh_clear_authorized_keys (bool) - 如果为 true，Packer 将尝试从 ~/.ssh/authorized_keys 和 /root/.ssh/authorized_keys 中删除其临时密钥。这主要是一个装样子的选项，因为无论是否设置为 true，Packer 都会从主机系统中删除临时私钥（除非用户设置了 -debug 标志）。默认为 false；目前仅适用于安装了 sed 的系统。 ssh_key_exchange_algorithms ([]string) - 如果设置该参数，Packer 将覆盖 golang 默认支持的密钥交换 (kex) 算法的值。可接受的值包括：\"curve25519-sha256@libssh.org\"、\"ecdh-sha2-nistp256\"、\"ecdh-sha2-nistp384\"、\"ecdh-sha2-nistp521\"、\"diffie-hellman-group14-sha1\"和\"diffie-hellman-group1-sha1\"。 ssh_certificate_file（string）- 用于通过 SSH 进行身份验证的用户证书的路径。 ~ 可以在路径中使用，将扩展为当前用户的主目录。 ssh_pty (bool) - 如果为 true，将为 SSH 连接请求 PTY。默认为 false。 ssh_timeout (duration string | ex: \"1h5m2s\") - 等待 SSH 可用的时间。Packer 使用它来确定机器何时启动，因此这通常很长。示例值：10m。默认为 5m，除非设置了 ssh_handshake_attempts。 ssh_disable_agent_forwarding (bool) - 如果为 true，SSH 代理转发将被禁用。默认为 false。 ssh_handshake_attempts (int) - 一旦可以连接，尝试发起的 SSH 握手次数。默认为 10，除非设置了 ssh_timeout。 ssh_bastion_host（string）- 用于实际 SSH 连接的堡垒主机。 ssh_bastion_port (int) - 堡垒主机的端口。默认为 22。 ssh_bastion_agent_auth (bool) - 如果为 true，则本地 SSH 代理将用于对堡垒主机进行身份验证。默认为 false。 ssh_bastion_username（string）- 连接堡垒主机的用户名。 ssh_bastion_password（string）- 用于向堡垒主机进行身份验证的密码。 ssh_bastion_interactive (bool) - 如果为 true，则键盘交互用于与堡垒主机进行身份验证。 ssh_bastion_private_key_file（string）- 用于与堡垒主机进行身份验证的 PEM 编码私钥文件的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_bastion_certificate_file（string）- 用于与堡垒主机进行身份验证的用户证书的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_file_transfer_method (string) - 选择使用 scp 或 sftp 作为传输文件、安全复制（默认）或 SSH 文件传输的协议。 ssh_proxy_host (string) - 用于 SSH 连接的 SOCKS 代理主机 ssh_proxy_port (int) - SOCKS 代理的端口。默认为 1080。 ssh_proxy_username（string）- 用于使用代理服务器进行身份验证的可选用户名。 ssh_proxy_password（string）- 用于向代理服务器进行身份验证的密码，可选。 ssh_keep_alive_interval (duration string | ex: \"1h5m2s\") - 向服务器发送\"keep alive\"消息的频率。设置为负值 (-1s) 以禁用。示例值：10s。默认为 5s。 ssh_read_write_timeout (duration string | ex: \"1h5m2s\") - 等待远程命令结束的时间量。这可能很有用，例如，如果 Packer 程序在服务器重新启动后阻塞在连接上。示例：5m。默认情况下禁用。 ssh_remote_tunnels ([]string) - ssh_local_tunnels ([]string) - temporary_key_pair_type（string）- dsa | ECDS | ed25519 | rsa（默认） 指定要创建的密钥类型。可配置的值为\"dsa\"、\"ecdsa\"、\"ed25519\"或\"rsa\"。 temporary_key_pair_bits (int) - 指定要创建的密钥中的位数。对于 RSA 密钥，最小大小为 1024 位，默认为 4096 位。通常，3072 位被认为足够了。 DSA 密钥必须恰好是 FIPS 186-2 指定的 1024 位。对于 ECDSA 密钥，位通过从三种椭圆曲线大小中选择一种来确定密钥长度：256、384 或 521 位。尝试使用 ECDSA 密钥的这三个值以外的位长度将失败。 Ed25519 密钥具有固定长度，位将被忽略。 ssh_keypair_name（string）- 如果配置该参数，那么它将是在 SSH 到机器时使用的密钥对。该密钥必须与加载到服务器中的密钥对名称相匹配。默认情况下不配置，除非使用 ssh_password，否则 Packer 将生成一个临时密钥对。使用 ssh_keypair_name 时必须指定 ssh_private_key_file 或 ssh_agent_auth。 ssh_private_key_file（string）- 用于通过 SSH 进行身份验证的 PEM 编码私钥文件的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_agent_auth (bool) - 如果为 true，则本地 SSH 代理将用于验证与源实例的连接。不会创建临时密钥对，ssh_password 和 ssh_private_key_file 的值将被忽略。必须设置环境变量 SSH_AUTH_SOCK 才能使此选项正常工作。 基础样例 这是一个基础示例。您将需要提供访问密钥，并且可能需要根据运行该模板时所能查到的镜像更改 AMI ID： HCL： // To make Packer read these variables from the environment into the var object, // set the environment variables to have the same name as the declared // variables, with the prefix PKR_VAR_. // There are other ways to [set variables](/packer/docs/templates/hcl_templates/variables#assigning-values-to-build-variables) // including from a var file or as a command argument. // export PKR_VAR_aws_access_key=$YOURKEY variable \"aws_access_key\" { type = string // default = \"hardcoded_key\" } // export PKR_VAR_aws_secret_key=$YOURSECRETKEY variable \"aws_secret_key\" { type = string // default = \"hardcoded_secret_key\" } source \"amazon-ebs\" \"basic-example\" { access_key = var.aws_access_key secret_key = var.aws_secret_key region = \"us-east-1\" source_ami = \"ami-fce3c696\" instance_type = \"t2.micro\" ssh_username = \"ubuntu\" ami_name = \"packer_AWS \" } build { sources = [ \"source.amazon-ebs.basic-example\" ] } JSON： { \"variables\": { \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\" }, \"builders\": [ { \"type\": \"amazon-ebs\", \"access_key\": \"{{user `aws_access_key`}}\", \"secret_key\": \"{{user `aws_secret_key`}}\", \"region\": \"us-east-1\", \"source_ami\": \"ami-fce3c696\", \"instance_type\": \"t2.micro\", \"ssh_username\": \"ubuntu\", \"ami_name\": \"packer_AWS {{timestamp}}\" } ] } 注意：Packer 也可以不用设置用户变量，直接从环境变量中读取访问密钥和秘密访问密钥。有关 Packer 将查找哪些环境变量的更多信息，请参阅上一节中的配置参考。 有关查找 AMI ID 及其与实例类型和区域的关系的更多信息，请参阅适用于 Linux 或 Windows 的 AWS EC2 文档。 访问主机实例来调试 如果出于某种原因需要访问实例进行调试，请使用 -debug 标志运行构建器。在调试模式下，Amazon 构建器会将私钥保存在当前目录中，并输出 DNS 或 IP 信息。您可以使用此信息来访问正在运行的实例。 AMI 块存储设备映射示例 下面是一个使用可选 AMI 块设备映射的示例。我们的 launch_block_device_mappings 配置将在构建期间将根卷 (/dev/sda) 扩大到 40gb（高于默认的 8gb）。使用 ami_block_device_mappings，当我们启动 AMI 的新实例时，AWS 将附加额外的卷 /dev/sdb 和 /dev/sdc。 HCL 样例： source \"amazon-ebs\" \"basic-example\" { region = \"us-east-1\" source_ami = \"ami-fce3c696\" instance_type = \"t2.micro\" ssh_username = \"ubuntu\" ami_name = \"packer_AWS_example_\" launch_block_device_mappings { device_name = \"/dev/sda1\" volume_size = 40 volume_type = \"gp2\" delete_on_termination = true } // Notice that instead of providing a list of mappings, you are just providing // multiple mappings in a row. This diverges from the JSON template format. ami_block_device_mappings { device_name = \"/dev/sdb\" virtual_name = \"ephemeral0\" } ami_block_device_mappings { device_name = \"/dev/sdc\" virtual_name = \"ephemeral1\" } } build { sources = [ \"source.amazon-ebs.basic-example\" ] } JSON 样例： { \"builders\": [ { \"type\": \"amazon-ebs\", \"region\": \"us-east-1\", \"source_ami\": \"ami-fce3c696\", \"instance_type\": \"t2.micro\", \"ssh_username\": \"ubuntu\", \"ami_name\": \"packer-quick-start \", \"launch_block_device_mappings\": [ { \"device_name\": \"/dev/sda1\", \"volume_size\": 40, \"volume_type\": \"gp2\", \"delete_on_termination\": true } ], \"ami_block_device_mappings\": [ { \"device_name\": \"/dev/sdb\", \"virtual_name\": \"ephemeral0\" }, { \"device_name\": \"/dev/sdc\", \"virtual_name\": \"ephemeral1\" } ] } ] } 假设您已设置环境变量 AWS_ACCESS_KEY_ID 和 AWS_SECRET_ACCESS_KEY，上述构建模板就可以正常工作。 注意：Packer 使用预构建的 AMI 作为构建镜像的来源。这些源 AMI 可能包含未标记为在构建新映像的实例终止时销毁的卷。 Packer 将尝试清除用户未指定在终止后保留的所有剩余卷。如果您需要保留这些源卷，您可以通过在设备的 launch_block_device_mappings 块中将 delete_on_termination 设置为 false 来改写终止设置。 构建时模板中可用的变量 在编写构建模板代码时，可以在代码中使用以下变量： BuildRegion - Packer 正在构建 AMI 的区域（例如 eu-central-1）。 SourceAMI - 用于构建 AMI 的源 AMI ID（例如 ami-a2412fcd）。 SourceAMICreationDate - 源 AMI 创建日期（例如\"2020-05-14T19:26:34.000Z\"）。 SourceAMIName - 用于构建 AMI 的源 AMI 名称（例如 ubuntu/images/ebs-ssd/ubuntu-xenial-16.04-amd64-server-20180306）。 SourceAMIOwner - 源 AMI 所有者 ID。 SourceAMIOwnerName - 源 AMI 所有者别名/名称（例如 amazon）。 SourceAMITags - 源 AMI 标签，类型为 map[string]string。 构建时共享的信息变量 本构建器在运行时会生成一些数据，这些数据通过旧的 JSON 模板引擎的构建功能和 HCL2 的上下文变量共享给配置器和后处理器。 BuildRegion - Packer 正在构建 AMI 的区域（例如 eu-central-1）。 SourceAMI - 用于构建 AMI 的源 AMI ID（例如 ami-a2412fcd）。 SourceAMICreationDate - 源 AMI 创建日期（例如 \"2020-05-14T19:26:34.000Z\"）。 SourceAMIName - 用于构建 AMI 的源 AMI 名称（例如 ubuntu/images/ebs-ssd/ubuntu-xenial-16.04-amd64-server-20180306）。 SourceAMIOwner - 源 AMI 所有者 ID。 SourceAMIOwnerName - 源 AMI 所有者别名/名称（例如 amazon）。 HCL 样例： # When accessing one of these variables from inside the builder, you need to # use the golang templating syntax. This is due to an architectural quirk that # won't be easily resolvable until legacy json templates are deprecated: build { source \"amazon-ebs\" \"basic-example\" { tags = { OS_Version = \"Ubuntu\" Release = \"Latest\" Base_AMI_ID = \"{{ .SourceAMI }}\" Base_AMI_Name = \"{{ .SourceAMIName }}\" } } // when accessing one of the variables from a provisioner or post-processor, use // hcl-syntax post-processor \"manifest\" { output = \"manifest.json\" strip_path = true custom_data = { source_ami_name = \"${build.SourceAMIName}\" } } JSON 样例： \"post-processors\": [ { \"type\": \"manifest\", \"output\": \"manifest.json\", \"strip_path\": true, \"custom_data\": { \"source_ami_name\": \"{{ build `SourceAMIName` }}\" } } ] Tags 样例 这里给出一个使用可选 AMI 标签的示例。这会将 OS_Version 和 Release 标签添加到完成的 AMI。和以前一样，您需要提供访问密钥，并且可能需要根据运行此模板时存在的镜像更改源 AMI ID： HCL 样例： source \"amazon-ebs\" \"basic-example\" { region = \"us-east-1\" source_ami = \"ami-fce3c696\" instance_type = \"t2.micro\" ssh_username = \"ubuntu\" ami_name = \"packer_tag_example {{timestamp}}\" tags = { OS_Version = \"Ubuntu\" Release = \"Latest\" Base_AMI_Name = \"{{ .SourceAMIName }}\" Extra = \"{{ .SourceAMITags.TagName }}\" } } build { sources = [ \"source.amazon-ebs.basic-example\" ] } JSON 样例： { \"builders\": [ { \"type\": \"amazon-ebs\", \"region\": \"us-east-1\", \"source_ami\": \"ami-fce3c696\", \"instance_type\": \"t2.micro\", \"ssh_username\": \"ubuntu\", \"ami_name\": \"packer-tag-example {{timestamp}}\", \"tags\": { \"OS_Version\": \"Ubuntu\", \"Release\": \"Latest\", \"Base_AMI_Name\": \"{{ .SourceAMIName }}\", \"Extra\": \"{{ .SourceAMITags.TagName }}\" } } ] } 通过 WinRM 连接 Windows 实例 如果要启动 Windows 实例并使用 WinRM 进行连接，则需要在该实例上配置 WinRM。以下是可以使用 AWS 的 \"user_data_file\" 选项配置的 powershell 脚本。它通过端口 5986 上的 HTTPS 启用 WinRM，并创建用于连接的自签名证书。如果您使用的是来自 CA 的证书，而不是创建自签名证书，则可以省略下面提到的 \"winrm_insecure\" 选项。 autogenerated_pa​​ssword_https_bootstrap.txt # MAKE SURE IN YOUR PACKER CONFIG TO SET: # # # \"winrm_username\": \"Administrator\", # \"winrm_insecure\": true, # \"winrm_use_ssl\": true, # # write-output \"Running User Data Script\" write-host \"(host) Running User Data Script\" Set-ExecutionPolicy Unrestricted -Scope LocalMachine -Force -ErrorAction Ignore # Don't set this before Set-ExecutionPolicy as it throws an error $ErrorActionPreference = \"stop\" # Remove HTTP listener Remove-Item -Path WSMan:\\Localhost\\listener\\listener* -Recurse # Create a self-signed certificate to let ssl work $Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\\LocalMachine\\My -DnsName \"packer\" New-Item -Path WSMan:\\LocalHost\\Listener -Transport HTTPS -Address * -CertificateThumbPrint $Cert.Thumbprint -Force # WinRM write-output \"Setting up WinRM\" write-host \"(host) setting up WinRM\" cmd.exe /c winrm quickconfig -q cmd.exe /c winrm set \"winrm/config\" '@{MaxTimeoutms=\"1800000\"}' cmd.exe /c winrm set \"winrm/config/winrs\" '@{MaxMemoryPerShellMB=\"1024\"}' cmd.exe /c winrm set \"winrm/config/service\" '@{AllowUnencrypted=\"true\"}' cmd.exe /c winrm set \"winrm/config/client\" '@{AllowUnencrypted=\"true\"}' cmd.exe /c winrm set \"winrm/config/service/auth\" '@{Basic=\"true\"}' cmd.exe /c winrm set \"winrm/config/client/auth\" '@{Basic=\"true\"}' cmd.exe /c winrm set \"winrm/config/service/auth\" '@{CredSSP=\"true\"}' cmd.exe /c winrm set \"winrm/config/listener?Address=*+Transport=HTTPS\" \"@{Port=`\"5986`\";Hostname=`\"packer`\";CertificateThumbprint=`\"$($Cert.Thumbprint)`\"}\" cmd.exe /c netsh advfirewall firewall set rule group=\"remote administration\" new enable=yes cmd.exe /c netsh firewall add portopening TCP 5986 \"Port 5986\" cmd.exe /c net stop winrm cmd.exe /c sc config winrm start= auto cmd.exe /c net start winrm 您会注意到此配置没有定义用户或密码；相反，Packer 会要求 AWS 提供它自动生成的随机密码。 以下配置将与上述模板一起使用： HCL 样例： # This example uses a amazon-ami data source rather than a specific AMI. # this allows us to use the same filter regardless of what region we're in, # among other benefits. data \"amazon-ami\" \"example\" { filters = { virtualization-type = \"hvm\" name = \"*Windows_Server-2012*English-64Bit-Base*\" root-device-type = \"ebs\" } owners = [\"amazon\"] most_recent = true # Access Region Configuration region = \"us-east-1\" } source \"amazon-ebs\" \"winrm-example\" { region = \"us-east-1\" source_ami = data.amazon-ami.example.id instance_type = \"t2.micro\" ami_name = \"packer_winrm_example \" # This user data file sets up winrm and configures it so that the connection # from Packer is allowed. Without this file being set, Packer will not # connect to the instance. user_data_file = \"../boot_config/winrm_bootstrap.txt\" communicator = \"winrm\" force_deregister = true winrm_insecure = true winrm_username = \"Administrator\" winrm_use_ssl = true } build { sources = [ \"source.amazon-ebs.winrm-example\" ] } JSON 样例： { \"builders\": [ { \"type\": \"amazon-ebs\", \"region\": \"us-east-1\", \"instance_type\": \"t2.micro\", \"source_ami_filter\": { \"filters\": { \"virtualization-type\": \"hvm\", \"name\": \"*Windows_Server-2012*English-64Bit-Base*\", \"root-device-type\": \"ebs\" }, \"most_recent\": true, \"owners\": \"amazon\" }, \"ami_name\": \"default-packer\", \"user_data_file\": \"./boot_config/winrm_bootstrap.txt\", \"communicator\": \"winrm\", \"force_deregister\": true, \"winrm_insecure\": true, \"winrm_username\": \"Administrator\", \"winrm_use_ssl\": true } ] } Windows 2016 Sysprep 命令 - 仅适用于 Amazon Windows AMI 对于 Amazon Windows 2016 AMI，必须要运行 Sysprep 命令，这些命令可以轻松添加到配置器当中。 HCL 样例： provisioner \"powershell\" { inline = [ \"C:/ProgramData/Amazon/EC2-Windows/Launch/Scripts/InitializeInstance.ps1 -Schedule\", \"C:/ProgramData/Amazon/EC2-Windows/Launch/Scripts/SysprepInstance.ps1 -NoShutdown\" ] } JSON 样例： { \"type\": \"powershell\", \"inline\": [ \"C:/ProgramData/Amazon/EC2-Windows/Launch/Scripts/InitializeInstance.ps1 -Schedule\", \"C:/ProgramData/Amazon/EC2-Windows/Launch/Scripts/SysprepInstance.ps1 -NoShutdown\" ] } 该使用哪种 SSH 参数选项？ 如果您设置以下 SSH 选项，下面的图表分解描述了 Packer 会执行的操作： ssh_password ssh_private_key_file ssh_keypair_name temporary_key_pair_name Packer will... X - - - 使用给定的用户名和密码进行 ssh 认证 - X - - 使用给定的私钥文件进行 ssh 认证 - X X - 使用给定的私钥文件进行 ssh 验证，并将配置的 keipair 附加到实例上 - - - X 使用特定名称创建一个临时的 ssh keypair，使用后清除 - - - - 使用默认名称创建一个临时的 ssh keypair，使用后清除 "},"7.builders/4.azure/overview.html":{"url":"7.builders/4.azure/overview.html","title":"Azure","keywords":"","body":"Azure 虚拟机镜像构建器 原文 Packer 可以通过多种方式创建 Azure 虚拟机镜像，具体取决于要用于构建镜像的策略。 本手册目前仅翻译以下构建器： azure-arm - 使用 Azure 资源管理器 (ARM) 启动虚拟机 (VM)，配置后生成新镜像。如有疑问，请使用此构建器，它是最容易上手的构建器。 Azure 身份认证 Packer Azure 构建器提供了以下几种与 Azure 进行身份验证的方法： Azure Active Directory 交互式登录。交互式登录仅适用于公共云和美国政府云。 Azure 托管身份(Managed Identity) Azure Active Directory 服务主体(Service Principal) Azure CLI 如果您不知道该使用哪种身份验证方法，可以使用交互式登录来试用构建器。如果您需要在自动化环境中使用 Packer，请使用服务主体或托管身份。 无论您选择哪种方法，您使用的身份都需要对 Azure 资源具有适当的权限，Packer 才能运行。最小权限集高度依赖于构建器及其配置。一种简单的入门方法是在订阅级别为身份分配 Contributor 角色。 Azure Active Directory 交互式登录 如果您的组织允许，您可以使用基于 oAuth 的 \"device code flow\" 的命令行交互式登录方法。当您仅在构建器配置中指定 use_interactive_auth 时，Packer 将选择该方法。当您运行 Packer 时，它会要求您访问一个网站并输入一个代码。然后，该网站将对您进行身份验证，使用您的组织可能配置的双因素身份验证策略进行验证。令牌缓存在您的主目录中的 .azure/packer 目录下，如果它们在后续运行中仍然有效，将被重复使用。 请注意，交互式登录仅适用于 Azure 公共云，不适用于主权/政府云。 Azure 托管身份 Azure 可以将身份分配给虚拟机（Azure 文档）。Packer 可以使用系统为运行 Packer 的 VM 分配的身份来调用 Azure API。这是默认行为，不需要设置任何配置属性。但是，这需要您在 Azure VM 上运行 Packer。 要启用此方法，让 Azure 为您的 VM 分配一个系统分配的身份。然后，授予您的 VM 访问适当资源的权限。如果 Azure VM 分配了多个托管身份（例如，系统分配的身份和用户分配的身份），则可以指定 client_id 配置参数以选择要使用的适当的托管身份。 source \"azure-arm\" \"basic-example\" { client_id = \"fe354398-d7sf-4dc9-87fd-c432cd8a7e09\" resource_group_name = \"packerdemo\" storage_account = \"virtualmachines\" capture_container_name = \"images\" capture_name_prefix = \"packer\" os_type = \"Linux\" image_publisher = \"Canonical\" image_offer = \"UbuntuServer\" image_sku = \"14.04.4-LTS\" location = \"West US\" vm_size = \"Standard_A2\" } 首先，尝试将 Subscription 级别的 Contributor 角色分配给您的 VM。然后，根据实际需求适当地将权限范围缩小或将 Packer 构建隔离在单独的订阅中。 Azure Active Directory 服务主体 Azure Active Directory 设计了名为“服务主体”(Service Principal) 对象的服务账号。SP 表示访问 Azure 资源的应用程序。它由 Client ID（又名 Application ID）标识，可以使用密码或证书进行身份验证。要使用服务主体，请指定 subscription_id 和 client_id，以及 client_secret、client_cert_path 或 client_jwt。后三个参数中的每一个都代表一种不同的方式来向 AAD 验证 SP： client_secret - 用户可以设置 AAD SP 注册时配置的密码/机密。 client_cert_path - 可以设置证书作为指定的 AAD SP 身份验证凭据。 client_cert_token_timeout - 设置使用 client_cert_path 时创建的令牌的过期时间。 client_jwt - 当用户无法向 Packer 提供完整证书的时候，他们可以为客户端身份验证提供 JWT 令牌（RFC 7523，第 2.2 节）。这些令牌是使用在 AAD 中注册的证书创建和签名的，并且具有用户设置的到期时间，从而限制令牌的有效性。使用 client_cert_path 作为身份验证时的也可以使用相同的底层机制。 要创建服务主体，您可以按照有关此主题的 Azure 文档进行操作。 Azure CLI 使用该方法将跳过提供的所有其他选项，并且仅使用 az cli 用于进行身份验证的凭据。可适用于普通用户 (az login) 和服务主体 (az login --service-principal --username APP_ID --password PASSWORD --tenant TENANT_ID)。 要启用 az cli 身份验证，请使用以下命令： use_azure_cli_auth : true 此模式将使用当前活动 az 会话中的 tenant_id 和 subscription_id，这些信息可以通过运行 az account show 命令获取。 "},"7.builders/4.azure/1.arm.html":{"url":"7.builders/4.azure/1.arm.html","title":"ARM","keywords":"","body":"Azure Resource Manager 构建器 原文 类型：azure-arm Artifact BuilderId：Azure.ResourceManagement.VMImage Packer 支持在 Azure 资源管理器中构建虚拟硬盘 (VHD) 和托管镜像。 Azure 在前 30 天为新用户提供 200 美元的信用额度；之后，您将承担使用 Packer 构建和存储虚拟机的费用。 Azure 结合使用 OAuth 和 Active Directory 来授权对 ARM API 的请求。了解如何配置访问 ARM 的授权。 下面的文档引用了 Azure CLI 的命令输出。 配置参考 构建器有许多可用的配置选项。我们将从身份验证参数开始介绍，然后是 Azure ARM 构建器特有的选项。除了此处列出的选项之外，还可以为此构建器配置通信器。 身份认证选项 在配置中允许通过多种方式对 Azure 客户端进行身份验证。当指定 client_id 和 subscription_id 以及以下一项且仅一项时：client_secret、client_jwt、client_cert_path —— Packer 将使用指定的 Azure Active Directory (AAD) 服务主体 (SP)。如果仅指定了 use_interactive_auth，Packer 将尝试以交互方式登录当前用户（令牌将被缓存）。如果上述选项均未设置，Packer 将尝试使用运行 Packer 的虚拟机上附加的托管身份和订阅。这仅在 Packer 在具有 System Assigned 或 User Assigned 的托管身份的 Azure 虚拟机上运行时才有效。 托管身份 如果在具有托管身份的 Azure 虚拟机上运行 Packer，则无需指定任何其他配置选项。因为 Packer 将尝试使用运行 Packer 的虚拟机的托管身份和订阅。 可以通过设置 subscription_id 使用不同的订阅。如果您的虚拟机有多个用户分配的托管身份，您也需要设置 client_id。 交互式用户登录 要使用交互式用户身份验证，您应该仅设置 use_interactive_auth。 Packer 将使用缓存的凭据或将您重定向到网站进行登录。 服务主体 要使用服务主体，您应该指定 subscription_id、client_id 以及 client_secret、client_cert_path 或 client_jwt 之一。 subscription_id (string) - 执行构建所使用的订阅 Id。 client_id 中指定的服务主体必须具有对此订阅的完全访问权限，除非指定了 build_resource_group_name 选项，在这种情况下，它需要拥有对 build_resource_group_name 参数中指定的已经存在的资源组的所有者访问权限。 client_id（string）- 与您的构建器关联的 Active Directory 服务主体。 client_secret（string）- 您的服务主体的密码或机密。 client_cert_path（string）- 包含服务主体的证书和私钥的 PEM 文件的位置。 client_cert_token_timeout (duration string | ex: \"1h30m12s\") - 在使用 client_cert_path 时创建的令牌上设置过期时间的时间。 client_jwt（string）- 使用与您的服务主体主体关联的证书签署的 JWT。有关详细信息，请参阅 Azure Active Directory 文档。 Azure ARM 构建器特定选项 Azure 构建器可以创建 VHD、托管镜像或创建共享镜像库。如果要创建 VHD，则必须使用一个现存的 VHD。同样，如果要创建托管镜像，则必须使用一个现存的托管镜像。托管镜像也可以发布到共享镜像库，但发布到库不需要托管镜像的定义。 必须 image_publisher（string）- 用于基础镜像的发布者的名称（仅限 Azure 市场镜像）。有关详细信息，请参阅文档。 使用 CLI 获取该参数的示例 az vm image list-publishers --location westus image_offer（string）- 用于基础镜像的发布者 offer 的名称（仅限 Azure 市场镜像）。有关详细信息，请参阅文档。 使用 CLI 获取该参数的示例 az vm image list-offers --location westus --publisher Canonical image_sku（string）- 适用于基础镜像 offer 的 SKU（仅限 Azure 市场镜像）。有关详细信息，请参阅文档。 使用 CLI 获取该参数的示例 az vm image list-skus --location westus --publisher Canonical --offer UbuntuServer image_url（string）- 作为基础镜像的自定义 VHD 的 URL。如果设置了此值，则不应设置 image_publisher、image_offer、image_sku 或 image_version。 custom_managed_image_name（string）- 用作基础镜像的自定义托管镜像的名称。如果设置了该值，则不要设置 image_publisher、image_offer、image_sku 或 image_version。如果设置了此值，则还必须设置选项 custom_managed_image_resource_group_name。请参阅文档以了解有关托管镜像的更多信息。 custom_managed_image_resource_group_name（string）- 用作于基础镜像的自定义托管镜像所在的资源组的名称。如果设置了此值，则不要设置 image_publisher、image_offer、image_sku 或 image_version。如果设置了此值，则还必须设置选项 custom_managed_image_name。请参阅文档以了解有关托管镜像的更多信息。 创建 VHD 时，需要以下附加选项： capture_container_name (string) - 目标容器名称。本质上是您的 VHD 在 Azure 中所保存的“目录”。创建的 VHD 的 URL 将为 https://.blob.core.windows.net/system/Microsoft.Compute/Images//.xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.vhd。 capture_name_prefix（string）- VHD 前缀。最终的制品将被命名为 PREFIX-osDisk.UUID 和 PREFIX-vmTemplate.UUID。 resource_group_name (string) - 将存储最终制品的资源组。 storage_account (string) - 存储最终制品的存储帐户。 创建托管镜像时，需要以下附加选项： managed_image_name (string) - 设置将保存的 Packer 构建的托管镜像的名称。不能存在用该名称命名的托管镜像，Packer 不会覆盖同名文件。如果设置了此值，则还必须设置值 managed_image_resource_group_name。请参阅文档以了解有关托管镜像的更多信息。 managed_image_resource_group_name（string）- 设置将保存 Packer 构建的托管镜像的资源组名称。资源组必须已经存在。如果设置了此值，则还必须设置值 managed_image_name。请参阅文档以了解有关托管镜像的更多信息。 可以通过指定 shared_image_gallery 配置选项来创建使用共享库镜像作为源的托管镜像。 Resource Group 用例 Azure 构建器可以在它控制的新资源组（默认）或现有资源组中创建资源。使用 Packer 创建的资源组的优点是失败时清理资源更容易，因为您可以简单地删除整个资源组，但这意味着提供的凭据必须具有创建和删除资源组的权限。通过使用现有资源组，您可以将提供的凭据范围限定到该组，但是构建失败后更有可能留下未使用的制品。 要让 Packer 创建资源组，您必须提供： location(string)您的虚拟机将在该区域运行。 使用 CLI 获取该参数的示例: az account list-locations 并可配置可选参数： temp_resource_group_name（string）分配给构建期间创建的临时资源组的名称。如果没有设置此参数，将分配一个随机值。该资源组在构建结束时被删除。 要使用现有资源组，您必须提供： build_resource_group_name（string）- 指定一个现有的资源组来运行构建。 设置了 temp_resource_group_name 或 location 时就不能设置 build_resource_group_name。 可选 user_assigned_managed_identities ([]string) - 要在虚拟机上配置的用户分配托管身份的一个或多个 ID 的列表。有关如何在虚拟机中获取令牌的信息，请参阅文档。若要将用户分配的托管身份分配给虚拟机，提供的帐户或服务主体必须具有 Managed Identity Operator 和Virtual Machine Contributor的角色。 capture_name_prefix（string）- VHD 前缀。 capture_container_name (string) - 目标容器名称。 shared_image_gallery (SharedImageGallery) - 使用共享镜像库的镜像作为本次构建的源镜像。 VHD 目标与此构建类型不兼容 - 目标必须是托管镜像。当使用 shared_image_gallery 作为源时，不应设置 image_publisher、image_offer、image_sku、image_version 和 custom_managed_image_name。 JSON 样例： \"shared_image_gallery\": { \"subscription\": \"00000000-0000-0000-0000-00000000000\", \"resource_group\": \"ResourceGroup\", \"gallery_name\": \"GalleryName\", \"image_name\": \"ImageName\", \"image_version\": \"1.0.0\", } \"managed_image_name\": \"TargetImageName\", \"managed_image_resource_group_name\": \"TargetResourceGroup\" HCL 样例： shared_image_gallery { subscription = \"00000000-0000-0000-0000-00000000000\" resource_group = \"ResourceGroup\" gallery_name = \"GalleryName\" image_name = \"ImageName\" image_version = \"1.0.0\" } managed_image_name = \"TargetImageName\" managed_image_resource_group_name = \"TargetResourceGroup\" shared_image_gallery_destination (SharedImageGalleryDestination) - 共享镜像库的名称，托管镜像将发布为该共享镜像库内的镜像版本。 JSON 样例： \"shared_image_gallery_destination\": { \"subscription\": \"00000000-0000-0000-0000-00000000000\", \"resource_group\": \"ResourceGroup\", \"gallery_name\": \"GalleryName\", \"image_name\": \"ImageName\", \"image_version\": \"1.0.0\", \"replication_regions\": [\"regionA\", \"regionB\", \"regionC\"], \"storage_account_type\": \"Standard_LRS\" } \"managed_image_name\": \"TargetImageName\", \"managed_image_resource_group_name\": \"TargetResourceGroup\" HCL 样例： shared_image_gallery_destination { subscription = \"00000000-0000-0000-0000-00000000000\" resource_group = \"ResourceGroup\" gallery_name = \"GalleryName\" image_name = \"ImageName\" image_version = \"1.0.0\" replication_regions = [\"regionA\", \"regionB\", \"regionC\"] storage_account_type = \"Standard_LRS\" } managed_image_name = \"TargetImageName\" managed_image_resource_group_name = \"TargetResourceGroup\" shared_image_gallery_timeout（持续时间string | 例如：\"1h5m2s\"） - 在超时之前等待镜像发布到共享镜像库的时间。如果您的 Packer 构建在发布到共享镜像库步骤中失败并出现 Original Error: context deadline exceeded，但是当您从 Azure 网页控制台检查时镜像存在，那么您可能需要将此超时从其默认值 \"60m\" 增加（有效的时间单位包括 s 代表秒，m 代表分钟，h 代表小时。） shared_gallery_image_version_end_of_life_date(string)- 共享镜像库镜像版本的生命周期结束日期 (2006-01-02T15:04:05.99Z)。此属性可用于退役目的。 shared_image_gallery_replica_count (int32) - 要创建的镜像版本在每个区域的副本数。当未指定 regionalReplicaCount 时，此属性将对单个区域生效。副本数必须在 1 到 100 之间，但对于大多数用例而言，50 个副本应该足够了。 shared_gallery_image_version_exclude_from_latest (bool) - 如果设置为 true，设置为从最新版本的镜像定义部署的虚拟机将不会使用此镜像版本。 image_version(string)- 指定要使用的镜像版本。默认为 latest。由于镜像同步延迟，不同地区可用的版本可能存在差异。为确保跨区域的版本一致，请将此值设置为在您部署的所有区域都可用的值。 使用 CLI 获取该参数的示例 az vm image list --location westus --publisher Canonical --offer UbuntuServer --sku 16.04.0-LTS --all location(string)- 将要运行构建的虚拟机所在的 Azure 数据中心。 vm_size (string) - 用于构建的虚拟机的大小。当您从 VHD 部署虚拟机时，可以更改此设置。查看定价信息。默认为 Standard_A1。 使用 CLI 获取该参数的示例 az vm list-sizes --location westus spot (Spot) - 是否在构建期间使用 spot 实例； spot 配置设置仅适用于 Packer 启动的虚拟机，不会保留在生成的镜像制品上。 managed_image_resource_group_name(string)- 指定将用于保存 Packer 构建结果的托管镜像的资源组名称。资源组必须已经存在。如果设置了此值，则还必须设置值 managed_image_name。请参阅文档以了解有关托管镜像的更多信息。 managed_image_name (string) - 指定将保存 Packer 构建结果的托管镜像名称。不能提前存在同名镜像，Packer 不会尝试覆盖同名镜像。如果设置了此值，则还必须设置 managed_image_resource_group_name。请参阅文档以了解有关托管镜像的更多信息。 managed_image_storage_account_type(string)- 指定托管镜像的存储帐户类型。有效值为 Standard_LRS 和 Premium_LRS。默认值为 Standard_LRS。 managed_image_os_disk_snapshot_name(string)- 如果设置了 managed_image_os_disk_snapshot_name，则会在保存虚拟机之前使用与此值相同的名称创建操作系统磁盘的快照。 managed_image_data_disk_snapshot_prefix(string)- 如果设置了 managed_image_data_disk_snapshot_prefix，则在保存虚拟机之前使用与此值相同的前缀创建数据磁盘的快照。 keep_os_disk (bool) - 如果设置了 keep_os_disk，则不会删除操作系统磁盘。默认为 false。 managed_image_zone_resilient (bool) - 将镜像存储在区域弹性存储中。您需要在支持可用区的区域中创建它。 azure_tags (map[string]string) - 创建的所有例如资源组、VM、NIC、VNET、公网 IP、KeyVault 等资源所附带的 Name/Value 标签对。用户最多可以定义 15 个标签。标记名称不能超过 512 个字符，标记值不能超过 256 个字符。 azure_tag ([]{name string, value string}) - 与 azure_tags 相同，但定义为包含名称和值字段的单一可重复块。在 HCL2 模式下，dynamic_block 将允许您动态地生成这些内容。 resource_group_name (string) - 将存储最终制品的资源组。 storage_account (string) - 存储最终制品的 Storage Account。 temp_compute_name(string)- 分配给虚拟机的临时名称。如果未设置此值，将分配一个随机值。知晓资源组和虚拟机名称是的 Packer 在构建期间可以执行命令来更新虚拟机，例如将资源磁盘附加到虚拟机。 temp_nic_name (string) - 分配给 Nic 的临时名称。如果未设置此值，将分配一个随机值。如果能够分配遵循命名约定规范的自定义 nic 名称可以简化部署。 temp_resource_group_name (string) - 分配给构建期间创建的临时资源组的名称。如果未设置此值，将分配一个随机值。该资源组在构建结束时被删除。 build_resource_group_name(string)- 指定一个现有的资源组来运行构建。 build_key_vault_name(string)- 指定一个现有的 Key Vault，用于将证书上传到要连接的实例。 build_key_vault_sku(string)- 指定要在构建期间创建的 Key Vault 的 SKU。有效值为 standard 或 premium。默认值为 standard。 disk_encryption_set_id(string)- 指定磁盘加密集(Disk Encryption Set) ID，用于加密在构建期间使用虚拟机创建的操作系统和数据磁盘，仅在发布到共享镜像库时可用，托管镜像不可用。磁盘加密集 ID 可以在Azure 门户上设置的磁盘加密的属性选项卡中查看 https://learn.microsoft.com/en-us/azure/virtual-machines/image-version-encryption private_virtual_network_with_public_ip (bool) - 此值允许您设置 virtual_network_name 并获取公网 IP。如果未设置该值且 virtual_network_name 已定义，则仅允许从同一子网/虚拟网络上的主机执行 Packer。 virtual_network_name(string)- 为虚拟机使用预先存在的虚拟网络。此选项启用与虚拟机的私有通信，不使用或配置公网 IP 地址（除非您设置 private_virtual_network_with_public_ip）。 virtual_network_subnet_name (string) - 如果设置了 virtual_network_name，则也可以设置该值。如果设置了 virtual_network_name 而未设置此值，则构建器会尝试确定要与虚拟网络一起使用的子网。如果找不到子网，或者无法在多个子网中决定使用哪个，则应设置此值。 virtual_network_resource_group_name(string)- 如果设置了 virtual_network_name，则也可以设置该值。如果设置了 virtual_network_name 而未设置此值，构建器将尝试确定包含虚拟网络的资源组。如果找不到资源组，或者无法消除歧义，则应设置此值。 custom_data_file (string) - 指定包含 custom data 的文件以注入到 cloud-init 进程中。文件的内容被读取并注入到 ARM 模板中。custom data 将在配置时传递给 cloud-init 进行处理。请参阅文档以了解有关自定义数据的更多信息，以及如何使用它来影响供应过程。 custom_data (string) - 指定启动实例时要应用的 Base64 编码 custom data。请注意，由于模板是 JSON，因此您需要注意转义字符。custom data 将在配置时传递给 cloud-init 进行处理。请参阅文档以了解有关 custom data 的更多信息，以及如何使用它来影响配置过程。 user_data_file (string) - 指定包含 user data 的文件以注入到 cloud-init 进程中。文件的内容被读取并注入到 ARM 模板中。从虚拟机被配置到被删除之间，user data 都可以被读取。虚拟机上的任何应用程序都可以在配置后从 Azure 实例元数据服务 (IMDS) 访问 user data。请参阅文档以了解有关用户数据的更多信息。 user_data (string) - 指定要应用的 Base64 编码 user data。请注意，由于模板是 JSON，因此您需要注意转义字符。从虚拟机被配置到被删除之间，user data 都可以被读取。虚拟机上的任何应用程序都可以在配置后从 Azure 实例元数据服务 (IMDS) 访问 user data。请参阅文档以了解有关用户数据的更多信息。 custom_script（string）- 用于在镜像构建期间运行有关虚拟机配置的脚本。 以下示例执行 user_data_file 指定的文件的内容： custom_script = \"powershell -ExecutionPolicy Unrestricted -NoProfile -NonInteractive -Command \\\"$userData = (Invoke-RestMethod -Headers @{Metadata=$true} -Method GET -Uri http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-01-01$([char]38)format=text); $contents = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData)); set-content -path c:\\\\Windows\\\\Temp\\\\userdata.ps1 -value $contents; . c:\\\\Windows\\\\Temp\\\\userdata.ps1;\\\"\" user_data_file = \"./scripts/userdata.ps1\" 指定一个命令注入 CustomScriptExtension，在 Windows 构建启动后，通信器尝试连接之前运行，请参阅文档了解更多信息。 plan_info (PlanInformation) - 用于从 Marketplace 镜像创建镜像。有关更多详细信息，请参阅使用 Marketplace 条款部署镜像。并非所有 Marketplace 镜像都支持程序化部署，并且镜像的支持是由镜像发布者控制的。 下面定义了一个示例 plan_info 对象。 { \"plan_info\": { \"plan_name\": \"rabbitmq\", \"plan_product\": \"rabbitmq\", \"plan_publisher\": \"bitnami\" } } plan_name (string) - 计划名称，必需。 plan_product (string) - 计划产品，必需。 plan_publisher (string) - 计划发布者，必需。 plan_promotion_code (string) - 一些镜像可以配置促销代码，可选。 使用 plan_info 从 Marketplace 创建的映像必须在部署镜像时指定 plan_info。构建器会自动将以下标签添加到镜像以确保此信息不会丢失： 1. PlanName 2. PlanProduct 3. PlanPublisher 4. PlanPromotionCode polling_duration_timeout (duration string | ex: \"1h5m2s\") - azure 的默认 PollingDuration 为 15 分钟，本参数将覆盖该值。请参阅 Azure DefaultPollingDuration。如果您的 Packer 构建在 ARM 部署时失败并出现错误 Original Error: context deadline exceeded，那么您可能需要将此超时从其默认值 15m 增加（有效时间单位包括 s 表示秒，m 表示分钟，h 代表小时。） os_type (string) - 如果指定了 Linux 或 Windows，Packer 将自动为要配置的机器配置身份验证凭据。对于 Linux，会配置 SSH 授权密钥。对于 Windows，会配置一个 WinRM 证书。 temp_os_disk_name (string) - 分配给 OSDisk 的临时名称。如果未设置此值，将分配一个随机值。如果能够分配遵循命名约定规范的自定义 osDiskName 名称可以简化部署。 os_disk_size_gb (int32) - 以 GB（千兆字节）为单位指定操作系统磁盘的大小。设置位小于等于零的值会被忽略。 disk_additional_size ([]int32) - 虚拟机的额外附加硬盘的大小（以 GB 为单位）。如果未指定，则虚拟机将仅包含一个 OS 磁盘。额外磁盘的数量和磁盘的最大大小取决于虚拟机的配置。有关详细信息，请参阅 Windows 或 Linux。 对于 VHD 构建，最终制品将被命名为 PREFIX-dataDisk-.UUID.vhd 并与操作系统磁盘一起存储在指定的存储容器中。额外的磁盘包含名为 PREFIX-vmTemplate.UUID 的部署模板中。 对于托管镜像的构建，最终制品包含在托管镜像中。附加的磁盘将具有与 OS 磁盘相同的存储帐户类型，由 managed_image_storage_account_type 参数所指定。 disk_caching_type (string) - 指定磁盘缓存类型。有效值为 None、ReadOnly 和 ReadWrite。默认值为 ReadWrite。 allowed_inbound_ip_addresses ([]string) - 指定应允许访问虚拟机的 IP 地址和 CIDR 块的列表。如果设置，将使用相应的规则创建 Azure 网络安全组并绑定到虚拟机的子网。不允许同时设置 allowed_inbound_ip_addresses 与 virtual_network_name。 boot_diag_storage_account（string）- 指定用于存储启动诊断的存储账户 —— 设置该参数将在指定的存储帐户中创建 2 个文件（串行控制台日志和屏幕截图文件）。构建完成后，必须手动将其删除。在这里查看更多信息 custom_resource_build_prefix（string）- 在构建期间指定自定义 Azure 资源名称，限制为最多 10 个字符，这将为资源名称设置前缀。实际资源名称将是 custom_resource_build_prefix + resourcetype + 5 个字符的随机字母数字字符串 license_type（string）- 为构建虚拟机指定许可证类型以启用 Azure 混合权益。如果未设置，将使用现收现付(Pay-As-You-Go)许可模式（默认）。有效值为： 对于 Windows： Windows_Client Windows_Server 对于 Linux： RHEL_BYOS SLES_BYOS 有关混合权益的更多信息，请参阅以下文档：Windows 以及 Linux secure_boot_enabled (bool) - 指定是否为虚拟机启用安全引导和可信启动。 vtpm_enabled (bool) - 指定是否为虚拟机启用 vTPM（虚拟可信平台模块）和可信启动。 async_resourcegroup_delete (bool) - 如果你想让 Packer 异步删除临时资源组时设置这个参数。它是一个布尔值，默认为 false。将此设置为 true 意味着您的构建速度更快，但是删除资源组失败时不会报错。 cloud_environment_name（string）- Public、China、Germany 或 USGovernment 之一。默认为 Public。还支持 USGovernmentCloud 和 AzureUSGovernmentCloud 等长格式。 metadata_host（string）- Azure 元数据服务的主机名（例如 management.azure.com），用于在使用自定义 Azure 环境时获取云环境。这也可以通过 ARM_METADATA_HOST 环境变量设置该参数。注意：cloud_environment_name 必须设置为 metadata_host 中可用环境列表中请求的环境名称。 client_id（string）- AAD 服务主体的 Application ID。还需要设置 client_secret、client_cert_path 或 client_jwt。 client_secret（string）- 为 AAD 服务主体注册的密码/机密。 client_cert_path（string）- 将用于作为指定 AAD 服务主体进行身份验证的 pem 编码证书的路径。 client_cert_token_timeout (duration string | ex: \"1h5m2s\") - 使用客户端证书时 JWT 令牌的超时时间。默认为 1 小时。 client_jwt（string）- 用于客户端身份验证（RFC 7523，第 2.2 节）的 JWT 承载令牌，将用于对 AAD 服务主体进行身份验证。与使用 client_cert_path 相比，在使用证书身份验证时拥有对令牌过期的更细致控制能力。 object_id（string）- AAD 服务主体的 Object ID。可选，如果留空，将从 oAuth 令牌派生。 tenant_id（string）- 与您的 client_id 和 subscription_id 关联的 Active Directory 租户标识符。如果未指定，将使用 subscription_id 查找 tenant_id。 subscription_id (string) - 要使用的订阅 ID。 use_azure_cli_auth (bool) - 使用 Azure CLI 身份验证的参数。默认为 false。 CLI 身份验证将使用来自活动 az login 会话的信息连接到 Azure，并设置与登录帐户关联的订阅 ID 和租户 ID。如果启用，它将使用 az CLI 提供的身份验证。 Azure CLI 身份验证将使用标记为 isDefault 的凭据，并且可以使用 az account show 进行验证。可以搭配普通身份验证 (az login) 和服务主体 (az login --service-principal --username APP_ID --password PASSWORD --tenant TENANT_ID)验证。如果启用则忽略所有其他配置。 use_interactive_auth (bool) - 使用交互式登录（使用设备代码）身份验证的标志。默认为 false。如果启用，它将使用交互式身份验证。 skip_create_image (bool) - 跳过创建镜像。在构建测试阶段设置为 true 很有帮助。默认为 false。 共享镜像库 shared_image_gallery_destination 块可用于将新镜像版本发布到现有共享镜像库。 subscription（string）- 使用的订阅 resource_group (string) - 使用的资源组 gallery_name（string）- 使用的镜像库名称 image_name (string) - 镜像名称 image_version（string）- 镜像版本 replication_regions ([]string) - 要复制到的区域 storage_account_type（string）- 为共享镜像库镜像版本指定存储帐户类型。默认为 Standard_LRS。可接受的值为 Standard_LRS``、Standard_ZRS 和 Premium_LRS。 构建期共享信息变量 本构建器会生成一些可以通过 JSON 模板引擎的构建功能和 HCL2 的上下文变量与配置器和后处理器共享的数据。 构建器可用的生成变量是： SourceImageName - 部署中使用的源镜像的全名。使用共享镜像时，生成的名称将指向用于创建所述版本的实际源镜像。 HCL 样例： // When accessing one of these variables from inside the builder, you need to // use the golang templating syntax. This is due to an architectural quirk that // won't be easily resolvable until legacy json templates are deprecated: source \"azure-arm\" \"basic-example\" { os_type = \"Linux\" image_publisher = \"Canonical\" image_offer = \"UbuntuServer\" image_sku = \"14.04.4-LTS\" } // when accessing one of the variables from a provisioner or post-processor, use // hcl-syntax post-processor \"manifest\" { output = \"manifest.json\" strip_path = true custom_data = { source_image_name = \"${build.SourceImageName}\" } } JSON 样例： \"post-processors\": [ { \"type\": \"manifest\", \"output\": \"manifest.json\", \"strip_path\": true, \"custom_data\": { \"source_image_name\": \"{{ build `SourceImageName` }}\" } } ] 通信器配置 除了构建器选项之外，还可以定义一个通信器： communicator (string) - Packer 目前支持三种通信器： none - 不使用通信器。如果设置了此项，大多数配置器也无法使用。 ssh - 将建立到机器的 SSH 连接。通常这是默认值。 winrm - 将建立 WinRM 连接。 除了上述三种之外，一些构建器还可以使用自定义通信器。例如，Docker 构建器有一个 docker 通信器，它使用 docker exec 和 docker cp 来执行脚本和复制文件。 pause_before_connecting (duration string | ex: \"1h5m2s\") - 我们建议您将 SSH 或 WinRM 作为访客引导程序脚本的最后一步，但有时您可能会遇到并行竞争场景，您需要 Packer 在尝试连接之前等待你的虚拟机系统就绪。 如果您遇到这种情况，您可以使用模板选项 pause_before_connecting。默认情况下，没有暂停。例如，如果您将 pause_before_connecting 设置为 10m，Packer 将检查它是否可以正常连接。但是一旦连接尝试成功，它将断开连接，然后等待 10 分钟，然后连接到虚拟机并开始配置。 ssh_host (string) - SSH 到的地址。这通常由构建器自动配置。 ssh_port (int) - 连接到 SSH 的端口。默认为 22。 ssh_username (string) - 用于连接 SSH 的用户名。如果使用 SSH，则必填。 ssh_password（string）- 用于通过 SSH 进行身份验证的明文密码。 ssh_ciphers ([]string) - 这会覆盖 Golang 默认支持的 Cipher。默认值为 [ \"aes128-gcm@openssh.com\", \"chacha20-poly1305@openssh.com\", \"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\", ] 密码的有效选项包括：“aes128-ctr”、“aes192-ctr”、“aes256-ctr”、“aes128-gcm@openssh.com”、“chacha20-poly1305@openssh.com”、“arcfour256”、“arcfour128” \", \"arcfour\", \"aes128-cbc\", \"3des-cbc\", ssh_clear_authorized_keys (bool) - 如果为 true，Packer 将尝试从 ~/.ssh/authorized_keys 和 /root/.ssh/authorized_keys 中删除其临时密钥。这主要是一个装饰性的选项，因为无论是否设置为 true，Packer 都会从主机系统中删除临时私钥（除非用户设置了 -debug 标志）。默认为 false；目前仅适用于安装了 sed 的系统。 ssh_key_exchange_algorithms ([]string) - 如果设置，Packer 将覆盖 Golang 默认支持的密钥交换 (kex) 算法的值。可接受的值包括：\"curve25519-sha256@libssh.org\", \"ecdh-sha2-nistp256\", \"ecdh-sha2-nistp384\", \"ecdh-sha2-nistp521\", \"diffie-hellman-group14-sha1\", 以及 \"diffie-hellman-group1-sha1\"。 ssh_certificate_file（string）- 用于通过 SSH 进行身份验证的用户证书的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_pty (bool) - 如果为 true，将为 SSH 连接请求 PTY。这默认为 false。 ssh_timeout (duration string | ex: \"1h5m2s\") - 等待 SSH 可用的时间。 Packer 使用它来确定机器何时启动，因此这通常很长。示例值：10m。默认为 5m，除非设置了 ssh_handshake_attempts。 ssh_disable_agent_forwarding (bool) - 如果为 true，SSH 代理转发将被禁用。默认为 false。 ssh_handshake_attempts (int) - 一旦可以连接，尝试使用 SSH 的握手次数。默认为 10，除非设置了 ssh_timeout。 ssh_bastion_host（string）- 用于实际 SSH 连接的堡垒主机。 ssh_bastion_port (int) - 堡垒主机的端口。默认为 22。 ssh_bastion_agent_auth (bool) - 如果为 true，则将使用本地 SSH 代理对堡垒主机进行身份验证。默认为 false。 ssh_bastion_username（string）- 连接堡垒主机的用户名。 ssh_bastion_password（string）- 用于向堡垒主机进行身份验证的密码。 ssh_bastion_interactive (bool) - 如果为 true，则将使用键盘交互方式与堡垒主机进行身份验证。 ssh_bastion_private_key_file（string）- 用于与堡垒主机进行身份验证的 PEM 编码私钥文件的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_bastion_certificate_file（string）- 用于与堡垒主机进行身份验证的用户证书的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 ssh_file_transfer_method (string) - scp 或 sftp - 如何传输文件、scp（默认）或 sftp。 注意：使用带有 Win32-OpenSSH v9.1.0.0p1-Beta 的 Windows 的用户，scp（用于复制数据的默认协议）返回非零错误代码，因为无法设置 MOTW，这会导致所有文件传输失败。作为解决方法，您可以使用 SFTP 替代传输协议： ssh_file_transfer_protocol = \"sftp\"。 ssh_proxy_host (string) - 用于 SSH 连接的 SOCKS 代理主机 ssh_proxy_port (int) - SOCKS 代理的端口。默认为 1080。 ssh_proxy_username（string）- 用于使用代理服务器进行身份验证的可选用户名。 ssh_proxy_password（string）- 用于向代理服务器进行身份验证的可选密码。 ssh_keep_alive_interval (duration string | ex: \"1h5m2s\") - 向服务器发送 \"keep alive\" 消息的频率。设置为负值 (-1s) 以禁用。示例值：10s。默认为 5s。 ssh_read_write_timeout (duration string | ex: \"1h5m2s\") - 等待远程命令结束的时间。该参数在某些时候可能很有用，例如，如果 Packer 程序在服务器重启后挂起在连接上。示例：5m。默认情况下禁用。 ssh_remote_tunnels ([]string) - ssh_local_tunnels ([]string) - ssh_private_key_file（string）- 用于通过 SSH 进行身份验证的 PEM 编码私钥文件的路径。 ~ 可以在路径中使用，将扩展到当前用户的主目录。 基础样例 这里有一份基础样例，HCL 版本： source \"azure-arm\" \"basic-example\" { client_id = \"fe354398-d7sf-4dc9-87fd-c432cd8a7e09\" client_secret = \"keepitsecret&#*$\" resource_group_name = \"packerdemo\" storage_account = \"virtualmachines\" subscription_id = \"44cae533-4247-4093-42cf-897ded6e7823\" tenant_id = \"de39842a-caba-497e-a798-7896aea43218\" capture_container_name = \"images\" capture_name_prefix = \"packer\" os_type = \"Linux\" image_publisher = \"Canonical\" image_offer = \"UbuntuServer\" image_sku = \"14.04.4-LTS\" azure_tags = { dept = \"engineering\" } location = \"West US\" vm_size = \"Standard_A2\" } build { sources = [\"sources.azure-arm.basic-example\"] } JSON 版本： { \"type\": \"azure-arm\", \"client_id\": \"fe354398-d7sf-4dc9-87fd-c432cd8a7e09\", \"client_secret\": \"keepitsecret&#*$\", \"resource_group_name\": \"packerdemo\", \"storage_account\": \"virtualmachines\", \"subscription_id\": \"44cae533-4247-4093-42cf-897ded6e7823\", \"tenant_id\": \"de39842a-caba-497e-a798-7896aea43218\", \"capture_container_name\": \"images\", \"capture_name_prefix\": \"packer\", \"os_type\": \"Linux\", \"image_publisher\": \"Canonical\", \"image_offer\": \"UbuntuServer\", \"image_sku\": \"14.04.4-LTS\", \"azure_tags\": { \"dept\": \"engineering\" }, \"location\": \"West US\", \"vm_size\": \"Standard_A2\" } 清理配置(Deprovision) Azure 虚拟机在每次构建结束时都应该执行清理配置。对于 Windows，这意味着执行 sysprep，而对于 Linux，这意味着执行 waagent 清理配置流程。 请参阅 Azure 示例文件夹以获取显示清理配置过程的完整示例。 Windows 以下代码片段显示了如何对 Windows 虚拟机运行 sysprep。清理配置应该是构建执行的最后一个操作。下面的代码将等待 sysprep 将镜像状态写入注册表，然后退出。如果你想等待不同的状态，这里记录了可用的状态。 HCL： provisioner \"powershell\" { inline = [ \" # NOTE: the following *3* lines are only needed if the you have installed the Guest Agent.\", \" while ((Get-Service RdAgent).Status -ne 'Running') { Start-Sleep -s 5 }\", \" while ((Get-Service WindowsAzureTelemetryService).Status -ne 'Running') { Start-Sleep -s 5 }\", \" while ((Get-Service WindowsAzureGuestAgent).Status -ne 'Running') { Start-Sleep -s 5 }\", \"& $env:SystemRoot\\\\System32\\\\Sysprep\\\\Sysprep.exe /oobe /generalize /quiet /quit /mode:vm\", \"while($true) { $imageState = Get-ItemProperty HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Setup\\\\State | Select ImageState; if($imageState.ImageState -ne 'IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE') { Write-Output $imageState.ImageState; Start-Sleep -s 10 } else { break } }\" ] } JSON： { \"provisioners\": [ { \"type\": \"powershell\", \"inline\": [ \" # NOTE: the following *3* lines are only needed if the you have installed the Guest Agent.\", \" while ((Get-Service RdAgent).Status -ne 'Running') { Start-Sleep -s 5 }\", \" while ((Get-Service WindowsAzureTelemetryService).Status -ne 'Running') { Start-Sleep -s 5 }\", \" while ((Get-Service WindowsAzureGuestAgent).Status -ne 'Running') { Start-Sleep -s 5 }\", \"& $env:SystemRoot\\\\System32\\\\Sysprep\\\\Sysprep.exe /oobe /generalize /quiet /quit /mode:vm\", \"while($true) { $imageState = Get-ItemProperty HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Setup\\\\State | Select ImageState; if($imageState.ImageState -ne 'IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE') { Write-Output $imageState.ImageState; Start-Sleep -s 10 } else { break } }\" ] } ] } Windows Guest Agent 参与 Sysprep 进程。代理必须先完成安装，然后才能对虚拟机运行 sysprep。为确保该前置条件，所有代理服务都必须在执行 sysprep.exe 之前运行。上面的 JSON 片段显示了一种在 PowerShell 配置器中执行此操作的方法。仅当 VM 配置为安装代理时才需要此代码段，这是默认设置。要了解有关禁用 Windows 来宾代理的更多信息，请参阅安装虚拟机代理。 请注意，如果配置不正确，sysprep 可能会陷入无限循环 —— 例如，如果它正在等待您从未执行过的重启。 Linux 以下配置代码片段显示了如何清理配置 Linux VM。清理配置应该是构建执行的最后一个操作。 HCL： provisioner \"shell\" { execute_command = \"chmod +x {{ .Path }}; {{ .Vars }} sudo -E sh '{{ .Path }}'\" inline = [ \"/usr/sbin/waagent -force -deprovision+user && export HISTSIZE=0 && sync\" ] inline_shebang = \"/bin/sh -x\" } JSON： { \"provisioners\": [ { \"execute_command\": \"chmod +x {{ .Path }}; {{ .Vars }} sudo -E sh '{{ .Path }}'\", \"inline\": [ \"/usr/sbin/waagent -force -deprovision+user && export HISTSIZE=0 && sync\" ], \"inline_shebang\": \"/bin/sh -x\", \"type\": \"shell\" } ] } 要了解有关 Linux 清理配置过程的更多信息，请参阅 WALinuxAgent 的说明。 skip_clean 有客户报告了导致构建器挂起的清理配置的问题，错误消息类似于以下内容： Build 'azure-arm' errored: Retryable error: Error removing temporary script at /tmp/script_9899.sh: ssh: handshake failed: EOF 一种解决方案是在配置器中将 skip_clean 设置为 true。这可以防止 Packer 在构建期间清理上传到虚拟机的所有帮助脚本。 默认值 Azure 构建器尝试选择默认值以使构建刚好可以工作。用户可以将这些值更改为更合适的值。 默认用户名是 Packer，而不是其他构建器中的 root。 Azure 上的大多数发行版不允许使用 root 通过 SSH 连接到虚拟机，因此需要非 root 默认用户。设置 ssh_username 参数以覆盖默认值。 默认的虚拟机规格为 Standard_A1。设置 vm_size 参数以覆盖默认值。 默认镜像版本是 latest。设置 image_version 参数以覆盖默认值。 默认情况下，一个临时的资源组将作为构建的一部分被创建和销毁。如果您没有这样做的权限，请使用 build_resource_group_name 指定一个现有资源组来运行构建。 实现 警告！本节讨论的是一些有关实现细节的深度内容。如果只是使用 Azure 构建器是不需要阅读本节内容的。 Azure 构建器使用 ARM Template 来部署资源。ARM 模板允许您声明所需的资源，无需描述如何实现。 Azure 构建器的工作的前提假设是它创建了执行构建所需的一切。构建完成后，它会简单地删除资源组以清理所有运行时资源。资源组使用 packer-Resource-Group- 的形式命名。值 是在每次调用 packer 时生成的随机值。 值在命名资源时尽可能重复使用，因此用户可以在他们的订阅中看到这些这些临时资源时更好地进行识别和分类。 VHD 是在保存用户指定的存储帐户内的，运行时不会随机创建存储账户。保存虚拟机时，生成的 VHD 将存储在与源 VHD 相同的存储帐户中。 Packer 创建的 VHD 必须在构建完成后保留，这就是由用户设置存储账户的原因。 构建的基本步骤是： 创建资源组。 验证并部署虚拟机模板。 运行用户定义的配置器；通常是 shell 命令。 关闭并保存虚拟机。 删除资源组。 删除临时虚拟机的操作系统磁盘。 用于构建的模板当前已在 Packer 代码中定义。对于 Linux、Windows 和 KeyVault 都有对应的模板。模板本身是用名称、密码、SSH 密钥、证书等的占位符模板化的。 什么是随机化 Azure 生成器在运行时创建以下随机值。 管理员密码：使用密码字母表的随机 32 个字符值。 证书：用于保护 WinRM 通信的 2,048 位证书。证书有效期为 24 小时，大致从调用时间开始。 证书密码：一个由 32 个密码字母表中字符组成的随机值，使用用于保护证书私钥。 计算名称：一个随机的 15 个字符的名称，以 pkrvm 为前缀；虚拟机的名称。 部署名称：一个随机的 15 个字符的名称，以 pkfdp 为前缀；部署的名称。 KeyVault 名称：一个随机的 15 个字符的名称，前缀为 pkrkv。 NIC 名称：一个随机的 15 个字符的名称，以 pkrni 为前缀。 公共 IP 名称：一个随机的 15 个字符的名称，前缀为 pkrip。 操作系统磁盘名称：一个随机的 15 个字符的名称，以 pkros 为前缀。 数据盘名称：一个随机的 15 个字符的名称，以 pkrdd 为前缀。 资源组名称：一个随机的 33 个字符的名称，前缀为 packer-Resource-Group-。 子网名称：一个随机的 15 个字符的名称，以 pkrsn 为前缀。 SSH 密钥对：2,048 位非对称密钥对；可以被用户改写。 虚拟网络名称：一个随机的 15 个字符的名称，以 pkrvn 为前缀。 用于随机值的默认字母表是 0123456789bcdfghjklmnpqrstvwxyz。减少了字母表（没有元音字母）以防止与 Azure 规范控制发生冲突。 用于随机值的密码字母表是 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ。 弃用警告 当您运行 Azure 构建器时，您可能会看到一个看起来很可怕的弃用警告： ==> azure-arm: Warning: You are using Azure Packer Builder to create VHDs which is being deprecated, consider using Managed Images. Learn more http://aka.ms/packermanagedimage 不要慌。您的构建不会在短时间内停止工作。 从长远来看，Azure 希望每个人都转向使用托管镜像和托管磁盘，因为它们隐藏了存储帐户性能方面的复杂性。托管磁盘可以导出到 VHD。如果弃用该方法，将由帮助维护 Packer 的 Microsoft 团队以对用户透明的过程来完成。 将来，Packer 可能会移除 VHD 支持，但会添加一个可以自动导出到存储帐户的后处理器。 Windows Windows 实现与 Linux 构建非常相似，不同之处在于它部署了一个模板来配置 KeyVault。 Packer 使用 WinRM 协议与 Windows VM 通信。 Azure 上的 Windows VM 默认为 WinRM 使用基于密码和证书的身份验证。密码很容易通过 VM ARM 模板设置，但证书需要一个存储介质。 Azure 的证书存储介质是 KeyVault。证书将上传到与虚拟机在同一资源组中预先配置好的的新 KeyVault 内。部署 Windows 虚拟机时，它会链接到 KeyVault 中的证书，Azure 将确保证书作为部署的一部分注入。 Windows 构建的基本步骤是： 创建资源组。 验证并部署 KeyVault 模板。 验证并部署 VM 模板。 执行规定 - 由用户定义；通常是 shell 命令。 关闭并捕获 VM。 删除资源组。 删除临时 VM 的操作系统磁盘。 Windows 构建需要两个模板和两个部署。不幸的是，KeyVault 和 VM 不能同时部署，因此需要两个模板和部署。部署 KeyVault 模板所需的时间极少，因此总体影响很小。 有关更多示例，请参阅 Packer 项目中的示例文件夹。 "},"7.builders/5.alicloud-ecs.html":{"url":"7.builders/5.alicloud-ecs.html","title":"Alicloud","keywords":"","body":"阿里云镜像构建器 原文 类型：alicloud-ecs Artifact BuilderId：alibaba.alicloud Packer 的 alicloud-ecs 构建器插件提供了基于现有基础镜像构建自定义镜像的能力。 配置参数 以下配置选项可用于构建阿里云镜像。除了此处列出的选项之外，还可以为此构建器配置通信器。 必须 access_key (string) - 除非设置了 profile，否则必须设置阿里云访问密钥，但也可以通过 ALICLOUD_ACCESS_KEY 环境变量来配置。 secret_key (string) - 除非设置了 profile，否则必须设置阿里云机密密钥，但也可以通过 ALICLOUD_SECRET_KEY 环境变量来配置。 region (string) - 除非设置了 profile，否则必须设置阿里云区域，但也可以通过 ALICLOUD_REGION 环境变量来配置。 ram_role_name (string) - 除非设置了 profile，否则必须为 EcsRamRole 模式设置阿里云 RamRole。 ram_role_arn (string) - 除非设置了 profile，否则必须为 RamRoleArn 模式设置阿里云 RamRoleArn。 ram_session_name (string) - 除非设置了 profile，否则必须为 RamRoleArn 模式设置阿里云 RamSessionName。 instance_type (string) - 实例的类型。有关可选值，请参阅实例类型表。您也可以调用查询实例类型表接口获取最新的实例类型表。 source_image (string) - 这是您要创建自定义镜像的基础镜像 ID。 image_family (string) - 镜像系列的名称。客户可以设置该参数，从指定的镜像家族中选择最新可用的自定义镜像来创建实例。 image_name (string) - 用户自定义图片的名称，[2, 128]个英文或中文字符。必须以大小写字母或汉字开头，可以包含数字、_ 或 -。名称不能以 http:// 或 https:// 开头。 可选 skip_region_validation (bool) - 如果设置为 true，则可以跳过区域验证，默认值为 false。 skip_image_validation (bool) - 如果设置为 true，则可以跳过镜像验证，默认值为 false。 profile (string) - 除非设置了 access_key，否则必须设置阿里云配置文件；也可以通过 ALICLOUD_PROFILE 环境变量来设置。 shared_credentials_file (string) - 阿里云共享凭证文件路径。如果该文件存在，将从该文件中读取访问密钥和机密密钥。 security_token (string) - STS 访问令牌，可以通过模板设置或配置环境变量来配置，例如 export SECURITY_TOKEN=value。 custom_endpoint_ecs (string) - 如果您使用的 API 与 aliyun ECS 公有云版本兼容，则此选项可以用来指定自定义 API 端点。 system_disk_mapping (AlicloudDiskDevice) - 系统盘的配置。有关选项的更多信息，请参阅磁盘设备配置部分。使用示例： \"builders\": [{ \"type\":\"alicloud-ecs\", \"system_disk_mapping\": { \"disk_size\": 50, \"disk_name\": \"mydisk\" }, ... } image_disk_mappings ([]AlicloudDiskDevice) - 添加一个或多个数据磁盘到镜像中。有关选项的更多信息，请参阅磁盘设备配置部分。使用示例： \"builders\": [{ \"type\":\"alicloud-ecs\", \"image_disk_mappings\": [ { \"disk_snapshot_id\": \"someid\", \"disk_device\": \"dev/xvdb\" } ], ... } associate_public_ip_address (bool) - 是否关联公网 IP 地址 zone_id（string）- 磁盘所属区域的 ID。 io_optimized (boolean) - ECS 实例是否开启 I/O 优化。如果未设置此选项，则该值将由产品 API 根据使用的 instance_type 确定。 description（string）- 描述 force_stop_instance (bool) - 是否在设备重启时使用强制关机。默认值为 false。 如果设置为 false，系统正常关闭；如果设置为 true，系统将在重启时被强制关闭。 disable_stop_instance (bool) - 如果此选项设置为 true，Packer 将不会为您停止实例，您需要确保实例将被最后的配置命令停止。否则，Packer 将在等待实例停止时超时。该选项是为一些您希望自行停止实例的特定场景提供的。例如，Sysprep 可能会在一个窗口期中中关闭实例。默认值为 false。 ram_role_name (string) - 启动实例时应用的 Ram 角色。 run_tags (map[string]string) - 为创建镜像而启动的实例上设置的标签。 security_group_id (string) - 新创建的实例所属的安全组的 ID。同一个安全组内的实例之间允许互访。如果不指定，新创建的实例将被添加到默认的安全组中。如果默认组不存在，或者其中的实例数量达到最大限制，将自动创建一个新的安全组。 security_group_name（string）- 安全组名称。默认值为空白。 [2, 128] 英文或汉字，必须以大小写字母或汉字开头。可以包含数字、.、_ 或 -。名称不能以 http:// 或 https:// 开头。 security_enhancement_strategy（string）- 指定是否启用安全强化。有效值： Active：启用安全强化。此值仅适用于公共镜像。 Deactive：不启用安全加固。此值适用于所有镜像类型。 user_data (string) - 启动实例时要应用的 User Data。请注意，由于模板是 JSON，因此您需要注意转义字符。相反，使用 user_data_file 通常更方便。 Packer 不会在关闭实例之前自动等待用户脚本完成，这必须在配置器中处理。 user_data_file (string) - 启动实例时将用于存储 User Data 数据的文件路径。 vpc_id (string) - 系统分配的 VPC ID。 vpc_name（string）- VPC 名称。默认值为空白。 [2, 128] 英文或汉字，必须以大小写字母或汉字开头。可以包含数字、_ 和 -。名称将出现在控制台上。不能以 http:// 或 https:// 开头。 vpc_cidr_block（string）- 可选项：192.168.0.0/16 和 172.16.0.0/16。未指定时，默认值为 172.16.0.0/16。 vswitch_id (string) - 要使用的 VSwitch 的 ID。 vswitch_name (string) - 要使用的 VSwitch 的名称。 instance_name (string) - 实例显示名称，为 [2, 128] 个中英文字符的字符串。它必须以大写/小写字母或汉字开头，可以包含数字、.、_ 或 -。实例名称显示在阿里云控制台上。如果不指定该参数，则默认为实例的InstanceId。它不能以 http:// 或 https:// 开头。 internet_charge_type (string) - 公网收费类型，可以是 PayByTraffic 或 PayByBandwidth。如果不指定该参数，默认值为 PayByBandwidth。对于中国以外的地区，目前只支持 PayByTraffic，需要手动设置。 internet_max_bandwidth_out (int) - 公网的最大传出带宽，以 Mbps（每秒兆位）为单位。取值范围： PayByBandwidth：[0, 100]。如果未指定此参数，API 会自动将其设置为 0 Mbps。 PayByTraffic：[1, 100]。如果未指定此参数，则返回错误。 wait_snapshot_ready_timeout (int) - 创建快照超时。如果此选项未设置或设置为 0，则默认超时为 3600 秒。对于那些包含大量数据的磁盘，可能需要更高的超时值。 wait_copying_image_ready_timeout (int) - 复制镜像超时。如果此选项未设置或设置为 0，则默认超时为 3600 秒。 ssh_private_ip (bool) - 如果该值为 true，Packer 将通过私有 ip 连接到创建的 ECS，而不是分配公有 ip 或 EIP。默认值为 false。 skip_create_image (bool) - 如果为 true，Packer 将不会创建镜像。默认为 false。 image_version (string) - 镜像的版本号，长度限制为 1 到 40 个英文字符。 image_description (string) - 镜像的描述，长度限制为 0 到 256 个字符。将其留空表示为默认值 null。它不能以 http:// 或 https:// 开头。 resource_group_id（string）- 要将自定义镜像分配到的资源组的 ID。如果不指定此参数，则将镜像分配给默认资源组。 image_share_account ([]string) - 待创建的镜像将要共享的阿里云账号ID。账户数为 1 到 10。如果账户数大于 10，则忽略该参数。 image_unshare_account([]string) - (译者表示懵逼，盲猜是不共享的账号) image_copy_regions ([]string) - 复制到目标 region 的 Id 列表。 image_copy_names ([]string) - 目标镜像的名称，[2, 128]个英文或中文字符。必须以大小写字母或汉字开头，可以包含数字、_ 或 -。它不能以 http:// 或 https:// 开头。 image_encrypted (boolean) - 是否加密目标镜像，包括那些通过设置 image_copy_regions 时复制的镜像。如果此选项设置为 true，则将从主要区域中的配置实例创建临时镜像，并在同一区域中生成加密副本。默认情况下，Packer 会继承源镜像中的加密设置。 image_force_delete (bool) - 如果设置为 true，当目标镜像名称（包括复制的镜像）与现有镜像重复时，它将删除现有镜像，然后创建目标镜像，否则，创建将失败。默认值为 false。检查目标镜像名称使用的是 image_name 和 image_copy_names 选项。如果在构建命令中提供了 -force 选项，则该选项可以省略并取为 true。 image_force_delete_snapshots (bool) - 如果设置为 true，当删除重复的现有镜像时，这些镜像的源快照也将被删除。如果在构建命令中提供了 -force 选项，则该选项可以省略并取为 true。 image_force_delete_instances (bool) - 阿里云镜像强制删除实例 image_ignore_data_disks (bool) - 如果设置为 true，则创建的镜像将不包含任何数据磁盘快照。此选项适用于那些不关心加载到实例上的默认数据磁盘的情况。默认值为 false。 skip_region_validation (bool) - 如果设置为 true，则可以跳过区域验证，默认值为 false。 tags (map[string]string) - 应用于目标镜像和相关快照的标签。 tag ([]{key string, value string}) - 与 tags 相同，但定义为包含键和值字段的单个可重复块。在 HCL2 模式下，dynamic 块 将允许您以编程方式创建这些内容。 temporary_key_pair_type（string）- dsa | ECDS | ed25519 | rsa（默认）指定要创建的密钥类型。 temporary_key_pair_bits (int) - 指定要创建的密钥的位数。对于 RSA 密钥，最小为 1024 位，默认为 4096 位。通常，3072 位被认为是足够的。 DSA 密钥必须恰好是 FIPS 186-2 指定的 1024 位。对于 ECDSA 密钥，通过从三种椭圆曲线大小中选择一种来确定密钥长度：256、384 或 521 位。尝试使用这三个值以外的 ECDSA 密钥长度将触发失败。 Ed25519 密钥具有固定长度，位将被忽略。 ssh_keypair_name（string）- 如果设置，将是用于机器 SSH 的密钥。该密钥必须与加载到远程服务器中的密钥对名称相匹配。默认情况下不设置，除非使用 ssh_password，否则 Packer 将生成一个临时密钥对。使用 ssh_keypair_name 时必须指定 ssh_private_key_file 或 ssh_agent_auth。 ssh_private_key_file（string）- 用于通过 SSH 进行身份验证的 PEM 编码私钥文件的路径。 可以在路径中使用 ~，将展开为当前用户的 HOME 目录。 ssh_agent_auth (bool) - 如果为 true，本地 SSH Agent 将用于验证与源实例的连接。不会创建临时密钥对，ssh_password 和 ssh_private_key_file 的值将被忽略。必须设置环境变量 SSH_AUTH_SOCK 才能使此选项正常工作。 阿里云 RAM 权限 最后插件需要获得一组阿里云RAM权限才能调用阿里云API。 以下策略文档提供了阿里云插件运行所需的最小设置权限： { \"Version\": \"1\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"ecs:AttachKeyPair\", \"ecs:CreateKeyPair\", \"ecs:DeleteKeyPairs\", \"ecs:DetachKeyPair\", \"ecs:DescribeKeyPairs\", \"ecs:DescribeDisks\", \"ecs:ImportKeyPair\", \"ecs:CreateSecurityGroup\", \"ecs:AuthorizeSecurityGroup\", \"ecs:AuthorizeSecurityGroupEgress\", \"ecs:DescribeSecurityGroups\", \"ecs:DeleteSecurityGroup\", \"ecs:CopyImage\", \"ecs:CancelCopyImage\", \"ecs:CreateImage\", \"ecs:DescribeImages\", \"ecs:DescribeImageFromFamily\", \"ecs:DeleteImage\", \"ecs:ModifyImageAttribute\", \"ecs:DescribeImageSharePermission\", \"ecs:ModifyImageSharePermission\", \"ecs:DescribeInstances\", \"ecs:StartInstance\", \"ecs:StopInstance\", \"ecs:CreateInstance\", \"ecs:DeleteInstance\", \"ecs:RunInstances\", \"ecs:RebootInstance\", \"ecs:RenewInstance\", \"ecs:CreateSnapshot\", \"ecs:DeleteSnapshot\", \"ecs:DescribeSnapshots\", \"ecs:TagResources\", \"ecs:UntagResources\", \"ecs:AllocatePublicIpAddress\", \"ecs:AddTags\", \"vpc:DescribeVpcs\", \"vpc:CreateVpc\", \"vpc:DeleteVpc\", \"vpc:DescribeVSwitches\", \"vpc:CreateVSwitch\", \"vpc:DeleteVSwitch\", \"vpc:AllocateEipAddress\", \"vpc:AssociateEipAddress\", \"vpc:UnassociateEipAddress\", \"vpc:ReleaseEipAddress\", \"vpc:DescribeEipAddresses\" ], \"Resource\": [ \"*\" ] } ] } 磁盘设备配置 disk_name (string) - 磁盘名称的值默认为空白。 [2, 128] 英文或汉字，必须以大小写字母或汉字开头。可以包含数字、.、_ 和 -。磁盘名称将出现在控制台上。它不能以 http:// 或 https:// 开头。 disk_category (string) - 系统磁盘的类别。可选值是： - cloud - general cloud disk - cloud_efficiency - efficiency cloud disk - cloud_ssd - cloud SSD - cloud_essd - cloud ESSD disk_size (int) - 系统磁盘的大小，以 GiB 为单位。取值范围：[20, 500]。指定的值必须等于或大于 max{20, ImageSize}。默认值：最大值{40, ImageSize}。 disk_snapshot_id (string) - 用于创建数据盘的快照 ID。指定此参数后，disk_size 将被忽略。创建的磁盘实际大小为指定快照的大小。该字段仅用于 ECSImagesDiskMappings 选项，不用于 ECSSystemDiskMapping 选项。 disk_description (string) - 磁盘的描述，默认为空白。 [2, 256] 个字符。磁盘描述将出现在控制台上。它不能以 http:// 或 https:// 开头。 disk_delete_with_instance (bool) - 磁盘是否随实例一起释放： disk_device (string) - 相关实例的设备信息：例如 /dev/xvdb。除非状态为 In_use，否则为 null。 disk_encrypted (boolean) - 是否加密数据盘。如果该选项设置为 true，数据盘将被加密，目标镜像中对应的快照也会被加密。默认情况下，如果这是一个额外的数据盘，Packer 不会加密数据盘。否则，Packer 会将继承源映像中的加密设置。详情请参考 ECS 磁盘加密介绍。 基础用法 variable \"access_key\" { type = string } variable \"secret_key\" { type = string } source \"alicloud-ecs\" \"basic-example\" { access_key = var.access_key secret_key = var.secret_key region = \"cn-beijing\" image_name = \"packer_test2\" source_image = \"centos_7_04_64_20G_alibase_201701015.vhd\" ssh_username = \"root\" instance_type = \"ecs.n1.tiny\" io_optimized = true internet_charge_type = \"PayByTraffic\" image_force_delete = true run_tags = { \"Built by\" = \"Packer\" \"Managed by\" = \"Packer\" } } build { sources = [\"sources.alicloud-ecs.basic-example\"] provisioner \"shell\" { inline = [ \"sleep 30\", \"yum install redis.x86_64 -y\", ] } } 请注意：镜像可能会在一段时间后被弃用；运行 aliyun ecs DescribeImages 查找一个存在的镜像。 请注意：由于 WinRM 在系统映像中默认关闭。如果您计划使用 Windows 作为基础镜像，则需要通过 userdata 启用它才能连接到实例，查看 alicloud_windows.json 和 winrm_enable_userdata.ps1 了解详情。 更多示例，请参见 Packer 项目中的 examples/alicloud 文件夹。 "},"8.data_sources/overview.html":{"url":"8.data_sources/overview.html","title":"数据源","keywords":"","body":"数据源 原文 数据源使得 Packer 可以获取数据以在模板中使用，包括那些在 Packer 外部定义的信息。 请参阅 data块文档 以了解有关使用数据源的更多信息。该文档还包含有关每种类型的数据源的详细信息。 请注意：数据源是 Packer v1.7.0（及更新版本）中包含的 HCL2 模板独有的功能。 "},"8.data_sources/1.http.html":{"url":"8.data_sources/1.http.html","title":"HTTP","keywords":"","body":"HTTP 数据源 原文 类型：http http 数据源向给定的 URL 发出 HTTP GET 请求并输出响应的信息。 基础用法 data \"http\" \"example\" { url = \"https://checkpoint-api.hashicorp.com/v1/check/terraform\" # Optional request headers request_headers = { Accept = \"application/json\" } } 配置参数 有两类配置参数：必须的和可选的。在每个类别中，可用选项按英文字母顺序排列和描述。 必须 url (string) - ​​请求数据的 URL。此 URL 必须返回 200 OK 状态码以及 text/* 或 application/json 作为 Content-Type。 可选 request_headers (map[string]string) - 表示请求中包含的额外 HTTP 标头的字符串映射。 数据源输出 该数据源的输出如下： url (string) - 请求数据的 URL。 body (string) - HTTP 响应的原始 body。 request_headers (map[string]string) - 表示响应 HTTP 标头的字符串映射。根据 RFC2616，重复的标头会被连接在一起。 "},"9.provisioners/overview.html":{"url":"9.provisioners/overview.html","title":"配置器","keywords":"","body":"配置器 原文 配置器使用内置和第三方软件在启动后安装和配置机器镜像。配置器使得镜像中的系统做好工作的准备，因此您可能希望将使用配置器完成以下工作： 安装包 修补内核 创建用户 下载应用程序代码 请参阅 provisioner 块文档以了解有关使用配置器的更多信息。 "},"9.provisioners/1.break_point.html":{"url":"9.provisioners/1.break_point.html","title":"断点","keywords":"","body":"断点配置器 原文 类型：breakpoint 断点配置器将暂停构建，直到用户按下 “enter” 以继续运行构建。这旨在用于调试目的，并允许您在配置过程的特定部分停止。 这与 -debug 标志无关，它会在每个步骤和所有配置器之间停止。 基础用法 source \"null\" \"example\" { communicator = \"none\" } build { sources = [\"source.null.example\"] provisioner \"shell-local\" { inline = [\"echo hi\"] } provisioner \"breakpoint\" { disable = false note = \"this is a breakpoint\" } provisioner \"shell-local\" { inline = [\"echo hi 2\"] } } 配置参数 可选 disable (boolean) - 如果为 true，则跳过断点。当您设置了多个断点并想要关闭或打开它们时很有用。默认值：false note (string) - 一个用于解释断点的目的或位置的字符串。例如，您可能会发现对断点进行编号或使用有关断点在构建中出现位置的信息来标记它们很有用 以下是对所有配置器都生效的通用参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 仅在列出名字的构建器上运行配置程序。 override (object) - 修改特定构建器的配置，例如： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } timeout（duration）- 如果配置器完成时间超过 1h10m1s 或 10m，则配置器将超时并失败。 用例 在您希望构建暂停的位置插入此配置器。当您准备好时，您会看到 ui 输出提示您按 “enter” 继续构建。 例如： ==> docker: Pausing at breakpoint provisioner with note \"foo bar baz\". ==> docker: Press enter to continue. 一旦按下回车键，构建将恢复并正常运行，直到它完成或出错。 "},"9.provisioners/2.file.html":{"url":"9.provisioners/2.file.html","title":"文件","keywords":"","body":"文件配置器 原文 类型： file Packer 的文件配置器可以将文件上传到由 Packer 构建的机器上。建议使用文件配置器上传文件，然后使用 shell 配置器将它们移动到正确的位置，设置权限等。 警告：您只能上传文件到配置器使用的用户（通常不是root用户）有权限访问的位置。在 /tmp 中创建文件，并使用 shell 配置器将它们移动到目标位置，是上传文件到 root 所拥有的目录的唯一方法。 文件配置器可以上传单个文件，也可以上传整个目录。 基础样例 JSON： { \"type\": \"file\", \"source\": \"app.tar.gz\", \"destination\": \"/tmp/app.tar.gz\" } HCL： provisioner \"file\" { source = \"app.tar.gz\" destination = \"/tmp/app.tar.gz\" } 配置参数 必填参数： content (string) - 这是要复制到目的地的内容。如果 destination 是一个文件，内容将被写入该文件，如果是目录，则会创建一个名为 pkr-file-content 的文件。建议使用文件作为目标。可以在此处使用 templatefile 函数或任何插值语法。该参数不可与 source 或 sources 一同设置。 source (string) - 要上传到机器的本地文件或目录的路径。路径可以是绝对的或相对的。如果是相对路径，就是相对于 Packer 执行时的工作目录。如果这是一个目录，路径务必以斜杠结尾。下文会详述关于上传目录的内容。除非设置了 sources，否则必须设置该参数。 destination (string) - 文件将被上传到机器上的目标路径。位置必须可写，并且所有父级目录必须已经存在。如果配置器使用的用户（通常不是 root）无法写入此目录，您将收到“Permission Denied”错误。如果源是一个文件，那么将最好也把目标设置为文件，但是如果将目标设置为目录，至少要确保目标路径以斜杠结尾，以便 Packer 知道使用源文件的文件名拼接到目标路径之后。否则可能会导致 Packer 无法上传文件。如果目标文件已经存在，它将被覆盖。 选填参数： sources ([]string) - 要上传的文件夹列表。如果你有多个文件要上传到同一个地方，这可以用来代替 source 选项。请注意，目标必须是带尾部斜杠的目录，sources 中列出的所有文件都将上传到同一目录，并保留其文件名。 direction (string) - 文件传输的方向。默认值为 upload。如果设置为 download，则远程机器中的文件 source 将下载到本地 destination generated (bool) - 仅适用于高级用户。如果为 true，则仅在上传前检查文件是否存在，而不是在构建前验证时检查。这允许用户在上传时即时地创建的文件。该参数默认为 false。我们不建议使用此功能，因为它会导致 Packer 变得依赖于系统状态。我们希望您在 Packer 运行之前生成您的文件，但我们也承认在某些情况下这可能是不可避免的。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用特定配置器的不同设置覆盖配置器，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 上传目录 file 配置器还能够将完整的目录上传到远程机器。上传目录时，您应该了解一些重要事项。 首先，目标目录必须已经存在。如果您需要创建它，请在运行文件配置器之前使用 shell 配置器来创建目录。如果目标目录不存在，文件配置器可能不会报错，同时引发意外的结果。 接下来，source 路径上尾部是否有斜杠将决定目录名称是否将嵌入到目标路径中，或者是否将创建目标。我们举例说明： 如果 source 是 /foo（尾部没有斜杠），目标是 /tmp，那么本地机器上 /foo 的内容将被上传到远程机器上的 /tmp/foo。远程机器上的 foo 目录将由 Packer 创建。 但是，如果源是 /foo/（尾部有斜杠），而目标是 /tmp，那么 /foo 的内容将直接上传到 /tmp。 此行为源自 rsync。请注意，Packer 在实际运行时，不一定会使用 rsync。 上传在 Packer 运行前还不存在的文件 通常来说，作为 source 的本地文件必须在 Packer 运行之前就已存在。这对于捕获拼写错误并确保构建一旦开始就会成功非常有用。但是，这也意味着您不能在构建期间生成文件，然后再使用文件配置器上传它。一个窍门是上传目录而不是文件。该目录仍然必须存在，但其内容一开始可以不存在。您可以在 Packer 运行期间将生成的文件写入该目录，并在稍后上传。 上传符号链接 上传符号链接时的行为取决于通信器。 Docker 通信器将保留符号链接，但所有其他通信器会将本地符号链接视为常规文件。如果您希望在上传时保留符号链接，建议您使用 tar。下面是一个可能的例子： $ ls -l files total 16 drwxr-xr-x 3 mwhooker staff 102 Jan 27 17:10 a lrwxr-xr-x 1 mwhooker staff 1 Jan 27 17:10 b -> a -rw-r--r-- 1 mwhooker staff 0 Jan 27 17:10 file1 lrwxr-xr-x 1 mwhooker staff 5 Jan 27 17:10 file1link -> file1 $ ls -l toupload total 0 -rw-r--r-- 1 mwhooker staff 0 Jan 27 17:10 files.tar Json： { \"provisioners\": [ { \"type\": \"shell-local\", \"command\": \"tar cf toupload/files.tar files\" }, { \"destination\": \"/tmp/\", \"source\": \"./toupload\", \"type\": \"file\" }, { \"inline\": [ \"cd /tmp && tar xf toupload/files.tar\", \"rm toupload/files.tar\" ], \"type\": \"shell\" } ] } HCL2： build { sources = [ \"source.docker.example\" ] provisioner \"shell-local\" { command = \"tar cf toupload/files.tar files\" } provisioner \"file\" { destination = \"/tmp/\" source = \"./toupload\" } provisioner \"shell\" { inline = [ \"cd /tmp && tar xf toupload/files.tar\", \"rm toupload/files.tar\" ] } } 通过 WinRM 传输大文件时速度缓慢的问题 由于我们的 WinRM 传输方式的限制，即使是中等大小的文件，上传和下载可能也需要很长时间。如果您在 Windows 上使用 file 配置器时遇到缓慢问题，建议您设置 SSH 服务并使用 ssh 通信器。如果您只想将文件传输给构建的机器，并且您的构建器支持使用 HTTP，您也可以使用 http_directory 或 http_content 指令。这将使构建机可以通过 HTTP 来访问该目录，并将环境变量 PACKER_HTTP_ADDR 设置为该地址。 "},"9.provisioners/3.powershell.html":{"url":"9.provisioners/3.powershell.html","title":"PowerShell","keywords":"","body":"PowerShell 配置器 原文 类型：powershell Packer 的 PowerShell 配置器在 Windows 机器上运行 PowerShell 脚本。它默认使用的通信器是 WinRM。然而，当与 SSH 通信器结合使用时，配置器可以同样工作（有一些注意事项）。有关详细信息，请参阅下面的部分。 注意：如果可能，尽量始终使用斜杠 / 作为路径分隔符，尤其是在处理相对路径时。反斜杠 \\ 可以用于 Windows，并且是官方的 Windows 路径分隔符，但是当从任何非 Windows 系统构建镜像时，Packer 只会将斜杠 / 视为路径分隔符，并将反斜杠视为纯文本。这可能会导致路径错误。 基础用法 HCL2： provisioner \"powershell\" { inline = [\"dir c:/\"] } Json： { \"type\": \"powershell\", \"inline\": [\"dir c:/\"] } 配置参数 下面列出了可用配置选项的参考。唯一必须的元素是 inline 或 script，此外的其他参数都是可选的。 以下参数必须选一配置： inline（array of string）- 这是一组要执行的命令。这些命令由换行符连接起来并变成一个文件，因此它们都在相同的上下文中执行。这使得您可以在一个命令中更改目录，并在下一个命令中使用目录中的内容，依此类推。内联脚本是在机器内完成简单任务的最简单方法。 script (string) - 要上传到机器并执行的脚本的路径。此路径可以是绝对路径或相对路径。如果是相对路径，就是相对于Packer执行时的工作目录。 scripts（array of string）- 要执行的脚本数组。脚本将按照指定的顺序上传和执行。每个脚本都是独立执行的，因此一个脚本中的变量等状态不会传递到下一个脚本。 选填参数 binary (boolean) - 如果为 true，则指定脚本是二进制文件，因此 Packer 不应将 Windows 行结尾转换为 Unix 行结尾（如果有的话）。默认为 false。 valid_exit_codes（整数列表）- 脚本的有效返回值。默认情况下是 0。 debug_mode - 如果配置该参数，则设置 PowerShell 的 PSDebug 模式以使脚本调试更容易。例如，将值设置为 1 会将下面的命令添加到执行命令中： Set-PSDebug -Trace 1 elevated_execute_command（string）- 用于执行提权脚本的命令。默认情况下，如下所示： powershell -executionpolicy bypass \"& { if (Test-Path variable:global:ProgressPreference){$ProgressPreference='SilentlyContinue'};. {{.Vars}}; &'{{.Path}}'; exit $LastExitCode }\" 由于配置器是一个模板引擎。因此，您可以在此字段中使用用户变量和模板函数。此外，您可以使用两个额外的变量： Path：要运行的脚本的路径 Vars：包含 environment_vars 列表的临时文件的位置（如果已配置）。Path 和 Vars 的值都可以通过分别设置 remote_path 和 remote_env_var_path 的值来手动配置。 如果您使用 SSH 通信器并更改了默认 shell，您可能需要修改 execute_command 以确保该命令有效且正确转义；默认将使用 cmd。 env（map(string)）- 在 execute_command 之前注入的键/值对映射。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。重复的 env 设置会覆盖 environment_vars 中的设置。这不是启用 JSON 模板引擎的函数。 HCL 插值照常工作。 environment_vars（[]string）- 在 execute_command 之前注入的键/值对数组。格式应为key=value。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。 use_pwsh（bool）- 运行 pwsh.exe 而不是 powershell.exe。默认为 false。 该值是一个模板引擎。因此，您可以在此字段中使用用户变量和模板函数。如果您在 AWS、Azure、Google Compute 或 OpenStack 上运行并且想要访问 Packer 用于通过 WinRM 连接到实例的自动生成的密码，您可以使用构建模板引擎通过 { { build `Password` } } 注入密码。在 HCL 模板中，您可以通过访问构建变量来做同样的事情，例如： HCL2： provisioner \"powershell\" { environment_vars = [\"WINRMPASS=${build.Password}\"] inline = [\"Write-Host \\\"Automatically generated aws password is: $Env:WINRMPASS\\\"\"] } Json： { \"type\": \"powershell\", \"environment_vars\": [\"WINRMPASS={ { build `Password` } }\"], \"inline\": [\"Write-Host \\\"Automatically generated aws password is: $Env:WINRMPASS\\\"\"] }, execute_command (string) - 用于执行脚本的命令。默认情况下，如下所示： powershell -executionpolicy bypass \"& { if (Test-Path variable:global:ProgressPreference){$ProgressPreference='SilentlyContinue'};. {{.Vars}}; &'{{.Path}}'; exit $LastExitCode }\" 该值是一个模板引擎。因此，您可以在此字段中使用用户变量和模板函数。此外，您可以使用两个额外的变量： Path：要运行的脚本的路径 Vars：包含 environment_vars 列表的临时文件的位置（如果已配置）。 Path 和 Vars 的值都可以通过分别设置 remote_path 和 remote_env_var_path 的值来手动配置。 如果您使用 SSH 通信器并更改了默认 shell，您可能需要修改 execute_command 以确保该命令有效且正确转义；默认假定您没有将默认 shell 更改为 cmd。 elevated_user 和 elevated_pa​​ssword（string）- 如果指定，PowerShell 脚本将使用给定的 Windows 用户以提权模式运行。 该值是一个模板引擎。因此，您可以在此字段中使用用户变量和模板函数。如果您在 AWS、Azure、Google Compute 或 OpenStack 上运行并且想要访问 Packer 用于通过 WinRM 连接到实例的自动生成的密码，您可以使用构建模板引擎通过 { { build `Password` } } 注入密码。在 HCL 模板中，您可以通过访问构建变量来完成相同的功能，例如： HCL2: provisioner \"powershell\" { elevated_user = \"Administrator\" elevated_password = build.Password } Json： { \"type\": \"powershell\", \"elevated_user\": \"Administrator\", \"elevated_password\": \"{ { build `Password` } }\", ... }, 如果您指定了空的 elevated_pa​​ssword 值，则 PowerShell 脚本将作为服务帐户运行。例如： HCL2： provisioner \"powershell\" { elevated_user = \"SYSTEM\" elevated_password = \"\" } Json： { \"type\": \"powershell\", \"elevated_user\": \"SYSTEM\", \"elevated_password\": \"\", ... }, execution_policy - 要在 Windows 上运行 PowerShell 脚本，Packer 默认将此设置为 \"bypass\" 并包装要运行的命令。将此设置为 \"none\" 将防止包装，允许在 Windows 上看到 Docker 的退出代码。可能的值为 bypass、allsigned、default、remotesigned、restricted、undefined、unrestricted 和 none。 remote_path (string) - PowerShell 脚本将被上传到目标构建机器中的路径。默认为 C:/Windows/Temp/script-UUID.ps1，其中 UUID 替换为动态生成的唯一标识脚本的字符串。 此设置允许用户覆盖默认上传位置。该值必须是可写位置，并且所有父目录必须已经存在。 remote_env_var_path（string）- 通过 PowerShell 脚本中上传所需的环境变量到远程环境中，然后在通过“dot sourcing”脚本执行主命令或脚本。 环境变量脚本将上传到的路径默认为 C:/Windows/Temp/packer-ps-env-vars-UUID.ps1，其中 UUID 被替换为动态生成的唯一标识脚本的字符串。 此设置允许用户改写环境变量脚本上传到的位置。该值必须是可写位置，并且所有父目录必须已经存在。 skip_clean (bool) - 是否在执行配置器后清理脚本。默认为 false。当为 true 时，任何由非提权的 Powershell 配置器创建的脚本都将从远程计算机中删除。无论为 skip_clean 设置的值如何，提权的脚本以及规划的任务将始终被删除。 start_retry_timeout (string) - 尝试启动远程进程的延时。默认情况下，这是 5m 或 5 分钟。此设置的存在是为了处理 SSH 可能重新启动的时间，例如系统重新启动。如果重新启动需要更长的时间，请将此设置为更高的值。 pause_after (string) - 配置 PowerShell 脚本后等待的时间，如果前面的所有步骤都成功了，则暂停。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用特定配置器的不同设置覆盖配置器，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 默认的环境变量 除了能够使用 environment_vars 配置自定义环境变量外，配置器还会自动定义某些常用的环境变量： PACKER_BUILD_NAME 值为 Packer 正在运行的构建的名称。这在 Packer 进行多个构建并且您希望将它们彼此能有所区分时最有用。 PACKER_BUILDER_TYPE 是用于创建运行脚本的机器的构建器类型。如果您只想在使用特定构建器构建的系统上运行脚本的特定部分，这将很有用。 PACKER_HTTP_ADDR 如果使用为文件传输提供 HTTP 服务器的构建器（例如 hyperv、parallels、qemu、virtualbox 和 vmware），这将被设置为 HTTP 服务器地址。您可以在配置器中使用此地址通过 HTTP 下载大文件。如果您在使用默认文件配置器时遇到较慢的速度，这可能很有用。使用 winrm 通信器的 file 配置器可能会遇到这些类型的困难。 将 PowerShell Provisioner 与 SSH Communicator 相结合 先说好消息。如果您使用的是 Microsoft 的 OpenSSH 移植版本，那么配置程序应该会按预期工作 —— 不需要额外的配置工作。 下面是警告。如果您使用的是替代配置，并且您的 SSH 连接使您进入远程主机上的 *nix shell，那么您很可能需要手动设置 execute_command； Packer 使用的默认 execute_command 对您不起作用。配置命令时，您需要确保相应地转义任何可能被远程 shell 错误解释的 $ 符号或其他字符。 以下示例显示了如何重新配置​​标准 execute_command 以在安装了 Cygwin/OpenSSH 的远程系统上工作。 execute_command 对每个 $ 符号反斜杠进行了转义，这样它就不会被远程 Bash shell 解释——Bash 是 Cygwin 环境的默认 shell。 HCL2： provisioner \"powershell\" { execute_command = \"powershell -executionpolicy bypass \\\"& { if (Test-Path variable:global:ProgressPreference){\\\\$ProgressPreference='SilentlyContinue'};. {{.Vars}}; &'{{.Path}}'; exit \\\\$LastExitCode }\\\"\" inline = [ \"Write-Host \\\"Hello from PowerShell\\\"\"] } Json： \"provisioners\": [ { \"type\": \"powershell\", \"execute_command\": \"powershell -executionpolicy bypass \\\"& { if (Test-Path variable:global:ProgressPreference){\\\\$ProgressPreference='SilentlyContinue'};. {{.Vars}}; &'{{.Path}}'; exit \\\\$LastExitCode }\\\"\", \"inline\": [\"Write-Host \\\"Hello from PowerShell\\\"\"] } ] Packer 对 PowerShell 特殊字符的处理 PowerShell 中的转义字符是 backtick（反引号），有时也称为 grave accent（重音符）。何时以及何时不转义 PowerShell 的特殊字符可能最好通过一系列示例来说明。 需要转义的情况 当 PowerShell 特有的转义字符直接出现在 PowerShell 配置器的 inline 命令中，或者当它们直接出现在用户自己的脚本中时，用户需要处理 PowerShell 这些转义字符。请注意，如果 Json 模板中的双引号内出现双引号，则需要添加反斜杠转义才能正确解析。 HCL2： provisioner \"powershell\" { inline = [ \"Write-Host \\\"A literal dollar `$ must be escaped\\\"\", \"Write-Host \\\"A literal backtick `` must be escaped\\\"\", \"Write-Host \\\"Here `\\\"double quotes`\\\" must be escaped\\\"\", \"Write-Host \\\"Here `'single quotes`' don`'t really need to be\\\"\", \"Write-Host \\\"escaped... but it doesn`'t hurt to do so.\\\"\", ] } Json： \"provisioners\": [ { \"type\": \"powershell\", \"inline\": [ \"Write-Host \\\"A literal dollar `$ must be escaped\\\"\", \"Write-Host \\\"A literal backtick `` must be escaped\\\"\", \"Write-Host \\\"Here `\\\"double quotes`\\\" must be escaped\\\"\", \"Write-Host \\\"Here `'single quotes`' don`'t really need to be\\\"\", \"Write-Host \\\"escaped... but it doesn`'t hurt to do so.\\\"\" ] } ] 上面的代码片段应该会在 Packer 控制台上产生以下输出： ==> amazon-ebs: Provisioning with Powershell... ==> amazon-ebs: Provisioning with PowerShell script: /var/folders/15/d0f7gdg13rnd1cxp7tgmr55c0000gn/T/packer-powershell-provisioner508190439 amazon-ebs: A literal dollar $ must be escaped amazon-ebs: A literal backtick ` must be escaped amazon-ebs: Here \"double quotes\" must be escaped amazon-ebs: Here 'single quotes' don't really need to be amazon-ebs: escaped... but it doesn't hurt to do so. 无需转义的情况 用户环境变量值以及 elevated_user 和 elevated_pa​​ssword 字段中出现的特殊字符将自动为用户处理。在这些情况下无需使用转义符。 HCL2： variable \"psvar\" { type = string default = \"My$tring\" } build { sources = [\"source.amazon-ebs.example\"] provisioner \"powershell\" { elevated_user = \"Administrator\" elevated_password = \"Super$3cr3t!\" inline = [\"Write-Output \\\"The dollar in the elevated_password is interpreted correctly\\\"\"] } provisioner \"powershell\" { environment_vars = [ \"VAR1=A$Dollar\", \"VAR2=A`Backtick\", \"VAR3=A'SingleQuote\", \"VAR4=A\\\"DoubleQuote\", \"VAR5=${var.psvar}\", ] inline = [ \"Write-Output \\\"In the following examples the special character is interpreted correctly:\\\"\", \"Write-Output \\\"The dollar in VAR1: $Env:VAR1\\\"\", \"Write-Output \\\"The backtick in VAR2: $Env:VAR2\\\"\", \"Write-Output \\\"The single quote in VAR3: $Env:VAR3\\\"\", \"Write-Output \\\"The double quote in VAR4: $Env:VAR4\\\"\", \"Write-Output \\\"The dollar in VAR5 (expanded from a user var): $Env:VAR5\\\"\", ] } } Json： { \"variables\": { \"psvar\": \"My$tring\" }, ... \"provisioners\": [ { \"type\": \"powershell\", \"elevated_user\": \"Administrator\", \"elevated_password\": \"Super$3cr3t!\", \"inline\": \"Write-Output \\\"The dollar in the elevated_password is interpreted correctly\\\"\" }, { \"type\": \"powershell\", \"environment_vars\": [ \"VAR1=A$Dollar\", \"VAR2=A`Backtick\", \"VAR3=A'SingleQuote\", \"VAR4=A\\\"DoubleQuote\", \"VAR5={{user `psvar`}}\" ], \"inline\": [ \"Write-Output \\\"In the following examples the special character is interpreted correctly:\\\"\", \"Write-Output \\\"The dollar in VAR1: $Env:VAR1\\\"\", \"Write-Output \\\"The backtick in VAR2: $Env:VAR2\\\"\", \"Write-Output \\\"The single quote in VAR3: $Env:VAR3\\\"\", \"Write-Output \\\"The double quote in VAR4: $Env:VAR4\\\"\", \"Write-Output \\\"The dollar in VAR5 (expanded from a user var): $Env:VAR5\\\"\" ] } ] ... } 上面的代码片段应该会在 Packer 控制台上产生以下输出： ==> amazon-ebs: Provisioning with Powershell... ==> amazon-ebs: Provisioning with PowerShell script: /var/folders/15/d0f7gdg13rnd1cxp7tgmr55c0000gn/T/packer-powershell-provisioner961728919 amazon-ebs: The dollar in the elevated_password is interpreted correctly ==> amazon-ebs: Provisioning with Powershell... ==> amazon-ebs: Provisioning with PowerShell script: /var/folders/15/d0f7gdg13rnd1cxp7tgmr55c0000gn/T/packer-powershell-provisioner142826554 amazon-ebs: In the following examples the special character is interpreted correctly: amazon-ebs: The dollar in VAR1: A$Dollar amazon-ebs: The backtick in VAR2: A`Backtick amazon-ebs: The single quote in VAR3: A'SingleQuote amazon-ebs: The double quote in VAR4: A\"DoubleQuote amazon-ebs: The dollar in VAR5 (expanded from a user var): My$tring "},"9.provisioners/4.shell.html":{"url":"9.provisioners/4.shell.html","title":"Shell","keywords":"","body":"Shell 原文 类型：shell Packer 的 shell 配置器使得 Packer 可以使用 shell 脚本构建的机器。 Shell 配置器是在计算机上安装和配置软件的最简单方法。 基础用法 HCL2： provisioner \"shell\" { inline = [\"echo foo\"] } Json： { \"type\": \"shell\", \"inline\": [\"echo foo\"] } 配置参数 下面列出了可用配置选项的参考。唯一必须的元素是 inline 或 script。每个其他选项都是可选的。 以下参数必须选一配置： inline（array of string）- 这是一组要执行的命令。这些命令由换行符连接起来并变成一个文件，因此它们都在相同的上下文中执行。这使得您可以在一个命令中更改目录，并在下一个命令中使用目录中的内容，依此类推。内联脚本是在机器内完成简单任务的最简单方法。 script (string) - 要上传到机器并执行的脚本的路径。此路径可以是绝对路径或相对路径。如果是相对路径，就是相对于Packer执行时的工作目录。 scripts（array of string）- 要执行的脚本数组。脚本将按照指定的顺序上传和执行。每个脚本都是独立执行的，因此一个脚本中的变量等状态不会传递到下一个脚本。 可选参数： binary (boolean) - 如果为 true，则指定脚本是二进制文件，因此 Packer 不应将 Windows 行结尾转换为 Unix 行结尾（如果有的话）。默认为 false。 valid_exit_codes（整数列表）- 脚本的有效返回值。默认情况下全部是 0。 env（map(string)）- 在 execute_command 之前注入的键/值对映射。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。重复的 env 设置会覆盖 environment_vars 中的设置。 environment_vars（[]string）- 在 execute_command 之前注入的键/值对数组。格式应为key=value。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。 env_var_format (string) - 当我们解析您提供的 environment_vars 时，该参数会为我们提供一个字符串模板以确保我们正确设置环境变量。默认值为 \"%s='%s' \"。与 use_env_var_file 结合使用时，默认值为 \"export %s='%s'\\n\" use_env_var_file (boolean) - 如果为 true，Packer 会将您的环境变量写入临时文件并从该文件获取它们，而不是在我们的 execute_command 中内联声明它们。默认的 execute_command 将是 chmod +x { {.Path} }; . { {.EnvVarFile} } && { {.Path} }。在大多数情况下，此选项是不必要的，但如果您在自定义 execute_command 中有额外的引号，那么这可能是正确执行脚本所必需的。默认值：false。 execute_command（string）- 用于执行脚本的命令。 默认值为 chmod +x { { .Path } }; { { .Vars } } { { .Path } }，除非 用户设置了 \"use_env_var_file\": true - 在这种情况下，默认 execute_command 是 chmod +x { {.Path} }; . { {.EnvVarFile} } && { {.Path} }。 该值是一个模板引擎。因此，您可能在此字段中使用用户变量和模板函数。此外，还有三个可用的额外变量： Path 是要运行的脚本的路径 Vars 是 environment_vars 的列表（如果已配置）。 EnvVarFile 是包含环境变量的文件的路径，如果 use_env_var_file 是 true expect_disconnect (boolean) - 默认为 false。当为 true 时，允许服务器断开与 Packer 的连接而不抛出错误。如果您重新启动 SSH 服务器或重新启动主机，则连接可能会断开。 inline_shebang (string) - 运行 inline 指定的命令时使用的 shebang 值。默认值为 /bin/sh -e。如果您不使用 inline，则此配置无效。重要提示：如果您对此进行自定义，请务必包含类似 -e 标志的内容，否则个别步骤失败不会引发配置器失败。 remote_folder (string) - 上传的脚本将保存在机器上的文件夹。默认值为 /tmp。 remote_file (string) - 上传的脚本在机器上的文件名。默认值为 script_nnn.sh。 remote_path (string) - 上传脚本在远程机器上的完整路径。默认值是 remote_folder/remote_file，如果设置此选项将覆盖 remote_folder 和 remote_file。 skip_clean (boolean) - 如果为 true，则指定上传到系统的脚本不会被 Packer 删除。默认值为 false（从系统中清理脚本）。 start_retry_timeout (string) - 尝试启动远程进程的时间量。默认情况下，默认值为 5m或 5 分钟。存在此设置是为了应对 SSH 可能重新启动的时间，例如系统重新启动。如果重新启动需要更长的时间，请将此设置为更高的值。 pause_after (string) - 配置 shell 脚本后等待的时间，如果前面的所有步骤都成功，则暂停。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用不同设置覆盖指定配置器的配置，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 执行命令的例子 对于许多新用户来说，execute_command 令人费解。但是，它提供了一个重要的功能：自定义命令的执行方式。最常见的用例是处理 sudo 密码提示。如果您使用非 POSIX shell，例如 FreeBSD 上的 tcsh，您可能还需要自定义该参数。 Sudo 的例子 某些操作系统默认为非根用户。例如，如果您以 ubuntu 身份登录并且使用密码 packer 执行 sudo，那么您需要将 execute_command 更改为： \"echo 'packer' | sudo -S sh -c '{{ .Vars }} {{ .Path }}'\" -S 标志告诉 sudo 从 stdin 读取密码，在本例中，它是通过管道输入了 packer 这个值。 如果您的环境变量包含空格或单引号，则上述示例将不起作用；这种情况下尝试删除单引号： \"echo 'packer' | sudo -S env {{ .Vars }} {{ .Path }}\" 通过这样配置 execute_command，您的脚本可以以 root 权限运行，而不必担心密码提示。 FreeBSD 的例子 FreeBSD 的默认 shell 是 tcsh，它偏离了 POSIX 语义。为了让 Packer 程序传递环境变量，您需要将 execute_command 更改为： chmod +x {{ .Path }}; env {{ .Vars }} {{ .Path }} 注意在 { { .Vars } } 之前添加了 env。 默认的环境变量 除了能够使用 environment_vars 配置自定义环境变量外，配置器还会自动定义某些常用的环境变量： PACKER_BUILD_NAME 值为 Packer 正在运行的构建的名称。这在 Packer 进行多个构建并且您希望将它们彼此能有所区分时最有用。 PACKER_BUILDER_TYPE 是用于创建运行脚本的机器的构建器类型。如果您只想在使用特定构建器构建的系统上运行脚本的特定部分，这将很有用。 PACKER_HTTP_ADDR 如果使用为文件传输提供 HTTP 服务器的构建器（例如 hyperv、parallels、qemu、virtualbox 和 vmware），这将被设置为 HTTP 服务器地址。您可以在配置器中使用此地址通过 HTTP 下载大文件。如果您在使用默认文件配置器时遇到较慢的速度，这可能很有用。使用 winrm 通信器的 file 配置器可能会遇到这些类型的困难。 处理重启 配置器有时需要重启，通常是在更新操作系统时。 Packer 的 shell 配置器可以处理重启的情况。 Packer 通过重试执行脚本一段时间直到超时失败来处理此问题。这将允许机器有时间启动并准备好运行脚本。 配置器等待的时间是使用 start_retry_timeout 配置的，默认为几分钟。 有时，当执行诸如 reboot 之类的命令时，shell 脚本将返回并且 Packer 将在 SSH 实际退出并重新启动机器之前开始执行下一个命令。为此，使用 pause_before 让 Packer 在执行下一个脚本之前等待： HCL2： provisioner \"shell\" { script = \"script.sh\" pause_before = \"10s\" timeout = \"10s\" } Json： { \"type\": \"shell\", \"script\": \"script.sh\", \"pause_before\": \"10s\", \"timeout\": \"10s\" } 某些操作系统配置无法在重启时正确终止所有网络连接，导致配置器在主机重启后挂起。在这种情况下，请确保在重启时或在 shell 脚本中关闭网络接口。例如，在 Gentoo 上： /etc/init.d/net.eth0 stop SSH Agent Forwarding 一些配置器需要从 Packer 实例中连接到远程 SSH 服务器。下面的示例是使用客户端上的 openssh 从私有 git 存储库中提取代码。确保您正在运行 ssh-agent 并使用 ssh-add /path/to/key 将您的 git repo SSH 密钥添加到其中。当 Packer 实例需要访问 SSH 密钥时，代理会将请求转发回您的 ssh-agent。 注意：当通过 git 进行配置时，您应该将 git 服务器密钥添加到 ~/.ssh/known_hosts 文件中，否则 git 命令可能会挂起等待输入。这可以通过文件配置器复制文件（更安全）或使用 ssh-keyscan 填充文件（不太安全）来完成。后者访问 github 的一个例子是： HCL2： provisioner \"shell\" { inline = [ \"sudo apt-get install -y git\", \"ssh-keyscan github.com >> ~/.ssh/known_hosts\", \"git clone git@github.com:exampleorg/myprivaterepo.git\" ] } Json： { \"type\": \"shell\", \"inline\": [ \"sudo apt-get install -y git\", \"ssh-keyscan github.com >> ~/.ssh/known_hosts\", \"git clone git@github.com:exampleorg/myprivaterepo.git\" ] } 故障排查 我的 shell 脚本在 Ubuntu 上不能正常工作！ 在 Ubuntu 上，/bin/sh shell 是 dash。如果您的脚本中包含特定于 bash) 的命令，请将 #!/bin/bash -e 放在脚本的顶部。可以在 Ubuntu wiki 的 DashAsBinSh 页面上找到 dash 和 bash 之间的区别。 当我登录时，我的 shell 可以工作，但 shell 配置器失败了 请参阅上面的提示。更有可能的是，您的登录 shell 使用 /bin/bash，而配置程序使用 /bin/sh。 使用 apt-get 或 yum 时安装程序挂起 确保在命令中添加 -y 以防止它要求用户输入才能继续执行。 我如何知道我的 shell 脚本在做什么？ 将 -x 标志添加到脚本顶部的 shebang (#!/bin/sh -x) 将在脚本语句执行时回显脚本语句。 我的构建并不总是一样 一些发行版在其他核心服务之前启动 SSH 守护进程，这会产生竞争条件。您的第一个配置器可以阻塞配置直至 SSH 守护进程完全启动后再运行。 HCL2： provisioner \"shell\" { inline = [\"sleep 10\"] } Json： { \"type\": \"shell\", \"inline\": [\"sleep 10\"] } 环境变量中使用双引号 Packer 会为您管理双引号，因此您不必担心。以下是 Packer 模板输入的示例以及您应该期望得到的内容： HCL2： provisioner \"shell\" { environment_vars = [ \"FOO=foo\", \"BAR=bar's\", \"BAZ=baz=baz\", \"QUX==qux\", \"FOOBAR=foo bar\", \"FOOBARBAZ='foo bar baz'\", \"QUX2=\\\"qux\\\"\" ] inline = [ \"echo \\\"FOO is $FOO\\\"\", \"echo \\\"BAR is $BAR\\\"\", \"echo \\\"BAZ is $BAZ\\\"\", \"echo \\\"QUX is $QUX\\\"\", \"echo \\\"FOOBAR is $FOOBAR\\\"\", \"echo \\\"FOOBARBAZ is $FOOBARBAZ\\\"\", \"echo \\\"QUX2 is $QUX2\\\"\" ] } Json： \"provisioners\": [ { \"type\": \"shell\", \"environment_vars\": [\"FOO=foo\", \"BAR=bar's\", \"BAZ=baz=baz\", \"QUX==qux\", \"FOOBAR=foo bar\", \"FOOBARBAZ='foo bar baz'\", \"QUX2=\\\"qux\\\"\"], \"inline\": [\"echo \\\"FOO is $FOO\\\"\", \"echo \\\"BAR is $BAR\\\"\", \"echo \\\"BAZ is $BAZ\\\"\", \"echo \\\"QUX is $QUX\\\"\", \"echo \\\"FOOBAR is $FOOBAR\\\"\", \"echo \\\"FOOBARBAZ is $FOOBARBAZ\\\"\", \"echo \\\"QUX2 is $QUX2\\\"\"] } ] 输出： docker: FOO is foo docker: BAR is bar's docker: BAZ is baz=baz docker: QUX is =qux docker: FOOBAR is foo bar docker: FOOBARBAZ is 'foo bar baz' docker: QUX2 is \"qux\" "},"9.provisioners/5.shell-local.html":{"url":"9.provisioners/5.shell-local.html","title":"Local Shell","keywords":"","body":"Local Shell 配置器 原文 类型：shell-local shell-local 将在运行 Packer 的机器上运行您选择的 shell 脚本 - 换句话说，shell-local 将在您的构建服务器或桌面等上运行 shell 脚本，而不是由 Packer 创建的远程/来宾机器。 远程 shell 配置器可以在远程机器上执行 shell 脚本。 基础用法 HCL2： source \"file\" \"example\" { content = \"example content\" } build { source \"source.file.example\" { target = \"./test_artifact.txt\" } provisioner \"shell-local\" { inline = [\"echo foo\"] } } Json： { \"builders\": [ { \"type\": \"file\", \"name\": \"example\", \"target\": \"./test_artifact.txt\", \"content\": \"example content\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo foo\"] } ] } 配置参数 下面列出了可用配置选项的参考。唯一必须的元素是 command。 以下参数必须选一配置： command（string）- 要执行的单个命令。它将被写入临时文件并使用下面的 execute_command 调用运行。如果您正在 AWS、Azure、Google Compute 或 OpenStack 上构建 Windows VM，并且想要访问 Packer 用于通过 WinRM 连接到实例的生成密码，您可以使用模板变量 { {.WinRMPassword} } 来将之设置成一个环境变量。 inline（[]string）- 一组要执行的命令。这些命令由换行符连接起来并变成一个文件，因此它们都在相同的上下文中执行。这允许您在一个命令中更改目录，并在下一个命令中使用目录中的内容，依此类推。inline 脚本是在运行 Packer 的机器中完成简单任务的最简单方法。 script (string) - 要执行的脚本的路径。此路径可以是绝对路径或相对路径。如果是相对路径，就是相对于Packer执行时的工作目录。 scripts（[]string）- 要执行的脚本数组。脚本将按照指定的顺序执行。每个脚本都是独立执行的，因此一个脚本中的变量等状态不会传递到下一个脚本。 选填参数： env (map(string)) - 在 execute_command 之前注入的键/值对映射。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。env 与 environment_vars 冲突的部分会覆盖后者的设置。 environment_vars ([]string) - 在 execute_command 之前注入的键/值对数组。格式应为 key=value。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。如果您正在 AWS、Azure、Google Compute 或 OpenStack 上构建 Windows VM，并且想要访问 Packer 用于通过 WinRM 连接到实例的生成密码，您可以使用模板变量 { {.WinRMPassword} } 来将之设置为一个环境变量。例如：\"environment_vars\"：\"WINRMPASS={ {.WinRMPassword} }\" env_var_format (string) - 当我们解析您提供的 environment_vars 时，该参数会为我们提供一个字符串模板以确保我们正确设置环境变量。默认情况下，在 Windows 主机上，此格式为 set %s=%s &&，在 Unix 上，它是 %s='%s'。您可能不需要更改此格式，但您可以在下面查看一些需要修改该参数的用法示例。 execute_command ([]string) - 用于执行脚本的命令。默认在 Unix 上是 [\"/bin/sh\", \"-c\", \"{ {.Vars} }\", \"{ {.Script} }\"]，在 Windows 上是 [\"cmd\", \"/c\", \"{ {.Vars} }\", \"{ {.Script} }\"]。该参数的值是一个模板引擎。有两个可用变量：Scripts，代表要运行的脚本的路径，以及 Vars，代表 environment_vars 的列表（如果已配置）。 如果您选择设置此选项，请确保数组中的第一个元素是您要使用的 shell 程序（例如，\"sh\"），数组中后面的元素必须是 { {.Script} }。 该参数为您提供了很大的灵活性。您可以选择提供自己的 shell 程序，例如 \"/usr/local/bin/zsh\" 甚至 \"powershell.exe\" 。然而，能力越大，责任越大 - 这些命令不受官方支持，如果您使用不同于默认的 shell，环境变量之类的功能可能无法工作。 为了向后兼容，您也可以使用 { {.Command} }，但它的解码方式与 { {.Script} } 相同。为了清楚起见，我们建议使用 { {.Script} } ，因为即使您只设置了一个要运行的命令，Packer 也会将其写入一个临时文件，然后将其作为脚本运行。 如果您正在 AWS、Azure、Google Compute 或 OpenStack 上构建 Windows VM，并且想要访问 Packer 用于通过 WinRM 连接到实例的生成密码，您可以使用模板变量 { {.WinRMPassword} } 来将之设置为一个环境变量。 inline_shebang (string) - 运行 inline 指定的命令时使用的 shebang 值。默认为 /bin/sh -e。如果您不使用 inline，则此配置无效。重要提示：如果您对此进行自定义，请务必包含类似 -e 标志的内容，否则个别步骤失败不会使配置器失败。 only_on ([]string) - 这是一个操作系统运行时数组，shell-local 将在其中执行。这允许您仅在特定操作系统上执行 shell-local。默认情况下，如果未设置 only_on，shell-local 将始终运行。 use_linux_pathing (bool) - 这仅与 Windows 主机相关。如果您在启用了 Windows Subsystem for Linux 功能的 Windows 环境中运行 Packer，并且想要调用 bash 脚本而不是调用 Cmd 脚本，则需要将此标志设置为 true；它告诉 Packer 为您的脚本使用 Linux 子系统路径，而不是 Windows 路径。 （例如 /mnt/c/path/to/your/file 而不是 C:/path/to/your/file）。有关如何使用此功能的更多指导，请参阅下面的示例。如果您不在 Windows 主机上，或者您不打算使用 shell-local 配置器来运行 bash 脚本，请忽略此选项。 valid_exit_codes ([]int) - 脚本的有效退出代码。默认为 0。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用特定配置器的不同设置覆盖配置器，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 execute_command 详解 对于许多新用户来说，execute_command 令人费解。但是，它提供了一个重要的功能：自定义命令的执行方式。最常见的用例是处理 sudo 密码提示。如果您使用非 POSIX shell，例如 FreeBSD 上的 tcsh，您可能还需要对该参数进行自定义。 Windows Subsystem For Linux shell-local 配置器的设计理念是允许您在本地操作系统的本机 shell 中运行命令。对于 Windows，我们在默认情况下假定这是 Cmd。然而通过修改配置程序配置中的 execute_command 和 use_linux_pathing 选项，可以让 shell local 配置程序使用 Windows Linux 子系统来运行 bash 脚本。 此功能的一个限制是无法使用 inline 和 command 参数；请使用 script 或 scripts 参数。 请注意，WSL 是测试版功能，不保证此工具能按您预期的方式工作。 HCL2： source \"null\" \"example\" { communicator = \"none\" } build { sources = [ \"source.null.example\" ] provisioner \"shell-local\"{ environment_vars = [\"PROVISIONERTEST=ProvisionerTest1\"] execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true scripts = [\"C:/Users/me/scripts/example_bash.sh\"] } provisioner \"shell-local\"{ environment_vars = [\"PROVISIONERTEST=ProvisionerTest2\"] execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true script = \"C:/Users/me/scripts/example_bash.sh\" } } Json： { \"builders\": [ { \"type\": \"null\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest1\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"scripts\": [\"C:/Users/me/scripts/example_bash.sh\"] }, { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest2\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"script\": \"C:/Users/me/scripts/example_bash.sh\" } ] } 默认的环境变量 除了能够使用 environment_vars 配置自定义环境变量外，配置器还会自动定义某些常用的环境变量： PACKER_BUILD_NAME 值为 Packer 正在运行的构建的名称。这在 Packer 进行多个构建并且您希望将它们彼此能有所区分时最有用。 PACKER_BUILDER_TYPE 是用于创建运行脚本的机器的构建器类型。如果您只想在使用特定构建器构建的系统上运行脚本的特定部分，这将很有用。 PACKER_HTTP_ADDR 如果使用为文件传输提供 HTTP 服务器的构建器（例如 hyperv、parallels、qemu、virtualbox 和 vmware），这将被设置为 HTTP 服务器地址。您可以在配置器中使用此地址通过 HTTP 下载大文件。如果您在使用默认文件配置器时遇到较慢的速度，这可能很有用。使用 winrm 通信器的 file 配置器可能会遇到这些类型的困难。 编写安全的脚本 无论您是使用 inline 参数，还是将其传递给 script 或是 scripts，重要的是要了解有关 shell-local 配置器如何运行的原理才能安全又轻松地运行该配置器。理解本配置器的运行原理会在这个过程中为你节省很多时间。 每次构建都会运行一次 您传递给 shell local 的脚本在每个构建器上都会运行一次。这意味着如果您有一个 amazon-ebs 构建器和一个 docker 构建器，您的脚本将运行两次。如果您有 3 个构建器，它将运行 3 次，每个构建器一次。 必须设置退出代码 如果任何配置器失败，Packer 程序的构建将会停止并清除所有临时制品。 对于 shell 脚本，这意味着脚本必须以代码 0 退出。必要时必须小心的调用 exit 0。 使用样例 Windows 主机 在 Windows 主机上运行一个 .cmd 文件的例子： HCL2： provisioner \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest1\"] scripts = [\"./scripts/test_cmd.cmd\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest1\"], \"scripts\": [\"./scripts/test_cmd.cmd\"] } 假设 test_cmd.cmd 的内容是： echo %SHELLLOCALTEST% 在 Windows 上使用 inline 命令运行该脚本，需要定制化 tempfile_extension： HCL2： provisioner \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest2\"], tempfile_extension = \".cmd\", inline = [echo \"%SHELLLOCALTEST%\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest2\"], \"tempfile_extension\": \".cmd\", \"inline\": [\"echo %SHELLLOCALTEST%\"] } 在 Windows 上使用 WSL 运行 bash 命令的示例，所需 use_linux_pathing 和 execute_command 进行定制化： HCL2： provisioner \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest3\"], execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true script = \"./scripts/example_bash.sh\" } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest3\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"script\": \"./scripts/example_bash.sh\" } example_bash.sh 的内容： #!/bin/bash echo $SHELLLOCALTEST 在 Windows 上运行 PowerShell 脚本的示例，需要对 env_var_format 和 execute_command 进行定制化： HCL2： provisioner \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest4\"] execute_command = [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"] env_var_format = \"$env:%s=\\\"%s\\\"; \" script = \"./scripts/example_ps.ps1\" } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest4\"], \"execute_command\": [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"], \"env_var_format\": \"$env:%s=\\\"%s\\\"; \", \"script\": \"./scripts/example_ps.ps1\" } 在 Windows 上以 inline 方式运行 PowerShell 脚本的示例，需要对 env_var_format、tempfile_extension 和 execute_command 进行定制化： HCL2： provisioner \"shell-local\" { tempfile_extension = \".ps1\" environment_vars = [\"SHELLLOCALTEST=ShellTest5\"] execute_command = [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"] env_var_format = \"$env:%s=\\\"%s\\\"; \" inline = [\"write-output $env:SHELLLOCALTEST\"] } Json： { \"type\": \"shell-local\", \"tempfile_extension\": \".ps1\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest5\"], \"execute_command\": [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"], \"env_var_format\": \"$env:%s=\\\"%s\\\"; \", \"inline\": [\"write-output $env:SHELLLOCALTEST\"] } Unix 主机 在 Unix 主机上运行脚本的例子： HCL2： provisioner \"shell-local\" { environment_vars = [\"PROVISIONERTEST=ProvisionerTest1\"] scripts = [\"./scripts/example_bash.sh\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest1\"], \"scripts\": [\"./scripts/example_bash.sh\"] } 在 Unix 主机上用 inline 运行脚本的例子： HCL2： provisioner \"shell-local\" { environment_vars = [\"PROVISIONERTEST=ProvisionerTest2\"] inline = [\"echo hello\", \"echo $PROVISIONERTEST\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest2\"], \"inline\": [\"echo hello\", \"echo $PROVISIONERTEST\"] } 在 Unix 上运行 Python 脚本的例子： HCL2： provisioner \"shell-local\" { script = \"hello.py\" environment_vars = [\"HELLO_USER=packeruser\"] execute_command = [ \"/bin/sh\", \"-c\", \"{{.Vars}} /usr/local/bin/python {{.Script}}\" ] } Json： { \"type\": \"shell-local\", \"script\": \"hello.py\", \"environment_vars\": [\"HELLO_USER=packeruser\"], \"execute_command\": [ \"/bin/sh\", \"-c\", \"{{.Vars}} /usr/local/bin/python {{.Script}}\" ] } hello.py 的内容如下： import os print('Hello, %s!' % os.getenv(\"HELLO_USER\")) "},"9.provisioners/6.windows-shell.html":{"url":"9.provisioners/6.windows-shell.html","title":"Windows Shell","keywords":"","body":"Windows Shell 配置器 原文 类型：windows-shell Packer 的 windows-shell 配置器使用 cmd 在 Windows 机器上运行命令。该配置器假定它正通过 WinRM 运行。 基础用法 HCL2： provisioner \"windows-shell\" { inline = [\"dir c:\\\\\"] } Json： { \"type\": \"windows-shell\", \"inline\": [\"dir c:\\\\\"] } 配置参数 下面列出了可用配置选项的参考。唯一必须的元素是 inline 或 script。其他选项都是可选的。 以下参数必须选一配置： inline（[]string）- 一组要执行的命令。这些命令由换行符连接起来并变成一个文件，因此它们都在相同的上下文中执行。这允许您在一个命令中更改目录，并在下一个命令中使用目录中的内容，依此类推。inline 脚本是在运行 Packer 的机器中完成简单任务的最简单方法。 script (string) - 要执行的脚本的路径。此路径可以是绝对路径或相对路径。如果是相对路径，就是相对于Packer执行时的工作目录。 scripts（[]string）- 要执行的脚本数组。脚本将按照指定的顺序执行。每个脚本都是独立执行的，因此一个脚本中的变量等状态不会传递到下一个脚本。 可选参数： binary (boolean) - 如果为 true，则指定脚本是二进制文件，因此 Packer 不会将 Windows 换行符转换为 Unix 换行符（如果有的话）。默认为 false。 valid_exit_codes ([]int) - 脚本的有效退出代码。默认值为 0。 env（map(string)）- 在 execute_command 之前注入的键/值对映射。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。重复的 env 设置会覆盖 environment_vars 中的设置。 environment_vars（[]string）- 在 execute_command 之前注入的键/值对数组。格式应为key=value。 Packer 也会默认将一些环境变量注入到环境中，这将在下面的部分中介绍。 execute_command（string）- 用于执行脚本的命令。 默认值为 { { .Vars } }\"{ { .Path } }\"。 该值是一个模板引擎。因此，您可能在此字段中使用用户变量和模板函数。此外，还有三个可用的额外变量： Path 是要运行的脚本的路径 Vars 是 environment_vars 的列表（如果已配置）。 remote_path (string) - 脚本将被上传到机器中的路径。默认值为 \"c:/Windows/Temp/script.bat\"。此值必须是可写位置，并且所有父目录必须已经存在。 start_retry_timeout (string) - 尝试启动远程进程的时间量。默认情况下，这是 \"5m\" 或 5 分钟。存在此设置是为了处理可能重新启动的时间，例如系统重新启动。如果重新启动需要更长的时间，请将此设置为更高的值。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用特定配置器的不同设置覆盖配置器，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 默认的环境变量 除了能够使用 environment_vars 配置自定义环境变量外，配置器还会自动定义某些常用的环境变量： PACKER_BUILD_NAME 值为 Packer 正在运行的构建的名称。这在 Packer 进行多个构建并且您希望将它们彼此能有所区分时最有用。 PACKER_BUILDER_TYPE 是用于创建运行脚本的机器的构建器类型。如果您只想在使用特定构建器构建的系统上运行脚本的特定部分，这将很有用。 PACKER_HTTP_ADDR 如果使用为文件传输提供 HTTP 服务器的构建器（例如 hyperv、parallels、qemu、virtualbox 和 vmware），这将被设置为 HTTP 服务器地址。您可以在配置器中使用此地址通过 HTTP 下载大文件。如果您在使用默认文件配置器时遇到较慢的速度，这可能很有用。使用 winrm 通信器的 file 配置器可能会遇到这些类型的困难。 "},"9.provisioners/7.windows-restart.html":{"url":"9.provisioners/7.windows-restart.html","title":"Windows Restart","keywords":"","body":"Windows Restart 配置器 原文 类型：windows-restart Windows Restart 配置器在 Windows 机器上发起重启并等待机器重新联机。 Windows 配置过程通常需要多次重启，而此配置器有助于简化该过程。 Packer 希望在机器重新启动并就绪后再继续执行配置程序。 Packer 通过 Windows 远程管理 (WinRM) 服务而不是 ACPI 函数进行 RPC 调用来检测重启是否已完成，因此 Windows 必须完全启动才能继续。 基础用法 HCL2： provisioner \"windows-restart\" {} Json： { \"type\": \"windows-restart\" } 配置参数 以下是该配置器可用的一些可选参数： check_registry (bool) - 如果为 true，则检查几个指示系统将要重启的注册表项。如果配置程序启动了重启，并且您希望配置器在重新连接之前等待重启完成，该参数将很有用。请注意，此选项是测试版功能，我们通常建议您在 winrm 配置器程序连接之前的自动无人参与阶段完成自动重启的安装（如 Windows 更新）。 registry_keys ([]string) - 如果 check-registry 为 true，windows-restart 将不会重新连接，直到所有列出的键都不再存在于注册表中。 default: var DefaultRegistryKeys = []string{ \"HKLM:SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Component Based Servicing\\\\RebootPending\", \"HKLM:SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Component Based Servicing\\\\PackagesPending\", \"HKLM:Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Component Based Servicing\\\\RebootInProgress\", } restart_command (string) - 发起启动重启的命令。默认值为 shutdown /r /f /t 0 /c \"packer restart\"。 restart_check_command (string) - 执行 restart_command 后运行的命令，用于检查远程计算机是否已重新启动。此命令将重试，直到恢复到客户机的连接或超过 restart_timeout。 HCL2： provisioner \"windows-restart\" { restart_check_command = \"powershell -command \\\"& {Write-Output 'restarted.'}\\\"\" } Json： { \"type\": \"windows-restart\", \"restart_check_command\": \"powershell -command \\\"& {Write-Output 'restarted.'}\\\"\" } restart_timeout (string) - 等待重启的超时时间。默认情况下，这是 5 分钟。示例值：5m。如果您正在安装更新或有很多启动服务，您可能需要增加此持续时间。 所有配置器共有的参数： pause_before (duration) - 执行前休眠一段时间。 max_retries (int) - provisioner 在失败的情况下重试的最大次数。默认为零 (0)。零表示不会重试错误。 only (array of string) - 只运行列表中指定的的配置器程序。 override (object) - 使用特定配置器的不同设置覆盖配置器，例如： HCL2： source \"null\" \"example1\" { communicator = \"none\" } source \"null\" \"example2\" { communicator = \"none\" } build { sources = [\"source.null.example1\", \"source.null.example2\"] provisioner \"shell-local\" { inline = [\"echo not overridden\"] override = { example1 = { inline = [\"echo yes overridden\"] } } } } Json： { \"builders\": [ { \"type\": \"null\", \"name\": \"example1\", \"communicator\": \"none\" }, { \"type\": \"null\", \"name\": \"example2\", \"communicator\": \"none\" } ], \"provisioners\": [ { \"type\": \"shell-local\", \"inline\": [\"echo not overridden\"], \"override\": { \"example1\": { \"inline\": [\"echo yes overridden\"] } } } ] } timeout（duration）- 如果配置器完成时间超过配置值（例如 1h10m1s 或 10m），则配置器将超时并失败。 "},"10.post-processors/overview.html":{"url":"10.post-processors/overview.html","title":"后处理器","keywords":"","body":"后处理器 后处理器在构建器和配置器之后运行。后处理器是可选的，您可以使用它们上传制品、重新打包文件等。下面我们将介绍一些不同类型的后处理器。 读者可以参考 post-processor 和 post-processors 获取如何配置后处理器。 "},"10.post-processors/1.artifice.html":{"url":"10.post-processors/1.artifice.html","title":"Artifice","keywords":"","body":"Artifice 后处理器 原文 类型：artifice 制品构建器 ID：packer.post-processor.artifice artifice 后处理器会覆盖上游构建器或后处理器传递下来的制品。所有下游后处理器都会看到您指定的新制品。 使用 artifice 覆盖制品后，您可以将其与其他大多数核心后处理器和第三方后处理器一起使用。 这样做的一个主要好处是，您可以使用 shell-local 修改来自上游的制品，并将这些修改后的制品传递到可能无法与原始构建器配合运行的后处理器中。例如，您可能想从 amazon-ebs 构建器导出 Docker 容器，然后使用 docker push 将该 Docker 容器推送至您的 Docker Hub 帐户中。 Artifice 允许您使用熟悉的 Packer 工作流程为您选择的基础架构上的每个构建创建一个全新的、无状态的构建环境。您可以使用它来构建几乎任何东西：buildpack、容器、jar、二进制文件、tarball、msi 安装程序等等。 请注意，artifice 后处理器不会删除旧的制品文件，即使它从制品中删除了它们。如果要删除旧的制品文件，可以使用 shell-local 后处理器来执行此操作。 工作流 Artifice 可帮助您将其他一些 Packer 功能结合在一起： 构建器，启动虚拟机（或容器）来构建您的制品 配置器，执行创建制品的步骤 file 配置器，从虚拟机下载制品 artifice 后处理器，用于识别从虚拟机下载了哪些文件 额外的后处理器，将制品推送到 Docker Hub 等 我们希望在虚拟机内执行尽可能多的工作。理想情况下，除了 artifice 之外，您唯一需要的后处理器将被用来把上传制品到合适的存储库。 配置 以下配置允许您指定您的制品由哪些文件构成。 必填 file（[]string）- 组成您的制品的文件列表。 Packer 的配置阶段完成后，这些文件必须存在于您的本地磁盘上。这些文件将取代来自上游的所有原始制品（例如虚拟机快照）。 选填 keep_input_artifact (boolean) - 如果为 true，则在创建新制品后不删除原始制品文件。默认为 true。 配置样例 一个最小的可运行例子： 启动克隆的 VMware 虚拟机 安装 Consul 下载 Consul 二进制文件 将其打包成 .tar.gz 文件 将其上传到 S3。 VMX 是一种在本地构建和测试的快速方法，但您可以轻松地替换成其他类型的构建器。 { \"builders\": [ { \"type\": \"vmware-vmx\", \"source_path\": \"/opt/ubuntu-1404-vmware.vmx\", \"ssh_username\": \"vagrant\", \"ssh_password\": \"vagrant\", \"shutdown_command\": \"sudo shutdown -h now\", \"headless\": \"true\", \"skip_compaction\": \"true\" } ], \"provisioners\": [ { \"type\": \"shell\", \"inline\": [ \"sudo apt-get install -y python-pip\", \"sudo pip install ifs\", \"sudo ifs install consul --version=0.5.2\" ] }, { \"type\": \"file\", \"source\": \"/usr/local/bin/consul\", \"destination\": \"consul\", \"direction\": \"download\" } ], \"post-processors\": [ [ { \"type\": \"artifice\", \"files\": [\"consul\"] }, { \"type\": \"compress\", \"output\": \"consul-0.5.2.tar.gz\" }, { \"type\": \"shell-local\", \"inline\": [ \"/usr/local/bin/aws s3 cp consul-0.5.2.tar.gz s3://\" ] } ] ] } 请注意，后处理器部分有两组方括号。这将创建一个后处理器链，其中上一个后处理器输出的制品被传递到后续的后处理器。如果仅使用一组方括号，后处理器将针对构建制品（本例中为 vmx 文件）单独运行，并且不会获得所需的结果。 { \"post-processors\": [ [ // 您可以创建多个后处理器链来处理多个构建器（例如，在同一构建内构建 Linux 和 Windows 二进制文件）。 "},"10.post-processors/2.compress.html":{"url":"10.post-processors/2.compress.html","title":"Compress","keywords":"","body":"Compress 后处理器 原文 类型：compress 制品构建器 ID：packer.post-processor.compress Packer 的 compress 后处理器获取包含文件的制品（例如来自 VMware 或 VirtualBox 的文件），并将该制品压缩到单个存档中。 配置 可选 默认情况下，Packer 将以 .tar.gz 格式构建存档，文件名如下：packer_{{.BuildName}}_{{.BuilderType}}。如果您想更改此设置，则需要指定 output 选项。 output（string）- 保存压缩档案的路径。存档格式是从文件名推断出来的。例如。 .tar.gz 会保存为一个 gzip 压缩的 tarball， .zip 将是一个 zip 文件。如果无法检测到扩展名，Packer 默认使用 .tar.gz 格式压缩，但不会更改文件名。 该参数的值会结合模板引擎渲染。因此，您可以在此字段中使用用户传入的变量和模板函数。以下特殊变量也可在输出模板中使用： {{.BuildName}} {{.BuilderType}} 如果您并行执行多个构建器，则应确保每个构建器的 output 都是唯一的。例如 packer_{{.BuildName}}.zip。 format（string）- 禁止自动检测存档格式，使用设置的格式 compression_level (number) - 为支持该功能的算法指定压缩级别，从 1 到 9（含）。通常，较高的压缩级别需要较长的时间，但会生成较小的文件。默认为 6 keep_input_artifact (boolean) - 如果为 true，则保留源文件和压缩文件；如果为 false，则丢弃源文件。默认为 false 支持的格式： 支持的文件扩展名包括 .zip、.tar、.gz、.tar.gz、.lz4 和 .tar.lz4。请注意，.gz 和 .lz4 不能用来压缩多个文件。 配置样例 一些例子（仅包含后处理器部分）： { \"type\": \"compress\", \"output\": \"archive.tar.lz4\" } { \"type\": \"compress\", \"output\": \"{{.BuildName}}_bundle.zip\" } { \"type\": \"compress\", \"output\": \"log_{{.BuildName}}.gz\", \"compression_level\": 9 } "},"10.post-processors/3.checksum.html":{"url":"10.post-processors/3.checksum.html","title":"Checksum","keywords":"","body":"Checksum 后处理器 原文 类型：checksum 制品构建器 ID：packer.post-processor.checksum checksum 后处理器为来自上游构建器或后处理器的制品以指定校验和算法计算校验和。所有下游后处理器都将看到新的制品。主要用例是计算制品的校验和以便稍后进行验证。 计算了制品的校验和后，您可以将新制品与其他后处理器（例如 artifice、compress 、docker-push 或第三方后处理器一起使用。 基本样例 Json： { \"type\": \"checksum\", \"checksum_types\": [\"sha1\", \"sha256\"], \"output\": \"packer_{{.BuildName}}_{{.ChecksumType}}.checksum\" } HCL2： post-processor \"checksum\" { checksum_types = [\"sha1\", \"sha256\"] output = \"packer_{{.BuildName}}_{{.ChecksumType}}.checksum\" } 配置 可选参数： checksum_types（[]string） - 存储着要计算的校验和类型的字符串数组。如果为空，则默认为 md5。允许的值为： md5 sha1 sha224 sha256 sha384 sha512 output（string）- 指定用于存储校验和的文件名。默认为 packer_{{.BuildName}}_{{.BuilderType}}_{{.ChecksumType}}.checksum。例如，如果您有一个名为 database 的构建器，您可能会看到校验和被写入名为 packer_database_docker_md5.checksum 的文件。该参数会结合模板引擎使用。因此，您可以在此字段中使用用户变量和模板函数。以下特殊变量也可在输出模板中使用： BuildName：生成制品的构建器的名称。 BuilderType：用于生成制品的构建器的类型。 ChecksumType：文件包含的校验和类型。如果 checksum_types 中有多个值，则应使用此选项。 "},"10.post-processors/4.docker-push.html":{"url":"10.post-processors/4.docker-push.html","title":"Docker Push","keywords":"","body":"Docker Push 后处理器 原文 类型：docker-push Packer Docker Push 后处理器从 docker-import 后处理器获取制品并将其推送到 Docker Registry。 配置 该后处理器所有参数均为可选： aws_access_key（string）- 用于与 AWS 通信的 AWS 访问密钥。了解如何设置。 aws_secret_key (string) - 用于与 AWS 通信的 AWS 密钥。了解如何设置。 aws_token（string）- 要使用的 AWS 访问令牌。这与 aws_access_key 和 aws_secret_key 不同。如果您不确定这是什么，那么您可能不需要它。也可以从 AWS_SESSION_TOKEN 环境变量中读取。 aws_profile（string）- 用于与 AWS 通信的 AWS 共享凭证配置文件。了解如何设置。 ecr_login (bool) - 默认为 false。如果为 true，则后处理器将登录 ECR 以便将镜像推送到 Amazon EC2 容器注册表 (ECR)。后处理器仅在推送期间登录。如果为 true 那么必须配置 login_server，且 login、login_username 和 login_password 参数将被忽略。 aws_force_use_public_ecr（bool）- 默认为 false。如果为 true，后处理器将尝试强制将镜像推送到 ECR Public Gallery。但是，如果您在 login_server 参数中已经指了定正确的 ECR Public URL，则此参数是可选的，后处理器将自动将自动将其认定为 ECR Public。 keep_input_artifact (boolean) - 如果为 true，则将 Docker 镜像推送到云端后不删除它。默认为 true，但如果不需要保存 Docker 镜像的本地副本，可以设置为 false。 platform (string) - 如果服务器支持多平台，则设置平台参数。 login（bool）- 默认为 false。如果为 true，则后处理器将在推送之前登录。登录 ECR 的信息请参阅 ecr_login。 login_username（string）- 用于验证登录的用户名。 login_password（string）- 用于验证登录的密码。 login_server (string) - 要登录的服务器地址。 注意：如果使用 Docker Hub 或是 Quay 作为镜像仓库，login 参数必须设置为 true，且 login_username 和 login_password 必须设置为你使用的镜像仓库的凭证。当使用 Docker Hub 时，login_server 参数可以忽略。 注意：如果您使用上述凭据登录，后处理器随后会自动将您注销（仅指定的服务器）。 使用示例 Json： { \"post-processors\": [ [ { \"type\": \"docker-import\", \"repository\": \"myrepo/myimage\", \"tag\": \"0.7\" }, { \"type\": \"docker-push\" } ] ] } HCL2： post-processors { post-processor \"docker-import\" { repository = \"myrepo/myimage\" tag = \"0.7\" } post-processor \"docker-push\" {} } "},"10.post-processors/5.manifest.html":{"url":"10.post-processors/5.manifest.html","title":"Manifest","keywords":"","body":"Manifest 后处理器 原文 类型：manifest 制品构建器 ID：packer.post-processor.manifest manifest 后处理器会生成一个 JSON 文件，其中包含 Packer 程序在运行期间生成的所有制品的列表。如果您的 Packer 模板包含多个构建，该后处理器可以帮助您跟踪与每个构建相对应的输出制品（文件、AMI ID、Docker 容器等）。 每次构建完成并更新清单文件中的数据时都会调用 manifest 后处理器。构建通过名称和类型进行标识，并包括其构建时间、制品 ID 和文件列表。 如果 Packer 程序使用 -force 标志运行，则清单文件将在每次 Packer 运行期间自动截断。不然的话，后续构建将追加到该文件中。您可以使用时间戳来查看哪个是最新的制品。 您可以多次指定 manifest 并将每个构建写入其自己的文件，或将所有构建写入同一文件。对于简单的构建，manifest 只需指定一次（见下文），但您也可以将其与其他后处理器（例如 Docker 和 Artifice）链接在一起。 配置 可选参数 output（string）- 将 manifest 写入此文件。默认值为 packer-manifest.json。 strip_path (bool) - 仅写入文件名，不往清单文件中写入路径。默认为 false。 strip_time (bool) - 不要在输出时写入 build_time 字段。 custom_data (map[string]string) - 添加到清单的任意数据。该参数将搭配模板引擎。因此可以在此字段中使用用户变量和模板函数。 注意：与大多数其他后处理器不同，keep_input_artifact 选项不适用于本后处理器。我们将始终保留清单的输入制品，因为删除我们刚刚记录的文件是无意义的。 使用示例 Json： { \"post-processors\": [ { \"type\": \"manifest\" } ] } HCL2： post-processor \"manifest\" {} 一个更全面一些的例子： Json： { \"post-processors\": [ { \"type\": \"manifest\", \"output\": \"manifest.json\", \"strip_path\": true, \"custom_data\": { \"my_custom_data\": \"example\" } } ] } HCL2： post-processor \"manifest\" { output = \"manifest.json\" strip_path = true custom_data = { my_custom_data = \"example\" } } 生成的清单文件看起来可能像这样： { \"builds\": [ { \"name\": \"docker\", \"builder_type\": \"docker\", \"build_time\": 1507245986, \"files\": [ { \"name\": \"packer_example\", \"size\": 102219776 } ], \"artifact_id\": \"Container\", \"packer_run_uuid\": \"6d5d3185-fa95-44e1-8775-9e64fe2e2d8f\", \"custom_data\": { \"my_custom_data\": \"example\" } } ], \"last_run_uuid\": \"6d5d3185-fa95-44e1-8775-9e64fe2e2d8f\" } 如果再次运行构建，新的构建制品将添加到清单文件中，而不是替换原内容。可以使用 packer_run_uuid 从清单中获取特定的构建制品。 上面的清单是使用以下模板生成的： Json： { \"builders\": [ { \"type\": \"docker\", \"image\": \"ubuntu:latest\", \"export_path\": \"packer_example\", \"run_command\": [\"-d\", \"-i\", \"-t\", \"--entrypoint=/bin/bash\", \"{ {.Image} }\"] } ], \"post-processors\": [ { \"type\": \"manifest\", \"output\": \"manifest.json\", \"strip_path\": true, \"custom_data\": { \"my_custom_data\": \"example\" } } ] } HCL2： source \"docker\" \"docker\"{ image = \"ubuntu:latest\" export_path = \"packer_example\" run_command = [\"-d\", \"-i\", \"-t\", \"--entrypoint=/bin/bash\", \"{ {.Image} }\"] } build { sources = [\"docker.docker\"] post-processor \"manifest\" { output = \"manifest.json\" strip_path = true custom_data = { my_custom_data = \"example\" } } } 清单文件的用法示例： 清单对于清理旧制品或将重要值打印到日志非常有用。以下示例使用 jq（一种用于解析 json 输出的命令行工具）来查找并打印由构建创建的 AMI 的 AWS ami-id。 #!/bin/bash AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | cut -d \":\" -f2) echo $AMI_ID "},"10.post-processors/6.local_shell.html":{"url":"10.post-processors/6.local_shell.html","title":"Local Shell","keywords":"","body":"Local Shell 后处理器 原文 类型：shell-local Local Shell 后处理器在后处理阶段在本地执行脚本。shell-local 提供了一种使用 Packer 输出值和变量自动执行某些任务的便捷方法。 基础样例： 以下样例演示了一个具有完整功能的构建： HCL2： source \"file\" \"example\" { content = \"example content\" } build { source \"source.file.example\" { target = \"./test_artifact.txt\" } post-processor \"shell-local\" { inline = [\"echo foo\"] } } Json： { \"builders\": [ { \"type\": \"file\", \"name\": \"example\", \"target\": \"./test_artifact.txt\", \"content\": \"example content\" } ], \"post-processors\": [ { \"type\": \"shell-local\", \"inline\": [\"echo foo\"] } ] } 配置 下面列出了可用配置选项的参考。 以下参数中必须选择其一设置： command（string）- 该参数是要执行的单个命令。它将被写入临时文件并使用下面的execute_command 调用运行。 inline（[]string）- 这是要执行的命令数组。这些命令由换行符连接并转换为单个文件，因此它们都在同一上下文中执行。这允许您在一个命令中更改目录，并在下一个命令中使用目录中的某些内容，依此类推。inline 脚本是在机器内完成简单任务的最简单方法。 script（string）- 要执行的脚本的路径。该路径可以是绝对路径或相对路径。如果是相对的，就是相对于 Packer 执行时的工作目录。 scripts（[]string）- 要执行的脚本数组。脚本将按照指定的顺序执行。每个脚本都是独立执行的，因此一个脚本中的变量等状态不会延续到下一个脚本。 以下是可选参数： env (map[string]string) - 在 execute_command 之前注入的键/值对映射。 Packer 默认情况下也会将一些环境变量注入到环境中，这些内容将在后续的部分中介绍。重复的 env 设置会覆盖 environment_vars 设置。 environment_vars（[]string）- 在 execute_command 之前注入的键/值对数组。格式应为 key=value。 Packer 默认情况下也会将一些环境变量注入到环境中，这些内容将在后续的部分中介绍。 env_var_format (string) - 当我们解析您提供的 environment_vars 时，可以用该参数设置一个可以使用的字符串模板，以确保正确设置环境变量。默认情况下，在 Windows 主机上，该参数为 %s=%s &&；在 Unix 上，该参数为 %s='%s'。我们可能不需要更改此格式，但可以在下面查看需要更改的用法示例。 execute_command（[]string）- 用于执行脚本的命令。默认情况下，在 *nix 系统上这是： [\"/bin/sh\", \"-c\", \"{{.Vars}} {{.Script}}\"] 在 Windows 上，execute_command 默认为： [\"cmd\", \"/V\", \"/C\", \"{{.Vars}}\", \"call\", \"{{.Script}}\"] 该参数将搭配模板引擎使用。有几个可用的变量： Script：要运行的脚本的路径 Vars：环境变量的列表（如果已配置） 此外，我们可以使用构建模板功能访问存储在生成的数据中的任何变量。如果您选择设置此参数，请确保数组中的第一个元素是您要使用的 shell 程序（例如，sh 或 /usr/local/bin/zsh，甚至 powershell.exe。除了 shell 命令语言之外的任何语言都没有明确支持，并且可能会被 Packer 中所做的假设所破坏）。值得注意的是，如果您选择尝试对 Powershell 或其他 Windows 命令使用 shell-local，则将无法为您的环境正确设置环境变量。 为了向后兼容，execute_command 将接受字符串而不是字符串数组。如果提供了单个字符串或仅包含一个元素的字符串数组，Packer 将通过将您的 execute_command 添加到到字符串数组 [\"sh\", \"-c\"] 尾部来重现过去的行为。例如，如果设置 \"execute_command\"：\"foo bar\"，Packer 最终运行的 execute_command 将是 [\"sh\"，\"-c\"，\"foo bar\"]。如果设置为 \"execute_command\": [\"foo\", \"bar\"]，则最终的 execute_command 仍为 [\"foo\", \"bar\"]。 再次强调，上述的设计是为了向后兼容性做的补丁；我们强烈建议您将 execute_command 设置为字符串数组。 inline_shebang (string) - 运行 inline 指定的命令时使用的 shebang 值。默认值为 /bin/sh -e。如果您不使用 inline，则此参数无效。重要提示：如果您对此进行自定义，请务必包含类似 -e 标志的内容，否则个别步骤失败不会导致配置器失败。 keep_input_artifact (boolean) - 与大多数其他后处理器不同，keep_input_artifact 选项对 shell-local 后处理器没有影响。 Packer 将始终保留 shell-local 的输入制品，因为 shell-local 后处理器仅转发它接收到的制品。如果您的 shell-local 后处理器生成一个或多个您想要替换输入制品的文件，则可以在 shell-local 后处理器运行后使用 artifice 后处理器覆盖输入制品。 only_on（[]string） - 这是保存了一组 shell-local 将会执行的运行时操作系统的数组。该参数允许我们设置为仅在特定操作系统上执行 shell-local。默认情况下，如果未设置 only_on，shell-local 将始终运行。 use_linux_pathing (bool) - 这只与 Windows 主机相关。如果您在启用了 Windows Subsystem for Linux 功能的 Windows 环境中运行 Packer，并且想要调用 bash 脚本而不是调用 Cmd 脚本，则需要将此标志设置为 true；它告诉 Packer 使用 Linux 子系统路径来存储脚本，而不是 Windows 路径。 （例如 /mnt/c/path/to/your/file 而不是 C:/path/to/your/file）。请参阅下面的示例以获取有关如何使用此功能的更多指导。如果您不在 Windows 主机上，或者您不打算使用 shell-local 后处理器来运行 bash 脚本，请忽略此参数。如果将此标志设置为 true，则在设置脚本时仍需要提供脚本的标准 Windows 路径。该参数是测试版功能。 valid_exit_codes（[]int）- 脚本的有效退出代码。默认情况下该值为 0。 execute_command 参数详解 对于许多新用户来说，execute_command 令人困惑。然而，它提供了一个重要的功能：定制命令的执行方式。最常见的用例是处理 sudo 密码提示。如果您使用非 POSIX shell（例如 FreeBSD 上的 tcsh），您可能还需要定制化该参数。 Windows 的 Linux 子系统 shell-local 后处理器的设计理念是允许您在本地操作系统的原生 shell 中运行命令。对于 Windows，我们默认假设这是 Cmd。但是，通过修改后处理器配置中的 execute_command 和use_linux_pathing 选项，可以从 shell-local 后处理器将 bash 脚本作为 Windows Linux 子系统的一部分运行。 下面的示例是一个功能齐全的测试配置。 该功能的一个限制是您无法使用 inline 和 command 选项，只能使用 script 或 scripts 参数。 请注意，此功能仍处于测试阶段，因为底层 WSL 也仍处于测试阶段。因此会有一些限制。例如，除非 Packer 和您要运行的脚本都位于 C 驱动器上，否则它可能无法工作。 HCL2： source \"null\" \"example\" { communicator = \"none\" } build { sources = [ \"source.null.example\" ] post-processor \"shell-local\"{ environment_vars = [\"PROVISIONERTEST=ProvisionerTest1\"] execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true scripts = [\"C:/Users/me/scripts/example_bash.sh\"] } post-processor \"shell-local\"{ environment_vars = [\"PROVISIONERTEST=ProvisionerTest2\"] execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true script = \"C:/Users/me/scripts/example_bash.sh\" } } Json： { \"builders\": [ { \"type\": \"null\", \"communicator\": \"none\" } ], \"post-processors\": [ { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest1\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"scripts\": [\"C:/Users/me/scripts/example_bash.sh\"] }, { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest2\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"script\": \"C:/Users/me/scripts/example_bash.sh\" } ] } 默认的环境变量 除了能够使用 environment_vars 参数指定自定义环境变量之外，配置程序还自动设定某些常用的环境变量： PACKER_BUILD_NAME 设置为 Packer 正在运行的构建的名称。在 Packer 进行多个构建并且您希望将它们与常见的配置脚本稍微区分开来时，该参数将非常有用。 PACKER_BUILDER_TYPE 是用于创建运行脚本的计算机的构建器的类型。如果您只想在使用某些构建器上运行脚本的某些部分，该参数将非常有用。 编写安全的脚本 无论您使用 inline 参数，还是使用 script 或 scripts 参数，了解 shell-local 后处理器的工作原理，对以安全、轻松地运行脚本非常重要。这种理解将在此过程中为您节省大量时间。 每个构建器运行一次 您传递给 shell-local 的脚本将在每个构建器中运行一次。这意味着，如果您有 amazon-ebs 构建器和 docker 构建器，您的脚本将运行两次。如果您有 3 个构建器，它将运行 3 次，每个构建器运行一次。 与构建制品的互动 为了与构建制品交互，您可能需要使用 manifest 后处理器。该后处理器将在每个构建器运行后将构建器生成的文件列表写入一个 json 文件。 例如，如果您想将 file 构建器中的文件打包到 tarball 中，您可以这样写： Json： { \"builders\": [ { \"content\": \"Lorem ipsum dolor sit amet\", \"target\": \"dummy_artifact\", \"type\": \"file\" } ], \"post-processors\": [ [ { \"output\": \"manifest.json\", \"strip_path\": true, \"type\": \"manifest\" }, { \"inline\": [ \"jq \\\".builds[].files[].name\\\" manifest.json | xargs tar cfz artifacts.tgz\" ], \"type\": \"shell-local\" } ] ] } HCL2： source \"file\" \"example\" { content = \"Lorem ipsum dolor sit amet\" target = \"dummy_artifact.txt\" } build { sources = [ \"source.file.example\" ] post-processor \"manifest\" { output = \"manifest.json\" strip_path = true } post-processor \"shell-local\" { inline = [ \"jq \\\".builds[].files[].name\\\" manifest.json | xargs tar cfz artifacts.tgz\" ] } } 该例子使用 jq 工具从清单文件中提取所有文件名并将它们传递给 tar。 总是显式退出 任何后处理器失败都会触发 Packer 构建的停止，所有临时制品都会被清除。 对于 shell 脚本，这意味着脚本必须以代码 0 退出。您必须非常小心，在需要时显式地以 exit 0 命令退出。 使用示例 Windows 主机： 以下是一个在 Windows 主机上运行 .cmd 的示例： HCL2： post-processor \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest1\"] scripts = [\"./scripts/test_cmd.cmd\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest1\"], \"scripts\": [\"./scripts/test_cmd.cmd\"] } test_cmd.cmd 的内容： echo %SHELLLOCALTEST% 在 Windows 上运行 inline 命令的示例，需要自定义参数 tempfile_extension： HCL2： post-processor \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest2\"], tempfile_extension = \".cmd\", inline = [\"echo %SHELLLOCALTEST%\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest2\"], \"tempfile_extension\": \".cmd\", \"inline\": [\"echo %SHELLLOCALTEST%\"] } 使用 WSL 在 Windows 上运行 bash 命令的示例，需要自定义参数 use_linux_pathing 和 execute_command： HCL2： post-processor \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest3\"], execute_command = [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"] use_linux_pathing = true script = \"./scripts/example_bash.sh\" } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest3\"], \"execute_command\": [\"bash\", \"-c\", \"{{.Vars}} {{.Script}}\"], \"use_linux_pathing\": true, \"script\": \"./scripts/example_bash.sh\" } example_bash.sh 文件的内容： #!/bin/bash echo $SHELLLOCALTEST 在 Windows 上运行 PowerShell 脚本的示例，需要自定义参数 env_var_format 和 execute_command： HCL2： post-processor \"shell-local\" { environment_vars = [\"SHELLLOCALTEST=ShellTest4\"] execute_command = [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"] env_var_format = \"$env:%s=\\\"%s\\\"; \" script = \"./scripts/example_ps.ps1\" } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest4\"], \"execute_command\": [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"], \"env_var_format\": \"$env:%s=\\\"%s\\\"; \", \"script\": \"./scripts/example_ps.ps1\" } 在 Windows 上通过 inline 参数运行 PowerShell 脚本的示例，需要自定义参数 env_var_format、tempfile_extension 和 execute_command： HCL2： post-processor \"shell-local\" { tempfile_extension = \".ps1\" environment_vars = [\"SHELLLOCALTEST=ShellTest5\"] execute_command = [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"] env_var_format = \"$env:%s=\\\"%s\\\"; \" inline = [\"write-output $env:SHELLLOCALTEST\"] } Json： { \"type\": \"shell-local\", \"tempfile_extension\": \".ps1\", \"environment_vars\": [\"SHELLLOCALTEST=ShellTest5\"], \"execute_command\": [\"powershell.exe\", \"{{.Vars}} {{.Script}}\"], \"env_var_format\": \"$env:%s=\\\"%s\\\"; \", \"inline\": [\"write-output $env:SHELLLOCALTEST\"] } Unix 主机 在 Unix 主机上运行一段脚本的例子： HCL2： post-processor \"shell-local\" { environment_vars = [\"PROVISIONERTEST=ProvisionerTest1\"] scripts = [\"./scripts/example_bash.sh\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest1\"], \"scripts\": [\"./scripts/example_bash.sh\"] } 在 Unix 上通过 inline 参数运行 bash 脚本的例子： HCL2： post-processor \"shell-local\" { environment_vars = [\"PROVISIONERTEST=ProvisionerTest2\"] inline = [\"echo hello\", \"echo $PROVISIONERTEST\"] } Json： { \"type\": \"shell-local\", \"environment_vars\": [\"PROVISIONERTEST=ProvisionerTest2\"], \"inline\": [\"echo hello\", \"echo $PROVISIONERTEST\"] } 在 Unix 上运行一段 Python 脚本的例子： HCL2： post-processor \"shell-local\" { script = \"hello.py\" environment_vars = [\"HELLO_USER=packeruser\"] execute_command = [ \"/bin/sh\", \"-c\", \"{{.Vars}} /usr/local/bin/python {{.Script}}\" ] } Json： { \"type\": \"shell-local\", \"script\": \"hello.py\", \"environment_vars\": [\"HELLO_USER=packeruser\"], \"execute_command\": [ \"/bin/sh\", \"-c\", \"{{.Vars}} /usr/local/bin/python {{.Script}}\" ] } hello.py 文件的内容： import os print('Hello, %s!' % os.getenv(\"HELLO_USER\")) "},"11.postscript/overview.html":{"url":"11.postscript/overview.html","title":"后记","keywords":"","body":""},"11.postscript/1.html":{"url":"11.postscript/1.html","title":"中国的出路在于出海","keywords":"","body":"中国的出路在于出海 2022-2023 是中国的国内外形势发生剧烈变化的一年，实际上在过去几年里，不少云计算圈的朋友就有各种的观点，总的趋势是越来越悲观的。 我曾经有一篇感想《加拉帕戈斯云上没有千里马》，在文章里我的观点是在中国越来越多的私有云、政府云、央企云实际上是一种生产力的倒退。很遗憾的是从那之后的行业发展看，这种趋势愈演愈烈，中国为数不多的真公有云都遇到了严重的发展瓶颈。另外一个老生常谈的问题就是与美国不同，中国的 SaaS 行业始终无法得到很好的发展，中国本土的 SaaS 企业基本都过的不是很好，这与欧美百花齐放的 SaaS 业态形成了鲜明的对比。 许多的同行非常的灰心，在中国似乎做公有云做标准化的垂直 SaaS 没有希望。我想谈谈我自己的一点看法。 我先讲一个故事，国内某个公有云企业在大概 2018 年还是 2019 年突然开始组成了一个很小的团队，开发 Terraform Provider，当时国内并没有用户使用 Terraform 来编排在这家云平台上的资源，他们这么做的动机是什么呢？了解下来是因为他们当时接触了英国一家领先的网络游戏引擎公司，想引入对方在自家云平台上运营在华的平台产品，但对方提出了一个清单，就是他们正在使用的 DevOps 工具链名单，要想他们上自家的云，必须支持上面所有的工具，这里面就有 Terraform 和 Packer。我和某里云相关团队也交流过这个话题，他们之所有投入人力来做 Terraform Provider 也是因为有许多出海的团队同时使用某里云和 AWS，所以他们要求统一使用的工具链，要求某里云必须支持 Terraform。 我们国家过去实行了供给侧改革，这个词当时我完全不明白什么意思，从后来的观察来看，慢慢理解了所谓“供给侧结构性改革，就是从提高供给质量出发，用改革的办法推进结构调整，矫正要素配置扭曲，扩大有效供给，提高供给结构对需求变化的适应性和灵活性，提高全要素生产率，促进经济社会持续健康发展”的解释。 所谓供给侧改革主要就是动用行政力量压制落后和过剩的产能实现出清，使得资本和资源可以转向先进制造和社会未来亟需的领域。 那么中国现在至少在云计算和 SaaS 领域遇到的问题，实际上需要的是和供给侧改革相反的需求侧改革，目前的私有云，甚至是开始逐渐抬头的下云的声音，本质上是因为大量低水平的需求使得社会资源集中向落后生产力发展。 《芯片战争》这本书里介绍过芯片诞生的历史，美国空军发现用于炸弹制导的真空管非常昂贵，也非常易于损坏，德州仪器的工程师了解到这一点后联系到了军方，希望军方能够采纳德仪最新开发的集成电路芯片。美军正苦恼于在越战中一直无法成功炸断清化大桥，连续 7 年的狂轰滥炸，在 1965 年的滚雷行动中进行了 871 次空袭，损失 11 架飞机，大桥仍然屹立不倒。军方给了德仪一笔经费，让德仪使用芯片来制造激光制导炸弹，德仪后面的成功创造了两个历史，一是改变了战争形态的精确制导武器，另一个则是改变了人类历史的芯片。 优秀的产品也需要优秀的需求，假如美国没有之前轰炸清化大桥耻辱性的失败，没有对“把炸弹精准地投向目标”的需求，那么按照美军在越南习惯的地毯式轰炸的惯性，芯片的发展与人类的历史又将截然不同。 我在旧文《迈向现代化的云计算》试图论证这样一个观点，即公有云真正的目标用户实际上应该是工程师团队，因为只有工程师能够在使用中体会到公有云与传统的数据中心以及私有云的不同。当然目前所有主张私有云或是退回传统数据中心的主张都可以拿出一些站得住脚的论据，比如说成本，比如说他们认为的安全，但这些都不是站在工程师团队，站在开发测试运维团队的角度来说的。 中国云计算行业当下的问题，SaaS 产业与国外的冰火两重天，实际上是由于中国和欧美相关产业目前正处于不同的发展阶段。在中国，信息技术带来的效率差异对商业成功的贡献占比不大，更多的是政策、资源、资本投入方面的差异决定的，在这种前提下工程师团队的效率并不是最重要的，也就导致了产业发展的形态不同。 我无意评论这种差异谁对谁错，不同的国家在不同的发展阶段可能适用于不同的政策，但是最终产业会开始比拼效率，国家间开始比拼全要素生产率。 中国共产党历史上曾经有过“立三路线”，盲目地想要直接在大城市发动暴动，占领大城市，建立政权，结果就是碰的头破血流，最终采用了“农村包围城市”的战略完成了中国革命。如今有志于追赶国际先进水平的中国云计算与 SaaS 团队也需要寻找属于自己的根据地徐图发展，如果国内目前的客观条件不允许，那么可行的出路可能就是出海。 在过去的一年中我与不少优秀的产品团队交流下来都是一个感受，那就是国外客户的付费意愿强，而且识货，你的产品如果真的先进、好用，国外客户当天就可以付费订阅。如果说中华民族的伟大复兴是属于这个民族的昭昭天命，那么我们这个行业要做的就是种下这个行业发展的种子，通过占领国际市场来积累技术和力量，等到国内大环境变得适合公有云与 SaaS 发展时再反攻回来，而且我坚信这一天终将是要到来的，一定是会到来的，因为客观规律在那里，最终一定是要走提升全要素生产率这条路的。 维基百科上对“反动”一词的解释是： 在政治学中，反动是指主张将事物恢复原状的政治观点，抱持这种观点的人一般认为原本社会拥有现在社会所不具有的积极特征。 我在这里讨论的“反动”是一个中性词，近年来中国出现的私有云浪潮，以及下云论，在我看来就是一种主张回到过去的观点，是一种技术反动路线。我相信我在旧文《中国的云计算革命尚未开始》一文中举的“电气化用了 50 年才在纺织领域取代了蒸汽机”的故事也适用于公有云和 SaaS，我们需要的是时间、耐心，以及属于本土从业者的根据地。 中国开放的大门不仅不会关上，还要越开越大，这一点我们这两年可以在新能源汽车、光伏风电电池等领域观察到产业升级以及进一步攻占全球更高端的市场的势头。中国没有后路可退，只有玩命完成产业升级，去夺取越来越多的国际市场份额，这对中国公有云以及 SaaS 产业来说也是一样的，最终中国的相关企业可能需要走一条看起来非常奇怪的路线：欲征服中国市场，必先征服全球市场。 "},"11.postscript/2.html":{"url":"11.postscript/2.html","title":"真后记","keywords":"","body":"真后记 其实原本是想今年翻译 Consul 或者 Nomad 的文档的，但这俩产品看起来都是不小的工作量，去年《Vault 中文手册》的翻译工作导致了角膜炎，2022 年很长的一段时间里都有畏光、迎风流泪的情况，后来看了医生用了眼药水才好了一些，所以今年选择翻译目标时想偷个懒，选了看起来简单一些的 Packer，但没想到 Packer 的功能也早已不是当年我用它时候的规模了，工作量着实比我一开始想象的要大，但今年因为各方面的原因不像去年那么拼，所以翻译工作做的比较慢。 2022 年上海经历了封城，我自己是被封在家里 87 天，然后年底奥密克戎在全国肆虐，最终开始了“乙类乙管”，也就是实际上的不管。我还记得去年组里开会，谈谈后面一段时间最担心的事和最大的期望，有年轻的同事说最大的期望就是结束疫情管控，好让他可以放松一下，像以前那样出去旅行。 有些人会觉得写到这里我是要控诉惨无人道的封禁政策，实际上不是的。我想说的恰恰相反。在这里我想讲两个故事聊表纪念。 在去年宣布解封前，我看到新闻，部分地区政府给药店和医院发文要求提前准备好退烧药品，当时心下感觉不妙，就开始提前准备对乙酰氨基酚以及布洛芬退烧药，还有含有利多卡因成分的润喉糖，并且提前给父母反复灌输要非常严肃地应对即将到来的疫情高峰的观念，提前准备了足够的食物和生活用品，在全国集中发烧的那段时间里，我和我太太，我父母，两户人家基本都是完全在家自我隔离严防死守，所以躲过了那一波高峰。 在疫情最严重的时候，腾讯在他们的打车微信小程序平台上改造出了一个基于地理位置的紧急发烧药求助平台。我因为提前阅读了一些非常棒的文章，所以有所准备，购买的 1200 片对乙酰氨基酚到了 200 片，我通过阅读了解到对乙酰氨基酚单方是孕妇唯一可用的退烧药，而且高热可能会危及到胎儿的生命安全，于是我决定将手上的对乙酰氨基酚全部用于援助孕妇。在那几天中我基本上是时刻监控小程序上有没有标注为孕妇的求助信息，有的是叫闪送到付送药，有的是亲自开车送药，我成功地给 21 名孕妇送去了她们急需的退烧药，其中一名孕妇告诉我她怀的是双胞胎，也就是说我帮助了 22 名宝宝。 我在孕妇们退烧以后基本没有和她们有任何联系，因为我相信不若相忘于江湖，我们的缘分仅限于那个不正常的时期，过后大家还是各自前进，但我请求她们能够在宝宝降生后发一张照片给我，让我留个纪念。很可惜到目前为止我只收到了个位数的照片，我也不想去讨要，可能她们正忙于应付新生命到来带来的各种麻烦，或是经济下行带来的各种压力吧，希望这 22 名宝宝都能平安健康，快快长大。 第二个故事是我的外婆今年不幸罹患新冠而去世了，享年九十多岁。我小的时候外婆非常宠我，买老母鸡烧鸡汤给我喝，夏天我睡午觉时嫌热，外婆就会用大蒲扇扇着风哄我睡觉，点点滴滴现在想来都如同发生在昨天一般。 外婆是旧社会出生的人，但她念过书，按照她的说法是念到高小，她甚至会三角函数。外婆家曾经家境尚可，后来似乎家道中落，与妹妹来到上海，成为了纺织工人。印象里的外婆就是抽大前门香烟，用大茶缸泡浓茶喝，就是工人的做派。后来外婆不幸罹患阿尔茨海默症，完全认不出我了，但即使认不出我，看到我还是会很慈祥地微笑，问我吃没吃过饭。最爱我的外婆，死于新冠病毒。 我曾经为中国的疫情管控政策辩护，我极其反感那些举白纸的人。我被人蔑称封控爱好者，老孩侠，还有人问说你怎么现在不提老人孩子了？ 最爱我的那个老人，已经死了啊。人生最感无助的事，就是你预见到了巨大的灾难就在眼前，但你无能为力。你只能抹掉眼泪，孤独地继续前进。 1 条生命的逝去，22 条生命的到来，几家欢喜，几家愁。 我会持续做相关的翻译和写作工作，因为我坚信中国开放的大门不能关上，理性的声音不能绝。在此感谢拍帮主、Luxenius、林一五等作者的文章。虽然这篇后记与 Packer 本身没有什么关系，但作为译者我想我有这个特权用这个小小的篇幅纪念生命中难忘而重要的一年。 "}}